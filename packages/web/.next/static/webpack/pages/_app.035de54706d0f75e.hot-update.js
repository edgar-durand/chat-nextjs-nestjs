"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"../../node_modules/next/dist/build/polyfills/process.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    createRoom: async ()=>({\n            _id: \"\",\n            name: \"\",\n            creator: {\n                _id: \"\",\n                name: \"\",\n                email: \"\",\n                avatar: \"\"\n            },\n            members: [],\n            isPrivate: false,\n            createdAt: \"\"\n        }),\n    joinRoom: async ()=>{},\n    leaveRoom: async ()=>{},\n    setTyping: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const API_URL = process.env.NEXT_PUBLIC_API_URL || \"http://localhost:3001\";\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        var _socketRef_current;\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n                setSocketConnected(false);\n            }\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        // Don't reconnect if already connected\n        if ((_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected) {\n            return;\n        }\n        // Disconnect any existing socket before creating a new one\n        if (socketRef.current) {\n            socketRef.current.disconnect();\n        }\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            reconnectionAttempts: 5,\n            reconnectionDelay: 1000,\n            timeout: 10000\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"connect_error\", (error)=>{\n            console.error(\"Socket connection error:\", error);\n            setSocketConnected(false);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            // Only add the message if it's relevant to the active chat\n            if (!currentActiveChatRef.current) return;\n            if (currentActiveChatRef.current.type === \"private\" && (message.sender._id === currentActiveChatRef.current.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === currentActiveChatRef.current.id) || currentActiveChatRef.current.type === \"room\" && message.room === currentActiveChatRef.current.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            if (!currentActiveChatRef.current) return;\n            if (currentActiveChatRef.current.type === \"private\" && data.senderId === currentActiveChatRef.current.id || currentActiveChatRef.current.type === \"room\" && data.roomId === currentActiveChatRef.current.id) {\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            // Clean up previous active chat when component unmounts\n            leaveActiveChat();\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n                setSocketConnected(false);\n            }\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Keep reference of active chat updated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    // Helper function to leave active chat\n    const leaveActiveChat = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!socketRef.current || !currentActiveChatRef.current) return;\n        try {\n            if (currentActiveChatRef.current.type === \"private\") {\n                socketRef.current.emit(\"leave_room\", {\n                    userId: currentActiveChatRef.current.id\n                });\n            } else {\n                socketRef.current.emit(\"leave_room\", {\n                    roomId: currentActiveChatRef.current.id\n                });\n            }\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n        }\n    }, []);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Load messages when activeChat changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated || !socketConnected) {\n            setMessages([]);\n            return;\n        }\n        // First leave previous room if any\n        leaveActiveChat();\n        const fetchMessages = async ()=>{\n            try {\n                setIsLoading(true);\n                let response;\n                if (activeChat.type === \"private\") {\n                    var _socketRef_current;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id));\n                    // Join user room for direct messages\n                    if ((_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected) {\n                        socketRef.current.emit(\"join_room\", {\n                            userId: activeChat.id\n                        });\n                    }\n                } else {\n                    var _socketRef_current1;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id));\n                    // Join room\n                    if ((_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.connected) {\n                        socketRef.current.emit(\"join_room\", {\n                            roomId: activeChat.id\n                        });\n                    }\n                }\n                setMessages(response.data);\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchMessages();\n        // Clear typing indicator when changing chats\n        setTypingUsers({});\n    // No cleanup function here - we'll handle leaving rooms in the leaveActiveChat function\n    }, [\n        activeChat,\n        isAuthenticated,\n        API_URL,\n        socketConnected,\n        leaveActiveChat\n    ]);\n    const sendMessage = async (content)=>{\n        var _socketRef_current;\n        if (!activeChat || !user || !((_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected)) return;\n        try {\n            const messageData = {\n                content,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            socketRef.current.emit(\"send_message\", messageData);\n        } catch (error) {\n            console.error(\"Error sending message:\", error);\n            throw error;\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            setRooms((prev)=>[\n                    ...prev,\n                    data\n                ]);\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId)=>{\n        if (!user) return;\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(user.id));\n            setRooms((prev)=>prev.map((room)=>room._id === roomId ? data : room));\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId)=>{\n        if (!user) return;\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(user.id));\n            setRooms((prev)=>prev.map((room)=>room._id === roomId ? data : room));\n            // If active chat is this room, clear it\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === roomId) {\n                setActiveChat(null);\n            }\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        var _socketRef_current;\n        if (!activeChat || !((_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.connected)) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            setActiveChat,\n            sendMessage,\n            createRoom,\n            joinRoom,\n            leaveRoom,\n            setTyping\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 370,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"eMaiGshLIK2E/kPWlcAp3NMk2Nc=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQzNCNUY7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQVM7WUFDQUM7WUFDQUM7UUFDRjtrQkFDR0c7Ozs7OztBQUdQLEVBQUU7SUEvVFdEOztRQUN1QnhCLGlEQUFPQTs7O0tBRDlCd0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL0NoYXRDb250ZXh0LnRzeD8wYjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICcuL0F1dGhDb250ZXh0JztcblxuaW50ZXJmYWNlIFVzZXIge1xuICBfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhdmF0YXI6IHN0cmluZztcbiAgaXNPbmxpbmU/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgTWVzc2FnZSB7XG4gIF9pZDogc3RyaW5nO1xuICBjb250ZW50OiBzdHJpbmc7XG4gIHNlbmRlcjogVXNlcjtcbiAgcmVjaXBpZW50Pzogc3RyaW5nO1xuICByb29tPzogc3RyaW5nO1xuICBpc1JlYWQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUm9vbSB7XG4gIF9pZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpbWFnZT86IHN0cmluZztcbiAgY3JlYXRvcjogVXNlcjtcbiAgbWVtYmVyczogVXNlcltdO1xuICBpc1ByaXZhdGU6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQ2hhdENvbnRleHRUeXBlIHtcbiAgYWN0aXZlQ2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHJvb21zOiBSb29tW107XG4gIG9ubGluZVVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcbiAgdXNlcnM6IFVzZXJbXTtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHNldEFjdGl2ZUNoYXQ6IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGNyZWF0ZVJvb206IChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nLCBpc1ByaXZhdGU/OiBib29sZWFuLCBtZW1iZXJzPzogc3RyaW5nW10pID0+IFByb21pc2U8Um9vbT47XG4gIGpvaW5Sb29tOiAocm9vbUlkOiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGxlYXZlUm9vbTogKHJvb21JZDogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzZXRUeXBpbmc6IChpc1R5cGluZzogYm9vbGVhbikgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZT4oe1xuICBhY3RpdmVDaGF0OiBudWxsLFxuICBtZXNzYWdlczogW10sXG4gIHJvb21zOiBbXSxcbiAgb25saW5lVXNlcnM6IHt9LFxuICB1c2VyczogW10sXG4gIHR5cGluZ1VzZXJzOiB7fSxcbiAgaXNMb2FkaW5nOiB0cnVlLFxuICBzZXRBY3RpdmVDaGF0OiAoKSA9PiB7fSxcbiAgc2VuZE1lc3NhZ2U6IGFzeW5jICgpID0+IHt9LFxuICBjcmVhdGVSb29tOiBhc3luYyAoKSA9PiAoeyBfaWQ6ICcnLCBuYW1lOiAnJywgY3JlYXRvcjogeyBfaWQ6ICcnLCBuYW1lOiAnJywgZW1haWw6ICcnLCBhdmF0YXI6ICcnIH0sIG1lbWJlcnM6IFtdLCBpc1ByaXZhdGU6IGZhbHNlLCBjcmVhdGVkQXQ6ICcnIH0pLFxuICBqb2luUm9vbTogYXN5bmMgKCkgPT4ge30sXG4gIGxlYXZlUm9vbTogYXN5bmMgKCkgPT4ge30sXG4gIHNldFR5cGluZzogKCkgPT4ge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IENoYXRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IHVzZXIsIGlzQXV0aGVudGljYXRlZCB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbYWN0aXZlQ2hhdCwgc2V0QWN0aXZlQ2hhdF0gPSB1c2VTdGF0ZTx7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtyb29tcywgc2V0Um9vbXNdID0gdXNlU3RhdGU8Um9vbVtdPihbXSk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8VXNlcltdPihbXSk7XG4gIGNvbnN0IFtvbmxpbmVVc2Vycywgc2V0T25saW5lVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcbiAgY29uc3QgW3R5cGluZ1VzZXJzLCBzZXRUeXBpbmdVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzb2NrZXRDb25uZWN0ZWQsIHNldFNvY2tldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRBY3RpdmVDaGF0UmVmID0gdXNlUmVmPHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsPihudWxsKTtcbiAgXG4gIGNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBzb2NrZXQgY29ubmVjdGlvbiB3aGVuIGF1dGhlbnRpY2F0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCB8fCAhdXNlcikge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIFxuICAgIGlmICghdG9rZW4pIHJldHVybjtcbiAgICBcbiAgICAvLyBEb24ndCByZWNvbm5lY3QgaWYgYWxyZWFkeSBjb25uZWN0ZWRcbiAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQ/LmNvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBEaXNjb25uZWN0IGFueSBleGlzdGluZyBzb2NrZXQgYmVmb3JlIGNyZWF0aW5nIGEgbmV3IG9uZVxuICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKEFQSV9VUkwsIHtcbiAgICAgIGF1dGg6IHsgdG9rZW4gfSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgIHJlY29ubmVjdGlvbkF0dGVtcHRzOiA1LFxuICAgICAgcmVjb25uZWN0aW9uRGVsYXk6IDEwMDAsXG4gICAgICB0aW1lb3V0OiAxMDAwMFxuICAgIH0pO1xuICAgIFxuICAgIC8vIFNvY2tldCBldmVudCBsaXN0ZW5lcnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3RfZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1NvY2tldCBjb25uZWN0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19tZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHtcbiAgICAgIC8vIE9ubHkgYWRkIHRoZSBtZXNzYWdlIGlmIGl0J3MgcmVsZXZhbnQgdG8gdGhlIGFjdGl2ZSBjaGF0XG4gICAgICBpZiAoIWN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIFxuICAgICAgaWYgKFxuICAgICAgICAoY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudC50eXBlID09PSAncHJpdmF0ZScgJiYgXG4gICAgICAgICAgKChtZXNzYWdlLnNlbmRlci5faWQgPT09IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IHVzZXIuaWQpIHx8IFxuICAgICAgICAgICAobWVzc2FnZS5zZW5kZXIuX2lkID09PSB1c2VyLmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50LmlkKSkpIHx8XG4gICAgICAgIChjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50LnR5cGUgPT09ICdyb29tJyAmJiBtZXNzYWdlLnJvb20gPT09IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQuaWQpXG4gICAgICApIHtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VyX3N0YXR1c19jaGFuZ2UnLCAoeyB1c2VySWQsIGlzT25saW5lIH0pID0+IHtcbiAgICAgIHNldE9ubGluZVVzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IGlzT25saW5lIH0pKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndHlwaW5nX2luZGljYXRvcicsIChkYXRhOiB7IHVzZXJJZDogc3RyaW5nLCB1c2VyTmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbiwgcm9vbUlkPzogc3RyaW5nLCBzZW5kZXJJZD86IHN0cmluZyB9KSA9PiB7XG4gICAgICBpZiAoIWN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICAgIFxuICAgICAgaWYgKFxuICAgICAgICAoY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudC50eXBlID09PSAncHJpdmF0ZScgJiYgZGF0YS5zZW5kZXJJZCA9PT0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudC5pZCkgfHxcbiAgICAgICAgKGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQudHlwZSA9PT0gJ3Jvb20nICYmIGRhdGEucm9vbUlkID09PSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50LmlkKVxuICAgICAgKSB7XG4gICAgICAgIHNldFR5cGluZ1VzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW2RhdGEudXNlcklkXTogZGF0YS5pc1R5cGluZyB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ21lc3NhZ2VfcmVhZCcsICh7IG1lc3NhZ2VJZCB9KSA9PiB7XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChtc2cgPT4gXG4gICAgICAgICAgbXNnLl9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIGlzUmVhZDogdHJ1ZSB9IDogbXNnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgcHJldmlvdXMgYWN0aXZlIGNoYXQgd2hlbiBjb21wb25lbnQgdW5tb3VudHNcbiAgICAgIGxlYXZlQWN0aXZlQ2hhdCgpO1xuICAgICAgXG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgdXNlciwgQVBJX1VSTF0pO1xuICBcbiAgLy8gS2VlcCByZWZlcmVuY2Ugb2YgYWN0aXZlIGNoYXQgdXBkYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQgPSBhY3RpdmVDaGF0O1xuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGxlYXZlIGFjdGl2ZSBjaGF0XG4gIGNvbnN0IGxlYXZlQWN0aXZlQ2hhdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50IHx8ICFjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGlmIChjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdsZWF2ZV9yb29tJywgeyB1c2VySWQ6IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQuaWQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdsZWF2ZV9yb29tJywgeyByb29tSWQ6IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQuaWQgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbXSk7XG4gIFxuICAvLyBMb2FkIGluaXRpYWwgZGF0YTogdXNlcnMgYW5kIHJvb21zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZldGNoSW5pdGlhbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBbdXNlcnNSZXNwb25zZSwgcm9vbXNSZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzYCksXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3Jvb21zL215YClcbiAgICAgICAgXSk7XG4gICAgICAgIFxuICAgICAgICBzZXRVc2Vycyh1c2Vyc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBzZXRSb29tcyhyb29tc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb25saW5lIHN0YXR1c1xuICAgICAgICBjb25zdCBpbml0aWFsT25saW5lU3RhdHVzID0ge307XG4gICAgICAgIHVzZXJzUmVzcG9uc2UuZGF0YS5mb3JFYWNoKHVzZXIgPT4ge1xuICAgICAgICAgIGluaXRpYWxPbmxpbmVTdGF0dXNbdXNlci5faWRdID0gdXNlci5pc09ubGluZSB8fCBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE9ubGluZVVzZXJzKGluaXRpYWxPbmxpbmVTdGF0dXMpO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGluaXRpYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hJbml0aWFsRGF0YSgpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBMb2FkIG1lc3NhZ2VzIHdoZW4gYWN0aXZlQ2hhdCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFpc0F1dGhlbnRpY2F0ZWQgfHwgIXNvY2tldENvbm5lY3RlZCkge1xuICAgICAgc2V0TWVzc2FnZXMoW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICAvLyBGaXJzdCBsZWF2ZSBwcmV2aW91cyByb29tIGlmIGFueVxuICAgIGxlYXZlQWN0aXZlQ2hhdCgpO1xuICAgIFxuICAgIGNvbnN0IGZldGNoTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiB1c2VyIHJvb20gZm9yIGRpcmVjdCBtZXNzYWdlc1xuICAgICAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudD8uY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdqb2luX3Jvb20nLCB7IHVzZXJJZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7QVBJX1VSTH0vY2hhdHMvcm9vbS8ke2FjdGl2ZUNoYXQuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiByb29tXG4gICAgICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50Py5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0TWVzc2FnZXMocmVzcG9uc2UuZGF0YSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtZXNzYWdlczonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hNZXNzYWdlcygpO1xuICAgIFxuICAgIC8vIENsZWFyIHR5cGluZyBpbmRpY2F0b3Igd2hlbiBjaGFuZ2luZyBjaGF0c1xuICAgIHNldFR5cGluZ1VzZXJzKHt9KTtcbiAgICBcbiAgICAvLyBObyBjbGVhbnVwIGZ1bmN0aW9uIGhlcmUgLSB3ZSdsbCBoYW5kbGUgbGVhdmluZyByb29tcyBpbiB0aGUgbGVhdmVBY3RpdmVDaGF0IGZ1bmN0aW9uXG4gIH0sIFthY3RpdmVDaGF0LCBpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkwsIHNvY2tldENvbm5lY3RlZCwgbGVhdmVBY3RpdmVDaGF0XSk7XG4gIFxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIXVzZXIgfHwgIXNvY2tldFJlZi5jdXJyZW50Py5jb25uZWN0ZWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnc2VuZF9tZXNzYWdlJywgbWVzc2FnZURhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgY3JlYXRlUm9vbSA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uID0gJycsIGlzUHJpdmF0ZSA9IGZhbHNlLCBtZW1iZXJzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tc2AsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGlzUHJpdmF0ZSxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBzZXRSb29tcyhwcmV2ID0+IFsuLi5wcmV2LCBkYXRhXSk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBqb2luUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt1c2VyLmlkfWApO1xuICAgICAgXG4gICAgICBzZXRSb29tcyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChyb29tID0+IFxuICAgICAgICAgIHJvb20uX2lkID09PSByb29tSWQgPyBkYXRhIDogcm9vbVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBqb2luaW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgbGVhdmVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dXNlci5pZH1gKTtcbiAgICAgIFxuICAgICAgc2V0Um9vbXMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocm9vbSA9PiBcbiAgICAgICAgICByb29tLl9pZCA9PT0gcm9vbUlkID8gZGF0YSA6IHJvb21cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gSWYgYWN0aXZlIGNoYXQgaXMgdGhpcyByb29tLCBjbGVhciBpdFxuICAgICAgaWYgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBhY3RpdmVDaGF0LmlkID09PSByb29tSWQpIHtcbiAgICAgICAgc2V0QWN0aXZlQ2hhdChudWxsKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbGVhdmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHNldFR5cGluZyA9IChpc1R5cGluZzogYm9vbGVhbikgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhc29ja2V0UmVmLmN1cnJlbnQ/LmNvbm5lY3RlZCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHR5cGluZ0RhdGEgPSB7XG4gICAgICBpc1R5cGluZyxcbiAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgIH07XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgndHlwaW5nJywgdHlwaW5nRGF0YSk7XG4gIH07XG4gIFxuICByZXR1cm4gKFxuICAgIDxDaGF0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgYWN0aXZlQ2hhdCxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgcm9vbXMsXG4gICAgICBvbmxpbmVVc2VycyxcbiAgICAgIHVzZXJzLFxuICAgICAgdHlwaW5nVXNlcnMsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBzZXRBY3RpdmVDaGF0LFxuICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICBjcmVhdGVSb29tLFxuICAgICAgam9pblJvb20sXG4gICAgICBsZWF2ZVJvb20sXG4gICAgICBzZXRUeXBpbmcsXG4gICAgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJpbyIsImF4aW9zIiwidXNlQXV0aCIsIkNoYXRDb250ZXh0IiwiYWN0aXZlQ2hhdCIsIm1lc3NhZ2VzIiwicm9vbXMiLCJvbmxpbmVVc2VycyIsInVzZXJzIiwidHlwaW5nVXNlcnMiLCJpc0xvYWRpbmciLCJzZXRBY3RpdmVDaGF0Iiwic2VuZE1lc3NhZ2UiLCJjcmVhdGVSb29tIiwiX2lkIiwibmFtZSIsImNyZWF0b3IiLCJlbWFpbCIsImF2YXRhciIsIm1lbWJlcnMiLCJpc1ByaXZhdGUiLCJjcmVhdGVkQXQiLCJqb2luUm9vbSIsImxlYXZlUm9vbSIsInNldFR5cGluZyIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic29ja2V0Q29ubmVjdGVkIiwic2V0U29ja2V0Q29ubmVjdGVkIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJjdXJyZW50IiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImNvbm5lY3RlZCIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJyZWNvbm5lY3Rpb25BdHRlbXB0cyIsInJlY29ubmVjdGlvbkRlbGF5IiwidGltZW91dCIsIm9uIiwiY29uc29sZSIsImxvZyIsImVycm9yIiwibWVzc2FnZSIsInR5cGUiLCJzZW5kZXIiLCJpZCIsInJlY2lwaWVudCIsInJvb20iLCJwcmV2IiwidXNlcklkIiwiaXNPbmxpbmUiLCJkYXRhIiwic2VuZGVySWQiLCJyb29tSWQiLCJpc1R5cGluZyIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImxlYXZlQWN0aXZlQ2hhdCIsImVtaXQiLCJmZXRjaEluaXRpYWxEYXRhIiwidXNlcnNSZXNwb25zZSIsInJvb21zUmVzcG9uc2UiLCJQcm9taXNlIiwiYWxsIiwiZ2V0IiwiaW5pdGlhbE9ubGluZVN0YXR1cyIsImZvckVhY2giLCJmZXRjaE1lc3NhZ2VzIiwicmVzcG9uc2UiLCJjb250ZW50IiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsImRlc2NyaXB0aW9uIiwicG9zdCIsImRlbGV0ZSIsInR5cGluZ0RhdGEiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});