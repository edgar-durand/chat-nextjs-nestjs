"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>0,\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFilesByChat, setUploadingFilesByChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const uploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!activeChat) return {};\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        return uploadingFilesByChat[chatId] || {};\n    }, [\n        activeChat,\n        uploadingFilesByChat\n    ]);\n    const updateUploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chatId, fileId, status)=>{\n        setUploadingFilesByChat((prev)=>{\n            const newState = {\n                ...prev\n            };\n            // Inicializar el objeto del chat si no existe\n            if (!newState[chatId]) {\n                newState[chatId] = {};\n            }\n            // Si status es null, eliminar el archivo\n            if (status === null) {\n                if (newState[chatId][fileId]) {\n                    delete newState[chatId][fileId];\n                }\n            } else {\n                // Actualizar el estado del archivo\n                newState[chatId][fileId] = status;\n            }\n            // Si no hay archivos en este chat, eliminar el objeto del chat\n            if (Object.keys(newState[chatId]).length === 0) {\n                delete newState[chatId];\n            }\n            return newState;\n        });\n    }, []);\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId || !activeChat) return;\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, null);\n    };\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envío de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room_\".concat(message.room);\n            } else if (message.sender._id !== user.id) {\n                chatKey = \"user_\".concat(message.sender._id);\n            } else if (message.recipient) {\n                chatKey = \"user_\".concat(message.recipient);\n            }\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leídos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leídos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leídos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leídos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = activeChat.type === \"private\" ? \"user_\".concat(activeChat.id) : \"room_\".concat(activeChat.id);\n            // Resetear el contador de mensajes no leídos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leído\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // Función para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leídas cuando se activa un chat\n        if (chat) {\n            const chatKey = chat.type === \"private\" ? \"user_\".concat(chat.id) : \"room_\".concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Cargar mensajes cuando se selecciona un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !user || !isAuthenticated) {\n            setMessages([]);\n            setIsLoadingMessages(false);\n            return;\n        }\n        setIsLoadingMessages(true);\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leídos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    const sendMessage = async (content, attachments)=>{\n        if (!socketRef.current || !activeChat) return;\n        try {\n            // Generar tempIds para los archivos y convertirlos a FileAttachment\n            const attachmentsWithIds = [];\n            if (attachments && attachments.length > 0) {\n                for (const file of attachments){\n                    const tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n                    // Determinar tipo de archivo de forma segura\n                    let fileType = \"document\";\n                    const fileTypeString = file.type || \"\"; // Usar string vacío si type es undefined\n                    if (fileTypeString.startsWith(\"image/\")) {\n                        fileType = \"image\";\n                    } else if (fileTypeString.startsWith(\"video/\")) {\n                        fileType = \"video\";\n                    } else if (fileTypeString.startsWith(\"audio/\")) {\n                        fileType = \"audio\";\n                    } else {\n                        fileType = \"document\";\n                    }\n                    // Crear objeto FileAttachment para el archivo\n                    const attachment = {\n                        tempId,\n                        filename: file.name || \"archivo\",\n                        contentType: file.type || \"application/octet-stream\",\n                        fileType,\n                        size: file.size || 0\n                    };\n                    // Si es un archivo grande, lo procesamos para subida en segundo plano\n                    if (file.size > 5 * 1024 * 1024) {\n                        attachment.isLargeFile = true;\n                        // Leer como base64 para preprocesamiento\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Iniciar subida en segundo plano\n                        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n                        updateUploadingFiles(chatId, tempId, {\n                            progress: 0,\n                            error: undefined\n                        });\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                        // Iniciar subida en segundo plano\n                        uploadLargeFileToServer(attachment).then((fileId)=>{\n                            if (fileId) {\n                                // Actualizar el attachment con el fileId\n                                attachment.fileId = fileId;\n                                attachment.isLargeFile = true;\n                                attachment.data = undefined; // Eliminar los datos binarios\n                                // Actualizar progreso a 100%\n                                updateUploadingFiles(chatId, tempId, {\n                                    progress: 100,\n                                    error: undefined\n                                });\n                            }\n                        }).catch((error)=>{\n                            console.error(\"Error subiendo archivo:\", error);\n                            updateUploadingFiles(chatId, tempId, {\n                                progress: 0,\n                                error: error.message || \"Error al subir el archivo\"\n                            });\n                        });\n                    } else {\n                        // Para archivos pequeños (<5MB), leerlos como base64 y enviar con el mensaje\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                    }\n                }\n            }\n            // Preparar datos del mensaje\n            const messageData = {\n                content,\n                attachments: attachmentsWithIds,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            // Enviar el mensaje a través del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                if (!response.success) {\n                    console.error(\"Error al enviar mensaje:\", response.error);\n                }\n            });\n            // Limpiar formulario después de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar mensaje:\", error);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // Implementación de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, {\n            progress: 0,\n            error: undefined\n        });\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya está subido\n            updateUploadingFiles(chatId, file.tempId, {\n                progress: 100,\n                error: undefined\n            });\n        }\n    };\n    // Función auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: undefined\n            });\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    updateUploadingFiles(chatId, attachment.tempId, {\n                        progress: percentCompleted,\n                        error: undefined\n                    });\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: error.message || \"Error al subir el archivo\"\n            });\n            return null;\n        }\n    };\n    // Esta función se encarga de marcar un mensaje como leído\n    const handleMarkAsRead = (messageId)=>{\n        if (!socketRef.current) return;\n        socketRef.current.emit(\"mark_message_read\", {\n            messageId\n        });\n        // Actualizar el estado de mensajes localmente\n        setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                    ...msg,\n                    isRead: true\n                } : msg));\n    };\n    // Esta función carga más mensajes para la paginación\n    const fetchMoreMessages = async (beforeMessageId)=>{\n        if (!activeChat || !isAuthenticated) return;\n        try {\n            let endpoint = \"\";\n            if (activeChat.type === \"private\") {\n                endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            } else {\n                endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            }\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n            // Añadir los mensajes anteriores al inicio del array de mensajes\n            setMessages((prev)=>[\n                    ...response.data,\n                    ...prev\n                ]);\n            return response.data.length;\n        } catch (error) {\n            console.error(\"Error al cargar m\\xe1s mensajes:\", error);\n            return 0;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            markAsRead: handleMarkAsRead,\n            startTyping: ()=>setTyping(true),\n            stopTyping: ()=>setTyping(false),\n            loadMoreMessages: fetchMoreMessages,\n            retryFileUpload,\n            cancelFileUpload\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 776,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"nmkhtaPAlYcE9ROK0SMDquUSxsM=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QkFBd0N1SSxPQUF4QjNMLFdBQVdxQyxFQUFFLEVBQUMsWUFBMEIsT0FBaEJzSjtZQUNoRSxPQUFPO2dCQUNMbkYsV0FBVyxHQUF5QnhHLE9BQXRCb0QsU0FBUSxnQkFBc0N1SSxPQUF4QjNMLFdBQVdxQyxFQUFFLEVBQUMsWUFBMEIsT0FBaEJzSjtZQUM5RDtZQUVBLE1BQU1sRixXQUFXLE1BQU03RyxpREFBUyxDQUFDNEc7WUFFakMsaUVBQWlFO1lBQ2pFakYsWUFBWWtCLENBQUFBLE9BQVE7dUJBQUlnRSxTQUFTL0IsSUFBSTt1QkFBS2pDO2lCQUFLO1lBRS9DLE9BQU9nRSxTQUFTL0IsSUFBSSxDQUFDN0IsTUFBTTtRQUM3QixFQUFFLE9BQU9tRCxPQUFPO1lBQ2RoQyxRQUFRZ0MsS0FBSyxDQUFDLG9DQUFpQ0E7WUFDL0MsT0FBTztRQUNUO0lBQ0Y7SUFFQSxxQkFDRSw4REFBQ2pHLFlBQVk2TCxRQUFRO1FBQUM5QyxPQUFPO1lBQzNCOUk7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUM7WUFDQUMsZUFBZTJGO1lBQ2YxRjtZQUNBQyxZQUFZNks7WUFDWjVLLGFBQWEsSUFBTWdKLFVBQVU7WUFDN0IvSSxZQUFZLElBQU0rSSxVQUFVO1lBQzVCOUksa0JBQWtCMks7WUFDbEIxSztZQUNBQztRQUNGO2tCQUNHRzs7Ozs7O0FBR1AsRUFBRTtJQXZyQldEOztRQUN1QnRCLGlEQUFPQTs7O0tBRDlCc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL0NoYXRDb250ZXh0LnRzeD8wYjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZU1lbW8sIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICcuL0F1dGhDb250ZXh0JztcblxuaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBfaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgYXZhdGFyOiBzdHJpbmc7XG4gIGlzT25saW5lPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGVudW0gRmlsZVR5cGUge1xuICBJTUFHRSA9ICdpbWFnZScsXG4gIFZJREVPID0gJ3ZpZGVvJyxcbiAgRE9DVU1FTlQgPSAnZG9jdW1lbnQnLFxuICBBVURJTyA9ICdhdWRpbydcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaWxlQXR0YWNobWVudCB7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG4gIGNvbnRlbnRUeXBlOiBzdHJpbmc7XG4gIGZpbGVUeXBlOiBGaWxlVHlwZTtcbiAgZGF0YT86IHN0cmluZzsgLy8gQmFzZTY0IGVuY29kZWQgZGF0YSBwYXJhIGFyY2hpdm9zIHBlcXVlw7Fvc1xuICBzaXplPzogbnVtYmVyO1xuICBmaWxlSWQ/OiBzdHJpbmc7IC8vIElEIHBhcmEgYXJjaGl2b3MgZ3JhbmRlcyBhbG1hY2VuYWRvcyBwb3Igc2VwYXJhZG9cbiAgaXNMYXJnZUZpbGU/OiBib29sZWFuOyAvLyBJbmRpY2Egc2kgZWwgYXJjaGl2byBlc3TDoSBhbG1hY2VuYWRvIHBvciBzZXBhcmFkb1xuICBpc0NodW5rPzogYm9vbGVhbjtcbiAgb3JpZ2luYWxGaWxlbmFtZT86IHN0cmluZztcbiAgY2h1bmtJbmRleD86IG51bWJlcjtcbiAgdG90YWxDaHVua3M/OiBudW1iZXI7XG4gIHRlbXBJZD86IHN0cmluZzsgLy8gSUQgdGVtcG9yYWwgcGFyYSBzZWd1aW1pZW50byBkZSBjYXJnYVxufVxuXG5pbnRlcmZhY2UgTWVzc2FnZSB7XG4gIF9pZDogc3RyaW5nO1xuICBjb250ZW50Pzogc3RyaW5nO1xuICBhdHRhY2htZW50cz86IEZpbGVBdHRhY2htZW50W107XG4gIHNlbmRlcjogVXNlcjtcbiAgcmVjaXBpZW50Pzogc3RyaW5nO1xuICByb29tPzogc3RyaW5nO1xuICBpc1JlYWQ6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUm9vbSB7XG4gIF9pZDogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBpbWFnZT86IHN0cmluZztcbiAgY3JlYXRvcjogVXNlcjtcbiAgbWVtYmVyczogVXNlcltdO1xuICBpc1ByaXZhdGU6IGJvb2xlYW47XG4gIGNyZWF0ZWRBdDogc3RyaW5nO1xuICByZW1vdmVkPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIENoYXRDb250ZXh0VHlwZSB7XG4gIGFjdGl2ZUNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsO1xuICBtZXNzYWdlczogTWVzc2FnZVtdO1xuICByb29tczogUm9vbVtdO1xuICBvbmxpbmVVc2VyczogUmVjb3JkPHN0cmluZywgYm9vbGVhbj47XG4gIHVzZXJzOiBVc2VyW107XG4gIHR5cGluZ1VzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgc3RyaW5nPjtcbiAgaXNMb2FkaW5nOiBib29sZWFuO1xuICBpc0xvYWRpbmdNZXNzYWdlczogYm9vbGVhbjtcbiAgdW5yZWFkTWVzc2FnZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj47XG4gIHVwbG9hZGluZ0ZpbGVzOiBSZWNvcmQ8c3RyaW5nLCB7IHByb2dyZXNzOiBudW1iZXIsIGVycm9yPzogc3RyaW5nIH0+O1xuICBzZXRBY3RpdmVDaGF0OiAoY2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGwpID0+IHZvaWQ7XG4gIHNlbmRNZXNzYWdlOiAoY29udGVudDogc3RyaW5nLCBhdHRhY2htZW50cz86IEZpbGVbXSkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbWFya0FzUmVhZDogKG1lc3NhZ2VJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzdGFydFR5cGluZzogKCkgPT4gdm9pZDtcbiAgc3RvcFR5cGluZzogKCkgPT4gdm9pZDtcbiAgbG9hZE1vcmVNZXNzYWdlczogKGJlZm9yZU1lc3NhZ2VJZDogc3RyaW5nKSA9PiBQcm9taXNlPG51bWJlcj47XG4gIHJldHJ5RmlsZVVwbG9hZDogKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB2b2lkO1xuICBjYW5jZWxGaWxlVXBsb2FkOiAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IENoYXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDaGF0Q29udGV4dFR5cGU+KHtcbiAgYWN0aXZlQ2hhdDogbnVsbCxcbiAgbWVzc2FnZXM6IFtdLFxuICByb29tczogW10sXG4gIG9ubGluZVVzZXJzOiB7fSxcbiAgdXNlcnM6IFtdLFxuICB0eXBpbmdVc2Vyczoge30sXG4gIGlzTG9hZGluZzogdHJ1ZSxcbiAgaXNMb2FkaW5nTWVzc2FnZXM6IGZhbHNlLFxuICB1bnJlYWRNZXNzYWdlczoge30sXG4gIHVwbG9hZGluZ0ZpbGVzOiB7fSxcbiAgc2V0QWN0aXZlQ2hhdDogKCkgPT4ge30sXG4gIHNlbmRNZXNzYWdlOiBhc3luYyAoKSA9PiB7fSxcbiAgbWFya0FzUmVhZDogKCkgPT4ge30sXG4gIHN0YXJ0VHlwaW5nOiAoKSA9PiB7fSxcbiAgc3RvcFR5cGluZzogKCkgPT4ge30sXG4gIGxvYWRNb3JlTWVzc2FnZXM6IGFzeW5jICgpID0+IDAsXG4gIHJldHJ5RmlsZVVwbG9hZDogKCkgPT4ge30sXG4gIGNhbmNlbEZpbGVVcGxvYWQ6ICgpID0+IHt9LFxufSk7XG5cbmV4cG9ydCBjb25zdCB1c2VDaGF0ID0gKCkgPT4gdXNlQ29udGV4dChDaGF0Q29udGV4dCk7XG5cbmV4cG9ydCBjb25zdCBDaGF0UHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyB1c2VyLCBpc0F1dGhlbnRpY2F0ZWQgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3QgW2FjdGl2ZUNoYXQsIHNldEFjdGl2ZUNoYXRdID0gdXNlU3RhdGU8eyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbcm9vbXMsIHNldFJvb21zXSA9IHVzZVN0YXRlPFJvb21bXT4oW10pO1xuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPFVzZXJbXT4oW10pO1xuICBjb25zdCBbb25saW5lVXNlcnMsIHNldE9ubGluZVVzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+Pih7fSk7XG4gIGNvbnN0IFt0eXBpbmdVc2Vycywgc2V0VHlwaW5nVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZz4+KHt9KTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaXNMb2FkaW5nTWVzc2FnZXMsIHNldElzTG9hZGluZ01lc3NhZ2VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3NvY2tldENvbm5lY3RlZCwgc2V0U29ja2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3VucmVhZE1lc3NhZ2VzLCBzZXRVbnJlYWRNZXNzYWdlc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pih7fSk7XG4gIGNvbnN0IFt1cGxvYWRpbmdGaWxlc0J5Q2hhdCwgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXRdID0gdXNlU3RhdGU8e1xuICAgIFtjaGF0SWQ6IHN0cmluZ106IHtcbiAgICAgIFtmaWxlSWQ6IHN0cmluZ106IHtcbiAgICAgICAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgICAgICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9Pih7fSk7XG4gIFxuICBjb25zdCB1cGxvYWRpbmdGaWxlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgcmV0dXJuIHVwbG9hZGluZ0ZpbGVzQnlDaGF0W2NoYXRJZF0gfHwge307XG4gIH0sIFthY3RpdmVDaGF0LCB1cGxvYWRpbmdGaWxlc0J5Q2hhdF0pO1xuXG4gIGNvbnN0IHVwZGF0ZVVwbG9hZGluZ0ZpbGVzID0gdXNlQ2FsbGJhY2soKFxuICAgIGNoYXRJZDogc3RyaW5nLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIHN0YXR1czogeyBwcm9ncmVzczogbnVtYmVyOyBlcnJvcj86IHN0cmluZyB9IHwgbnVsbFxuICApID0+IHtcbiAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XG4gICAgICBcbiAgICAgIC8vIEluaWNpYWxpemFyIGVsIG9iamV0byBkZWwgY2hhdCBzaSBubyBleGlzdGVcbiAgICAgIGlmICghbmV3U3RhdGVbY2hhdElkXSkge1xuICAgICAgICBuZXdTdGF0ZVtjaGF0SWRdID0ge307XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNpIHN0YXR1cyBlcyBudWxsLCBlbGltaW5hciBlbCBhcmNoaXZvXG4gICAgICBpZiAoc3RhdHVzID09PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdTdGF0ZVtjaGF0SWRdW2ZpbGVJZF0pIHtcbiAgICAgICAgICBkZWxldGUgbmV3U3RhdGVbY2hhdElkXVtmaWxlSWRdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBY3R1YWxpemFyIGVsIGVzdGFkbyBkZWwgYXJjaGl2b1xuICAgICAgICBuZXdTdGF0ZVtjaGF0SWRdW2ZpbGVJZF0gPSBzdGF0dXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNpIG5vIGhheSBhcmNoaXZvcyBlbiBlc3RlIGNoYXQsIGVsaW1pbmFyIGVsIG9iamV0byBkZWwgY2hhdFxuICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld1N0YXRlW2NoYXRJZF0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgbmV3U3RhdGVbY2hhdElkXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2FuY2VsRmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIGlmICghZmlsZS50ZW1wSWQgfHwgIWFjdGl2ZUNoYXQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgZmlsZS50ZW1wSWQsIG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY3VycmVudEFjdGl2ZUNoYXRSZWYgPSB1c2VSZWYoYWN0aXZlQ2hhdCk7XG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgXG4gIC8vIEtlZXAgdGhlIHJlZiBpbiBzeW5jIHdpdGggdGhlIHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudCA9IGFjdGl2ZUNoYXQ7XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgXG4gIC8vIEluaXRpYWxpemUgc29ja2V0IGNvbm5lY3Rpb24gd2hlbiBhdXRoZW50aWNhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXVzZXIpIHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG4gICAgXG4gICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50ID0gaW8oQVBJX1VSTCwge1xuICAgICAgYXV0aDogeyB0b2tlbiB9LFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgLy8gQXVtZW50YXIgZWwgdGllbXBvIGRlIGVzcGVyYSBwYXJhIHBlcm1pdGlyIGVudsOtbyBkZSBhcmNoaXZvcyBncmFuZGVzXG4gICAgICB0aW1lb3V0OiA2MDAwMCAvLyBhdW1lbnRhciBlbCB0aWVtcG8gZGUgZXNwZXJhIGEgNjAgc2VndW5kb3NcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTb2NrZXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfbWVzc2FnZScsIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIFxuICAgICAgLy8gSWRlbnRpZmljYXIgbGEgY2xhdmUgZGUgY2hhdCBwYXJhIHNlZ3VpbWllbnRvIGRlIG5vdGlmaWNhY2lvbmVzXG4gICAgICBsZXQgY2hhdEtleSA9ICcnO1xuICAgICAgaWYgKG1lc3NhZ2Uucm9vbSkge1xuICAgICAgICBjaGF0S2V5ID0gYHJvb21fJHttZXNzYWdlLnJvb219YDtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zZW5kZXIuX2lkICE9PSB1c2VyLmlkKSB7XG4gICAgICAgIGNoYXRLZXkgPSBgdXNlcl8ke21lc3NhZ2Uuc2VuZGVyLl9pZH1gO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnJlY2lwaWVudCkge1xuICAgICAgICBjaGF0S2V5ID0gYHVzZXJfJHttZXNzYWdlLnJlY2lwaWVudH1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTb2xvIGFncmVnYXIgZWwgbWVuc2FqZSBzaSBlcyByZWxldmFudGUgcGFyYSBlbCBjaGF0IGFjdGl2b1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3ByaXZhdGUnICYmIFxuICAgICAgICAgICgobWVzc2FnZS5zZW5kZXIuX2lkID09PSBhY3RpdmVDaGF0LmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSB1c2VyLmlkKSB8fCBcbiAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gdXNlci5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gYWN0aXZlQ2hhdC5pZCkpKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIG1lc3NhZ2Uucm9vbSA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBtZXNzYWdlXSk7XG4gICAgICB9IFxuICAgICAgLy8gU2kgZWwgbWVuc2FqZSBubyBlcyBwYXJhIGVsIGNoYXQgYWN0aXZvIHkgbm8gZnVlIGVudmlhZG8gcG9yIGVsIHVzdWFyaW8gYWN0dWFsLCBpbmNyZW1lbnRhciBjb250YWRvclxuICAgICAgZWxzZSBpZiAobWVzc2FnZS5zZW5kZXIuX2lkICE9PSB1c2VyLmlkICYmIGNoYXRLZXkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldyBtZXNzYWdlIG5vdGlmaWNhdGlvbjonLCBjaGF0S2V5LCBtZXNzYWdlKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW2NoYXRLZXldOiAocHJldltjaGF0S2V5XSB8fCAwKSArIDFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VyX3N0YXR1c19jaGFuZ2UnLCAoeyB1c2VySWQsIGlzT25saW5lIH0pID0+IHtcbiAgICAgIHNldE9ubGluZVVzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IGlzT25saW5lIH0pKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndHlwaW5nX2luZGljYXRvcicsIChkYXRhOiB7IHVzZXJJZDogc3RyaW5nLCB1c2VyTmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbiwgcm9vbUlkPzogc3RyaW5nLCBzZW5kZXJJZD86IHN0cmluZyB9KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBkYXRhLnNlbmRlcklkID09PSBhY3RpdmVDaGF0LmlkKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGRhdGEucm9vbUlkID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEFsbWFjZW5hciBub21icmUgZW4gbHVnYXIgZGUgc29sbyBsYSBiYW5kZXJhIGJvb2xlYW5hXG4gICAgICAgIHNldFR5cGluZ1VzZXJzKHByZXYgPT4gKHsgXG4gICAgICAgICAgLi4ucHJldiwgXG4gICAgICAgICAgW2RhdGEudXNlcklkXTogZGF0YS5pc1R5cGluZyA/IGRhdGEudXNlck5hbWUgOiBmYWxzZSBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdtZXNzYWdlX3JlYWQnLCAoeyBtZXNzYWdlSWQgfSkgPT4ge1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAobXNnID0+IFxuICAgICAgICAgIG1zZy5faWQgPT09IG1lc3NhZ2VJZCA/IHsgLi4ubXNnLCBpc1JlYWQ6IHRydWUgfSA6IG1zZ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBuZXcgcm9vbSBjcmVhdGlvbnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X3Jvb20nLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ05ldyByb29tIHJlY2VpdmVkOicsIHJvb20pO1xuICAgICAgc2V0Um9vbXMocHJldiA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByb29tIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHByZXYuc29tZShyID0+IHIuX2lkID09PSByb29tLl9pZCk7XG4gICAgICAgIGlmIChleGlzdHMpIHJldHVybiBwcmV2O1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIHJvb21dO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHJvb20gdXBkYXRlcyAobWVtYmVycyBhZGRlZC9yZW1vdmVkKVxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdyb29tX3VwZGF0ZWQnLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Jvb20gdXBkYXRlZDonLCByb29tKTtcbiAgICAgIGlmIChyb29tLnJlbW92ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb29tIHdhcyByZW1vdmVkIGZvciB0aGlzIHVzZXIsIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5maWx0ZXIociA9PiByLl9pZCAhPT0gcm9vbS5faWQpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIGFjdGl2ZSBjaGF0IGlzIHRoaXMgcm9vbSwgY2xlYXIgaXRcbiAgICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgYWN0aXZlQ2hhdC5pZCA9PT0gcm9vbS5faWQpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDaGF0KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJvb20gaW4gdGhlIGxpc3RcbiAgICAgICAgc2V0Um9vbXMocHJldiA9PiBwcmV2Lm1hcChyID0+IHIuX2lkID09PSByb29tLl9pZCA/IHJvb20gOiByKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9O1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCB1c2VyLCBBUElfVVJMXSk7XG4gIFxuICAvLyBMb2FkIGluaXRpYWwgZGF0YTogdXNlcnMgYW5kIHJvb21zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZldGNoSW5pdGlhbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBbdXNlcnNSZXNwb25zZSwgcm9vbXNSZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzYCksXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3Jvb21zL215YClcbiAgICAgICAgXSk7XG4gICAgICAgIFxuICAgICAgICBzZXRVc2Vycyh1c2Vyc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBzZXRSb29tcyhyb29tc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb25saW5lIHN0YXR1c1xuICAgICAgICBjb25zdCBpbml0aWFsT25saW5lU3RhdHVzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuICAgICAgICB1c2Vyc1Jlc3BvbnNlLmRhdGEuZm9yRWFjaCgodXNlcjogVXNlcikgPT4ge1xuICAgICAgICAgIGluaXRpYWxPbmxpbmVTdGF0dXNbdXNlci5faWQhXSA9IHVzZXIuaXNPbmxpbmUgfHwgZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRPbmxpbmVVc2Vycyhpbml0aWFsT25saW5lU3RhdHVzKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbml0aWFsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoSW5pdGlhbERhdGEoKTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgLy8gQ3VhbmRvIHNlIGluaWNpYSBlbCBzb2NrZXQgeSBzZSBjb25lY3RhLCBzb2xpY2l0YW1vcyBlbCBlc3RhZG8gYWN0dWFsIGRlIG1lbnNhamVzIG5vIGxlw61kb3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc29ja2V0Q29ubmVjdGVkICYmIHNvY2tldFJlZi5jdXJyZW50ICYmIHVzZXIpIHtcbiAgICAgIC8vIFNvbGljaXRhciBtZW5zYWplcyBubyBsZcOtZG9zIGFsIHNlcnZpZG9yXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdnZXRfdW5yZWFkX21lc3NhZ2VzJyk7XG4gICAgICBcbiAgICAgIC8vIEVzY3VjaGFyIGxhIHJlc3B1ZXN0YSBjb24gZWwgcmVjdWVudG8gZGUgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VucmVhZF9tZXNzYWdlc19jb3VudCcsICh1bnJlYWRDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHVucmVhZCBjb3VudHM6JywgdW5yZWFkQ291bnRzKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXModW5yZWFkQ291bnRzKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8ub2ZmKCd1bnJlYWRfbWVzc2FnZXNfY291bnQnKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc29ja2V0Q29ubmVjdGVkLCB1c2VyXSk7XG5cbiAgLy8gQXNlZ3VyYXJzZSBkZSBxdWUgbG9zIG1lbnNhamVzIHNlIG1hcnF1ZW4gY29tbyBsZcOtZG9zIGN1YW5kbyBzZSBhYnJlIHVuIGNoYXRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlQ2hhdCAmJiBzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ3JlYXIgdW5hIGNsYXZlIHBhcmEgZWwgY2hhdCBhY3R1YWxcbiAgICAgIGNvbnN0IGNoYXRLZXkgPSBhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyBcbiAgICAgICAgPyBgdXNlcl8ke2FjdGl2ZUNoYXQuaWR9YCBcbiAgICAgICAgOiBgcm9vbV8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgIFxuICAgICAgLy8gUmVzZXRlYXIgZWwgY29udGFkb3IgZGUgbWVuc2FqZXMgbm8gbGXDrWRvcyBwYXJhIGVzdGUgY2hhdFxuICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbY2hhdEtleV06IDBcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgLy8gTm90aWZpY2FyIGFsIHNlcnZpZG9yIHF1ZSBsb3MgbWVuc2FqZXMgc2UgaGFuIGxlw61kb1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnbWFya19tZXNzYWdlc19yZWFkJywge1xuICAgICAgICBjaGF0SWQ6IGFjdGl2ZUNoYXQuaWQsXG4gICAgICAgIGNoYXRUeXBlOiBhY3RpdmVDaGF0LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2FjdGl2ZUNoYXRdKTtcbiAgXG4gIC8vIEZ1bmNpw7NuIHBhcmEgbWFuZWphciBlbCBjYW1iaW8gZGUgY2hhdCBhY3Rpdm9cbiAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSA9IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4ge1xuICAgIC8vIExpbXBpYXIgbGFzIG5vdGlmaWNhY2lvbmVzIG5vIGxlw61kYXMgY3VhbmRvIHNlIGFjdGl2YSB1biBjaGF0XG4gICAgaWYgKGNoYXQpIHtcbiAgICAgIGNvbnN0IGNoYXRLZXkgPSBjaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IGB1c2VyXyR7Y2hhdC5pZH1gIDogYHJvb21fJHtjaGF0LmlkfWA7XG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjaGF0S2V5XTogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBcbiAgICBzZXRBY3RpdmVDaGF0KGNoYXQpO1xuICB9O1xuXG4gIC8vIENhcmdhciBtZW5zYWplcyBjdWFuZG8gc2Ugc2VsZWNjaW9uYSB1biBjaGF0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICF1c2VyIHx8ICFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldE1lc3NhZ2VzKFtdKTtcbiAgICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNMb2FkaW5nTWVzc2FnZXModHJ1ZSk7XG4gICAgXG4gICAgY29uc3QgZmV0Y2hNZXNzYWdlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBlbmRwb2ludCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiB1c2VyIHJvb20gZm9yIGRpcmVjdCBtZXNzYWdlc1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHVzZXJJZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL3Jvb20vJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiByb29tXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChlbmRwb2ludCk7XG4gICAgICAgIHNldE1lc3NhZ2VzKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyY2FyIGxvcyBtZW5zYWplcyBjb21vIGxlw61kb3MgZW4gZWwgc2Vydmlkb3JcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdtYXJrX21lc3NhZ2VzX3JlYWQnLCB7XG4gICAgICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlLFxuICAgICAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoTWVzc2FnZXMoKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgLSBsZWF2ZSByb29tc1xuICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3Jvb20nKSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdsZWF2ZV9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUNoYXQsIHVzZXIsIGlzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nLCBhdHRhY2htZW50cz86IEZpbGVbXSkgPT4ge1xuICAgIGlmICghc29ja2V0UmVmLmN1cnJlbnQgfHwgIWFjdGl2ZUNoYXQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhciB0ZW1wSWRzIHBhcmEgbG9zIGFyY2hpdm9zIHkgY29udmVydGlybG9zIGEgRmlsZUF0dGFjaG1lbnRcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzV2l0aElkczogRmlsZUF0dGFjaG1lbnRbXSA9IFtdO1xuICAgICAgXG4gICAgICBpZiAoYXR0YWNobWVudHMgJiYgYXR0YWNobWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgYXR0YWNobWVudHMpIHtcbiAgICAgICAgICBjb25zdCB0ZW1wSWQgPSBgdGVtcC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gRGV0ZXJtaW5hciB0aXBvIGRlIGFyY2hpdm8gZGUgZm9ybWEgc2VndXJhXG4gICAgICAgICAgbGV0IGZpbGVUeXBlID0gRmlsZVR5cGUuRE9DVU1FTlQ7XG4gICAgICAgICAgY29uc3QgZmlsZVR5cGVTdHJpbmcgPSBmaWxlLnR5cGUgfHwgJyc7IC8vIFVzYXIgc3RyaW5nIHZhY8OtbyBzaSB0eXBlIGVzIHVuZGVmaW5lZFxuICAgICAgICAgIGlmIChmaWxlVHlwZVN0cmluZy5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5JTUFHRTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVUeXBlU3RyaW5nLnN0YXJ0c1dpdGgoJ3ZpZGVvLycpKSB7XG4gICAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLlZJREVPO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlsZVR5cGVTdHJpbmcuc3RhcnRzV2l0aCgnYXVkaW8vJykpIHtcbiAgICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuQVVESU87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuRE9DVU1FTlQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWFyIG9iamV0byBGaWxlQXR0YWNobWVudCBwYXJhIGVsIGFyY2hpdm9cbiAgICAgICAgICBjb25zdCBhdHRhY2htZW50OiBGaWxlQXR0YWNobWVudCA9IHtcbiAgICAgICAgICAgIHRlbXBJZCxcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxlLm5hbWUgfHwgJ2FyY2hpdm8nLFxuICAgICAgICAgICAgY29udGVudFR5cGU6IGZpbGUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICAgIGZpbGVUeXBlLFxuICAgICAgICAgICAgc2l6ZTogZmlsZS5zaXplIHx8IDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpIGVzIHVuIGFyY2hpdm8gZ3JhbmRlLCBsbyBwcm9jZXNhbW9zIHBhcmEgc3ViaWRhIGVuIHNlZ3VuZG8gcGxhbm9cbiAgICAgICAgICBpZiAoZmlsZS5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSB7IC8vIE3DoXMgZGUgNU1CXG4gICAgICAgICAgICBhdHRhY2htZW50LmlzTGFyZ2VGaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gTGVlciBjb21vIGJhc2U2NCBwYXJhIHByZXByb2Nlc2FtaWVudG9cbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ZGF0YSA9IHJlYWRlci5yZXN1bHQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgLy8gUXVpdGFyIGVsIHByZWZpam8gKGVqLiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0Q2xlYW4gPSBiYXNlNjRkYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gYmFzZTY0Q2xlYW47XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEluaWNpYXIgc3ViaWRhIGVuIHNlZ3VuZG8gcGxhbm9cbiAgICAgICAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQsIHRlbXBJZCwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWdyZWdhciBhIGxhIGxpc3RhIGRlIGFkanVudG9zXG4gICAgICAgICAgICBhdHRhY2htZW50c1dpdGhJZHMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW5pY2lhciBzdWJpZGEgZW4gc2VndW5kbyBwbGFub1xuICAgICAgICAgICAgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIoYXR0YWNobWVudCkudGhlbihmaWxlSWQgPT4ge1xuICAgICAgICAgICAgICBpZiAoZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBlbCBhdHRhY2htZW50IGNvbiBlbCBmaWxlSWRcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmlzTGFyZ2VGaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmRhdGEgPSB1bmRlZmluZWQ7IC8vIEVsaW1pbmFyIGxvcyBkYXRvcyBiaW5hcmlvc1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc28gYSAxMDAlXG4gICAgICAgICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCB0ZW1wSWQsIHsgcHJvZ3Jlc3M6IDEwMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJpZW5kbyBhcmNoaXZvOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCB0ZW1wSWQsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBzdWJpciBlbCBhcmNoaXZvJyB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIHBlcXVlw7FvcyAoPDVNQiksIGxlZXJsb3MgY29tbyBiYXNlNjQgeSBlbnZpYXIgY29uIGVsIG1lbnNhamVcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ZGF0YSA9IHJlYWRlci5yZXN1bHQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgLy8gUXVpdGFyIGVsIHByZWZpam8gKGVqLiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0Q2xlYW4gPSBiYXNlNjRkYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gYmFzZTY0Q2xlYW47XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFncmVnYXIgYSBsYSBsaXN0YSBkZSBhZGp1bnRvc1xuICAgICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByZXBhcmFyIGRhdG9zIGRlbCBtZW5zYWplXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzV2l0aElkcyxcbiAgICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFbnZpYXIgZWwgbWVuc2FqZSBhIHRyYXbDqXMgZGVsIHNvY2tldFxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnc2VuZF9tZXNzYWdlJywgbWVzc2FnZURhdGEsIChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVudmlhciBtZW5zYWplOicsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExpbXBpYXIgZm9ybXVsYXJpbyBkZXNwdcOpcyBkZSBlbnZpYXJcbiAgICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICBmaWxlSW5wdXRSZWYuY3VycmVudC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHByb2Nlc2FyIG1lbnNhamU6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGNyZWF0ZVJvb20gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbiA9ICcnLCBpc1ByaXZhdGUgPSBmYWxzZSwgbWVtYmVyczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXNgLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBpc1ByaXZhdGUsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTm8gbmVlZCB0byBtYW51YWxseSBhZGQgdG8gcm9vbXMgYXJyYXksIHRoZSBzb2NrZXQgZXZlbnQgd2lsbCBoYW5kbGUgaXRcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHVwZGF0ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IHsgbmFtZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGltYWdlPzogc3RyaW5nOyBpc1ByaXZhdGU/OiBib29sZWFuIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wdXQoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9YCwgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbG9jYWwgc3RhdGUgdG8gaW1tZWRpYXRlbHkgcmVmbGVjdCBjaGFuZ2VzXG4gICAgICBzZXRSb29tcyhwcmV2Um9vbXMgPT4gXG4gICAgICAgIHByZXZSb29tcy5tYXAocm9vbSA9PiBcbiAgICAgICAgICByb29tLl9pZCA9PT0gcm9vbUlkID8geyAuLi5yb29tLCAuLi5kYXRhIH0gOiByb29tXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGpvaW5Sb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIGFkZGluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1qb2luaW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igam9pbmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGxlYXZlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiByZW1vdmluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1sZWF2aW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsZWF2aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgc2V0VHlwaW5nID0gKGlzVHlwaW5nOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHR5cGluZ0RhdGEgPSB7XG4gICAgICBpc1R5cGluZyxcbiAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgIH07XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgndHlwaW5nJywgdHlwaW5nRGF0YSk7XG4gIH07XG4gIFxuICBjb25zdCBjbGVhckNoYXRIaXN0b3J5ID0gYXN5bmMgKHJlY2lwaWVudElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7cmVjaXBpZW50SWR9YCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQ2hhdCBoaXN0b3J5IGNsZWFyZWQgc3VjY2Vzc2Z1bGx5JyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBjaGF0IGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2xlYXIgY2hhdCBoaXN0b3J5JyB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEltcGxlbWVudGFjacOzbiBkZSByZXRyeUZpbGVVcGxvYWRcbiAgY29uc3QgcmV0cnlGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlc2V0IHByb2dyZXNzXG4gICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdD8udHlwZX0tJHthY3RpdmVDaGF0Py5pZH1gO1xuICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGZpbGUudGVtcElkISwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICBcbiAgICAvLyBQcmVwYXJlIGZvciByZS11cGxvYWRcbiAgICBpZiAoZmlsZS5kYXRhKSB7XG4gICAgICAvLyBFcyB1biBhcmNoaXZvIHlhIGNvbnZlcnRpZG8gYSBiYXNlNjRcbiAgICAgIHVwbG9hZExhcmdlRmlsZVRvU2VydmVyKGZpbGUpO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlSWQpIHtcbiAgICAgIC8vIFJlbW92ZXIgZWwgZXJyb3IgcGVybyBtYW50ZW5lciBlbCBwcm9ncmVzbyBjb21vIGNvbXBsZXRhZG9cbiAgICAgIC8vIHlhIHF1ZSBlbCBhcmNoaXZvIHlhIGVzdMOhIHN1Ymlkb1xuICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgZmlsZS50ZW1wSWQhLCB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRnVuY2nDs24gYXV4aWxpYXIgcGFyYSBzdWJpciB1biBhcmNoaXZvIGdyYW5kZSBkaXJlY3RhbWVudGUgYWwgc2Vydmlkb3JcbiAgY29uc3QgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIgPSBhc3luYyAoYXR0YWNobWVudDogRmlsZUF0dGFjaG1lbnQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgICBpZiAoIWF0dGFjaG1lbnQudGVtcElkKSB7XG4gICAgICBhdHRhY2htZW50LnRlbXBJZCA9IGB0ZW1wLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YDtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnRpciBkYXRvcyBiYXNlNjQgYSBCbG9iIHBhcmEgc3ViaXJcbiAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBhdHRhY2htZW50LmRhdGEgfHwgJyc7XG4gICAgICBjb25zdCBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYmFzZTY0RGF0YSk7XG4gICAgICBjb25zdCBieXRlQXJyYXlzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IDUxMikge1xuICAgICAgICBjb25zdCBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNTEyKTtcbiAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG4gICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgYXR0YWNobWVudC5maWxlbmFtZSwgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhciBGb3JtRGF0YSBwYXJhIGxhIHN1YmlkYVxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBJbmljaWFyIGxhIGNhcmdhIHkgYWN0dWFsaXphciBlbCBlc3RhZG9cbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQ/LnR5cGV9LSR7YWN0aXZlQ2hhdD8uaWR9YDtcbiAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgIFxuICAgICAgLy8gUmVhbGl6YXIgbGEgc3ViaWRhIGNvbiBzZWd1aW1pZW50byBkZSBwcm9ncmVzb1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L2ZpbGUtc3RvcmFnZS91cGxvYWRgLCBmb3JtRGF0YSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnRDb21wbGV0ZWQgPSBwcm9ncmVzc0V2ZW50LnRvdGFsIFxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKChwcm9ncmVzc0V2ZW50LmxvYWRlZCAqIDEwMCkgLyBwcm9ncmVzc0V2ZW50LnRvdGFsKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgYXR0YWNobWVudC50ZW1wSWQhLCB7IHByb2dyZXNzOiBwZXJjZW50Q29tcGxldGVkLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5maWxlSWQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZmlsZUlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgc3ViaXIgYXJjaGl2bzonLCBlcnJvcik7XG4gICAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0Py50eXBlfS0ke2FjdGl2ZUNoYXQ/LmlkfWA7XG4gICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQhLCBhdHRhY2htZW50LnRlbXBJZCEsIHsgXG4gICAgICAgIHByb2dyZXNzOiAwLCBcbiAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIGFsIHN1YmlyIGVsIGFyY2hpdm8nXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEVzdGEgZnVuY2nDs24gc2UgZW5jYXJnYSBkZSBtYXJjYXIgdW4gbWVuc2FqZSBjb21vIGxlw61kb1xuICBjb25zdCBoYW5kbGVNYXJrQXNSZWFkID0gKG1lc3NhZ2VJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ21hcmtfbWVzc2FnZV9yZWFkJywgeyBtZXNzYWdlSWQgfSk7XG4gICAgXG4gICAgLy8gQWN0dWFsaXphciBlbCBlc3RhZG8gZGUgbWVuc2FqZXMgbG9jYWxtZW50ZVxuICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gXG4gICAgICBwcmV2Lm1hcChtc2cgPT4gXG4gICAgICAgIG1zZy5faWQgPT09IG1lc3NhZ2VJZCA/IHsgLi4ubXNnLCBpc1JlYWQ6IHRydWUgfSA6IG1zZ1xuICAgICAgKVxuICAgICk7XG4gIH07XG4gIFxuICAvLyBFc3RhIGZ1bmNpw7NuIGNhcmdhIG3DoXMgbWVuc2FqZXMgcGFyYSBsYSBwYWdpbmFjacOzblxuICBjb25zdCBmZXRjaE1vcmVNZXNzYWdlcyA9IGFzeW5jIChiZWZvcmVNZXNzYWdlSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxldCBlbmRwb2ludCA9ICcnO1xuICAgICAgXG4gICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfT9iZWZvcmU9JHtiZWZvcmVNZXNzYWdlSWR9YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvcm9vbS8ke2FjdGl2ZUNoYXQuaWR9P2JlZm9yZT0ke2JlZm9yZU1lc3NhZ2VJZH1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChlbmRwb2ludCk7XG4gICAgICBcbiAgICAgIC8vIEHDsWFkaXIgbG9zIG1lbnNhamVzIGFudGVyaW9yZXMgYWwgaW5pY2lvIGRlbCBhcnJheSBkZSBtZW5zYWplc1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucmVzcG9uc2UuZGF0YSwgLi4ucHJldl0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5sZW5ndGg7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGNhcmdhciBtw6FzIG1lbnNhamVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBhY3RpdmVDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICByb29tcyxcbiAgICAgIG9ubGluZVVzZXJzLFxuICAgICAgdXNlcnMsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZ01lc3NhZ2VzLFxuICAgICAgdW5yZWFkTWVzc2FnZXMsXG4gICAgICB1cGxvYWRpbmdGaWxlcyxcbiAgICAgIHNldEFjdGl2ZUNoYXQ6IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UsXG4gICAgICBzZW5kTWVzc2FnZSxcbiAgICAgIG1hcmtBc1JlYWQ6IGhhbmRsZU1hcmtBc1JlYWQsXG4gICAgICBzdGFydFR5cGluZzogKCkgPT4gc2V0VHlwaW5nKHRydWUpLFxuICAgICAgc3RvcFR5cGluZzogKCkgPT4gc2V0VHlwaW5nKGZhbHNlKSxcbiAgICAgIGxvYWRNb3JlTWVzc2FnZXM6IGZldGNoTW9yZU1lc3NhZ2VzLFxuICAgICAgcmV0cnlGaWxlVXBsb2FkLFxuICAgICAgY2FuY2VsRmlsZVVwbG9hZFxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ2hhdENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImlvIiwiYXhpb3MiLCJ1c2VBdXRoIiwiRmlsZVR5cGUiLCJDaGF0Q29udGV4dCIsImFjdGl2ZUNoYXQiLCJtZXNzYWdlcyIsInJvb21zIiwib25saW5lVXNlcnMiLCJ1c2VycyIsInR5cGluZ1VzZXJzIiwiaXNMb2FkaW5nIiwiaXNMb2FkaW5nTWVzc2FnZXMiLCJ1bnJlYWRNZXNzYWdlcyIsInVwbG9hZGluZ0ZpbGVzIiwic2V0QWN0aXZlQ2hhdCIsInNlbmRNZXNzYWdlIiwibWFya0FzUmVhZCIsInN0YXJ0VHlwaW5nIiwic3RvcFR5cGluZyIsImxvYWRNb3JlTWVzc2FnZXMiLCJyZXRyeUZpbGVVcGxvYWQiLCJjYW5jZWxGaWxlVXBsb2FkIiwidXNlQ2hhdCIsIkNoYXRQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsImlzQXV0aGVudGljYXRlZCIsInNldE1lc3NhZ2VzIiwic2V0Um9vbXMiLCJzZXRVc2VycyIsInNldE9ubGluZVVzZXJzIiwic2V0VHlwaW5nVXNlcnMiLCJzZXRJc0xvYWRpbmciLCJzZXRJc0xvYWRpbmdNZXNzYWdlcyIsInNvY2tldENvbm5lY3RlZCIsInNldFNvY2tldENvbm5lY3RlZCIsInNldFVucmVhZE1lc3NhZ2VzIiwidXBsb2FkaW5nRmlsZXNCeUNoYXQiLCJzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdCIsImNoYXRJZCIsInR5cGUiLCJpZCIsInVwZGF0ZVVwbG9hZGluZ0ZpbGVzIiwiZmlsZUlkIiwic3RhdHVzIiwicHJldiIsIm5ld1N0YXRlIiwiT2JqZWN0Iiwia2V5cyIsImxlbmd0aCIsImZpbGUiLCJ0ZW1wSWQiLCJzb2NrZXRSZWYiLCJjdXJyZW50QWN0aXZlQ2hhdFJlZiIsImZpbGVJbnB1dFJlZiIsImN1cnJlbnQiLCJBUElfVVJMIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJkaXNjb25uZWN0IiwidG9rZW4iLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYXV0aCIsIndpdGhDcmVkZW50aWFscyIsInRpbWVvdXQiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwiY2hhdEtleSIsInJvb20iLCJzZW5kZXIiLCJfaWQiLCJyZWNpcGllbnQiLCJ1c2VySWQiLCJpc09ubGluZSIsImRhdGEiLCJzZW5kZXJJZCIsInJvb21JZCIsImlzVHlwaW5nIiwidXNlck5hbWUiLCJtZXNzYWdlSWQiLCJtYXAiLCJtc2ciLCJpc1JlYWQiLCJleGlzdHMiLCJzb21lIiwiciIsInJlbW92ZWQiLCJmaWx0ZXIiLCJmZXRjaEluaXRpYWxEYXRhIiwidXNlcnNSZXNwb25zZSIsInJvb21zUmVzcG9uc2UiLCJQcm9taXNlIiwiYWxsIiwiZ2V0IiwiaW5pdGlhbE9ubGluZVN0YXR1cyIsImZvckVhY2giLCJlcnJvciIsImVtaXQiLCJ1bnJlYWRDb3VudHMiLCJvZmYiLCJjaGF0VHlwZSIsImhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UiLCJjaGF0IiwiZmV0Y2hNZXNzYWdlcyIsImVuZHBvaW50IiwicmVzcG9uc2UiLCJjb250ZW50IiwiYXR0YWNobWVudHMiLCJhdHRhY2htZW50c1dpdGhJZHMiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZmlsZVR5cGUiLCJmaWxlVHlwZVN0cmluZyIsInN0YXJ0c1dpdGgiLCJhdHRhY2htZW50IiwiZmlsZW5hbWUiLCJuYW1lIiwiY29udGVudFR5cGUiLCJzaXplIiwiaXNMYXJnZUZpbGUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsInJlc29sdmUiLCJvbmxvYWQiLCJiYXNlNjRkYXRhIiwicmVzdWx0IiwiYmFzZTY0Q2xlYW4iLCJzcGxpdCIsInByb2dyZXNzIiwidW5kZWZpbmVkIiwicHVzaCIsInVwbG9hZExhcmdlRmlsZVRvU2VydmVyIiwidGhlbiIsImNhdGNoIiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsInN1Y2Nlc3MiLCJ2YWx1ZSIsInNldFNlbGVjdGVkRmlsZSIsImNyZWF0ZVJvb20iLCJkZXNjcmlwdGlvbiIsImlzUHJpdmF0ZSIsIm1lbWJlcnMiLCJwb3N0IiwidXBkYXRlUm9vbSIsInVwZGF0ZURhdGEiLCJwdXQiLCJwcmV2Um9vbXMiLCJqb2luUm9vbSIsInRhcmdldFVzZXJJZCIsImxlYXZlUm9vbSIsImRlbGV0ZSIsInNldFR5cGluZyIsInR5cGluZ0RhdGEiLCJjbGVhckNoYXRIaXN0b3J5IiwiYmFzZTY0RGF0YSIsImJ5dGVDaGFyYWN0ZXJzIiwiYXRvYiIsImJ5dGVBcnJheXMiLCJvZmZzZXQiLCJzbGljZSIsImJ5dGVOdW1iZXJzIiwiQXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImJ5dGVBcnJheSIsIlVpbnQ4QXJyYXkiLCJibG9iIiwiQmxvYiIsIkZpbGUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiYXBwZW5kIiwiaGVhZGVycyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJwcm9ncmVzc0V2ZW50IiwicGVyY2VudENvbXBsZXRlZCIsInRvdGFsIiwicm91bmQiLCJsb2FkZWQiLCJoYW5kbGVNYXJrQXNSZWFkIiwiZmV0Y2hNb3JlTWVzc2FnZXMiLCJiZWZvcmVNZXNzYWdlSWQiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});