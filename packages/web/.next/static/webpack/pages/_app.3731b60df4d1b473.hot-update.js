"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>{},\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFiles, setUploadingFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envío de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room_\".concat(message.room);\n            } else if (message.sender._id !== user.id) {\n                chatKey = \"user_\".concat(message.sender._id);\n            } else if (message.recipient) {\n                chatKey = \"user_\".concat(message.recipient);\n            }\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leídos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leídos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leídos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leídos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = activeChat.type === \"private\" ? \"user_\".concat(activeChat.id) : \"room_\".concat(activeChat.id);\n            // Resetear el contador de mensajes no leídos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leído\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // Función para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leídas cuando se activa un chat\n        if (chat) {\n            const chatKey = chat.type === \"private\" ? \"user_\".concat(chat.id) : \"room_\".concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Cargar mensajes cuando se selecciona un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !user || !isAuthenticated) {\n            setMessages([]);\n            setIsLoadingMessages(false);\n            return;\n        }\n        setIsLoadingMessages(true);\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leídos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    const sendMessage = async function(content) {\n        let attachments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!activeChat || !isAuthenticated || !socketRef.current) {\n            return;\n        }\n        // Inicializar estado de carga para cada archivo\n        const newUploadingFiles = {\n            ...uploadingFiles\n        };\n        // Para archivos grandes, especialmente videos, los enviamos usando el nuevo endpoint optimizado\n        let processedAttachments = [];\n        // Asignar IDs temporales para seguimiento\n        const attachmentsWithIds = attachments.map((attachment)=>({\n                ...attachment,\n                tempId: \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9))\n            }));\n        // Establecer el estado inicial de carga para cada archivo\n        attachmentsWithIds.forEach((attachment)=>{\n            newUploadingFiles[attachment.tempId] = {\n                progress: 0\n            };\n        });\n        setUploadingFiles(newUploadingFiles);\n        try {\n            for (const attachment of attachmentsWithIds){\n                // Actualizar progreso\n                setUploadingFiles((prev)=>({\n                        ...prev,\n                        [attachment.tempId]: {\n                            progress: 10,\n                            error: undefined\n                        }\n                    }));\n                // Si es un video o archivo grande, lo enviamos usando el nuevo endpoint optimizado\n                if (attachment.fileType === \"video\" || attachment.size && attachment.size > 5 * 1024 * 1024) {\n                    console.log(\"Subiendo archivo grande (\".concat(attachment.fileType, \"): \").concat(attachment.filename, \", tama\\xf1o: \").concat(attachment.size, \" bytes\"));\n                    // Crear un objeto FormData para enviar el archivo\n                    const formData = new FormData();\n                    // Si tenemos datos en base64, convertirlos a Blob\n                    if (attachment.data && attachment.data.startsWith(\"data:\")) {\n                        // Extraer los datos base64 (quitar el prefijo \"data:MIME;base64,\")\n                        const base64Data = attachment.data.split(\",\")[1];\n                        const binaryString = window.atob(base64Data);\n                        const bytes = new Uint8Array(binaryString.length);\n                        for(let i = 0; i < binaryString.length; i++){\n                            bytes[i] = binaryString.charCodeAt(i);\n                        }\n                        const blob = new Blob([\n                            bytes\n                        ], {\n                            type: attachment.contentType\n                        });\n                        formData.append(\"file\", blob, attachment.filename);\n                    } else if (attachment.data) {\n                        // Si tenemos datos binarios directos\n                        const byteCharacters = atob(attachment.data);\n                        const byteArrays = [];\n                        for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                            const slice = byteCharacters.slice(offset, offset + 512);\n                            const byteNumbers = new Array(slice.length);\n                            for(let i = 0; i < slice.length; i++){\n                                byteNumbers[i] = slice.charCodeAt(i);\n                            }\n                            const byteArray = new Uint8Array(byteNumbers);\n                            byteArrays.push(byteArray);\n                        }\n                        const blob = new Blob(byteArrays, {\n                            type: attachment.contentType\n                        });\n                        formData.append(\"file\", blob, attachment.filename);\n                    }\n                    // Añadir metadatos del archivo\n                    formData.append(\"contentType\", attachment.contentType);\n                    // Actualizar progreso\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: 30,\n                                error: undefined\n                            }\n                        }));\n                    try {\n                        // Usar el nuevo endpoint para subir el archivo directamente\n                        const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                            headers: {\n                                \"Content-Type\": \"multipart/form-data\"\n                            },\n                            onUploadProgress: (progressEvent)=>{\n                                const percentCompleted = Math.round(progressEvent.loaded * 70 / (progressEvent.total || 100));\n                                // Actualizar el progreso (30% base + hasta 70% más durante la carga)\n                                setUploadingFiles((prev)=>({\n                                        ...prev,\n                                        [attachment.tempId]: {\n                                            progress: 30 + percentCompleted,\n                                            error: undefined\n                                        }\n                                    }));\n                            }\n                        });\n                        console.log(\"Respuesta de carga:\", response.data);\n                        if (response.data && response.data.fileId) {\n                            // Archivo subido correctamente\n                            processedAttachments.push({\n                                ...attachment,\n                                fileId: response.data.fileId,\n                                isLargeFile: true,\n                                // Eliminar los datos binarios para evitar enviarlos de nuevo\n                                data: undefined\n                            });\n                            // Actualizar progreso a 100%\n                            setUploadingFiles((prev)=>({\n                                    ...prev,\n                                    [attachment.tempId]: {\n                                        progress: 100,\n                                        error: undefined\n                                    }\n                                }));\n                        } else {\n                            throw new Error(\"No se pudo obtener el ID del archivo\");\n                        }\n                    } catch (uploadError) {\n                        console.error(\"Error al subir archivo grande:\", uploadError);\n                        // Actualizar estado con el error\n                        setUploadingFiles((prev)=>({\n                                ...prev,\n                                [attachment.tempId]: {\n                                    progress: 0,\n                                    error: uploadError.message || \"Error al subir el archivo\"\n                                }\n                            }));\n                        continue;\n                    }\n                } else {\n                    // Para archivos pequeños, los enviamos con el mensaje\n                    processedAttachments.push(attachment);\n                    // Actualizar progreso\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: 80,\n                                error: undefined\n                            }\n                        }));\n                }\n            }\n            const messageData = {\n                content,\n                attachments: processedAttachments,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            // Enviar el mensaje a través del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                if (response.success) {\n                    // Éxito - quitar archivos del estado de carga\n                    const finalProgress = {\n                        ...uploadingFiles\n                    };\n                    attachmentsWithIds.forEach((attachment)=>{\n                        delete finalProgress[attachment.tempId];\n                    });\n                    setUploadingFiles(finalProgress);\n                } else {\n                    // Error - actualizar estado con el error\n                    const errorProgress = {\n                        ...uploadingFiles\n                    };\n                    attachmentsWithIds.forEach((attachment)=>{\n                        errorProgress[attachment.tempId] = {\n                            progress: 0,\n                            error: response.error || \"Error al enviar el mensaje\"\n                        };\n                    });\n                    setUploadingFiles(errorProgress);\n                }\n            });\n            // Limpiar formulario después de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar archivos:\", error);\n            // Actualizar estado con el error\n            const errorProgress = {\n                ...uploadingFiles\n            };\n            attachmentsWithIds.forEach((attachment)=>{\n                errorProgress[attachment.tempId] = {\n                    progress: 0,\n                    error: error.message || \"Error al procesar archivos\"\n                };\n            });\n            setUploadingFiles(errorProgress);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // Implementación de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        setUploadingFiles((prev)=>({\n                ...prev,\n                [file.tempId]: {\n                    progress: 0,\n                    error: undefined\n                }\n            }));\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya está subido\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [file.tempId]: {\n                        progress: 100,\n                        error: undefined\n                    }\n                }));\n        }\n    };\n    // Implementación de cancelFileUpload\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Eliminar el archivo de la cola de carga\n        setUploadingFiles((prev)=>{\n            const newState = {\n                ...prev\n            };\n            delete newState[file.tempId];\n            return newState;\n        });\n    };\n    // Función auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [attachment.tempId]: {\n                        progress: 0,\n                        error: undefined\n                    }\n                }));\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: percentCompleted,\n                                error: undefined\n                            }\n                        }));\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [attachment.tempId]: {\n                        progress: 0,\n                        error: error.message || \"Error al subir el archivo\"\n                    }\n                }));\n            return null;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            users,\n            onlineUsers,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            createRoom,\n            updateRoom,\n            joinRoom,\n            leaveRoom,\n            setTyping,\n            clearChatHistory,\n            retryFileUpload,\n            cancelFileUpload\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 789,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"ygKBXQHUDveXc83kNn6UfJuKVi4=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q3VCdEIsaURBQU9BOzs7S0FEOUJzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvQ2hhdENvbnRleHQudHN4PzBiNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgX2lkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGF2YXRhcjogc3RyaW5nO1xuICBpc09ubGluZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIEZpbGVUeXBlIHtcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBWSURFTyA9ICd2aWRlbycsXG4gIERPQ1VNRU5UID0gJ2RvY3VtZW50JyxcbiAgQVVESU8gPSAnYXVkaW8nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUF0dGFjaG1lbnQge1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBmaWxlVHlwZTogRmlsZVR5cGU7XG4gIGRhdGE/OiBzdHJpbmc7IC8vIEJhc2U2NCBlbmNvZGVkIGRhdGEgcGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3NcbiAgc2l6ZT86IG51bWJlcjtcbiAgZmlsZUlkPzogc3RyaW5nOyAvLyBJRCBwYXJhIGFyY2hpdm9zIGdyYW5kZXMgYWxtYWNlbmFkb3MgcG9yIHNlcGFyYWRvXG4gIGlzTGFyZ2VGaWxlPzogYm9vbGVhbjsgLy8gSW5kaWNhIHNpIGVsIGFyY2hpdm8gZXN0w6EgYWxtYWNlbmFkbyBwb3Igc2VwYXJhZG9cbiAgaXNDaHVuaz86IGJvb2xlYW47XG4gIG9yaWdpbmFsRmlsZW5hbWU/OiBzdHJpbmc7XG4gIGNodW5rSW5kZXg/OiBudW1iZXI7XG4gIHRvdGFsQ2h1bmtzPzogbnVtYmVyO1xuICB0ZW1wSWQ/OiBzdHJpbmc7IC8vIElEIHRlbXBvcmFsIHBhcmEgc2VndWltaWVudG8gZGUgY2FyZ2Fcbn1cblxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBfaWQ6IHN0cmluZztcbiAgY29udGVudD86IHN0cmluZztcbiAgYXR0YWNobWVudHM/OiBGaWxlQXR0YWNobWVudFtdO1xuICBzZW5kZXI6IFVzZXI7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgcm9vbT86IHN0cmluZztcbiAgaXNSZWFkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJvb20ge1xuICBfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNyZWF0b3I6IFVzZXI7XG4gIG1lbWJlcnM6IFVzZXJbXTtcbiAgaXNQcml2YXRlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgcmVtb3ZlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBhY3RpdmVDaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbDtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgcm9vbXM6IFJvb21bXTtcbiAgb25saW5lVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICB1c2VyczogVXNlcltdO1xuICB0eXBpbmdVc2VyczogUmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZz47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgaXNMb2FkaW5nTWVzc2FnZXM6IGJvb2xlYW47XG4gIHVucmVhZE1lc3NhZ2VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB1cGxvYWRpbmdGaWxlczogUmVjb3JkPHN0cmluZywgeyBwcm9ncmVzczogbnVtYmVyLCBlcnJvcj86IHN0cmluZyB9PjtcbiAgc2V0QWN0aXZlQ2hhdDogKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB2b2lkO1xuICBzZW5kTWVzc2FnZTogKGNvbnRlbnQ6IHN0cmluZywgYXR0YWNobWVudHM/OiBGaWxlW10pID0+IFByb21pc2U8dm9pZD47XG4gIG1hcmtBc1JlYWQ6IChtZXNzYWdlSWRzOiBzdHJpbmdbXSkgPT4gdm9pZDtcbiAgc3RhcnRUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIHN0b3BUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIGxvYWRNb3JlTWVzc2FnZXM6ICgpID0+IFByb21pc2U8dm9pZD47XG4gIHJldHJ5RmlsZVVwbG9hZDogKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB2b2lkO1xuICBjYW5jZWxGaWxlVXBsb2FkOiAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHZvaWQ7XG59XG5cbmNvbnN0IENoYXRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxDaGF0Q29udGV4dFR5cGU+KHtcbiAgYWN0aXZlQ2hhdDogbnVsbCxcbiAgbWVzc2FnZXM6IFtdLFxuICByb29tczogW10sXG4gIG9ubGluZVVzZXJzOiB7fSxcbiAgdXNlcnM6IFtdLFxuICB0eXBpbmdVc2Vyczoge30sXG4gIGlzTG9hZGluZzogdHJ1ZSxcbiAgaXNMb2FkaW5nTWVzc2FnZXM6IGZhbHNlLFxuICB1bnJlYWRNZXNzYWdlczoge30sXG4gIHVwbG9hZGluZ0ZpbGVzOiB7fSxcbiAgc2V0QWN0aXZlQ2hhdDogKCkgPT4ge30sXG4gIHNlbmRNZXNzYWdlOiBhc3luYyAoKSA9PiB7fSxcbiAgbWFya0FzUmVhZDogKCkgPT4ge30sXG4gIHN0YXJ0VHlwaW5nOiAoKSA9PiB7fSxcbiAgc3RvcFR5cGluZzogKCkgPT4ge30sXG4gIGxvYWRNb3JlTWVzc2FnZXM6IGFzeW5jICgpID0+IHt9LFxuICByZXRyeUZpbGVVcGxvYWQ6ICgpID0+IHt9LFxuICBjYW5jZWxGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9ICgpID0+IHVzZUNvbnRleHQoQ2hhdENvbnRleHQpO1xuXG5leHBvcnQgY29uc3QgQ2hhdFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgdXNlciwgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFthY3RpdmVDaGF0LCBzZXRBY3RpdmVDaGF0XSA9IHVzZVN0YXRlPHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW3Jvb21zLCBzZXRSb29tc10gPSB1c2VTdGF0ZTxSb29tW10+KFtdKTtcbiAgY29uc3QgW3VzZXJzLCBzZXRVc2Vyc10gPSB1c2VTdGF0ZTxVc2VyW10+KFtdKTtcbiAgY29uc3QgW29ubGluZVVzZXJzLCBzZXRPbmxpbmVVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xuICBjb25zdCBbdHlwaW5nVXNlcnMsIHNldFR5cGluZ1VzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmc+Pih7fSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lzTG9hZGluZ01lc3NhZ2VzLCBzZXRJc0xvYWRpbmdNZXNzYWdlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzb2NrZXRDb25uZWN0ZWQsIHNldFNvY2tldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt1bnJlYWRNZXNzYWdlcywgc2V0VW5yZWFkTWVzc2FnZXNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4oe30pO1xuICBjb25zdCBbdXBsb2FkaW5nRmlsZXMsIHNldFVwbG9hZGluZ0ZpbGVzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIHsgcHJvZ3Jlc3M6IG51bWJlciwgZXJyb3I/OiBzdHJpbmcgfT4+KHt9KTtcbiAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcbiAgXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY3VycmVudEFjdGl2ZUNoYXRSZWYgPSB1c2VSZWYoYWN0aXZlQ2hhdCk7XG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgXG4gIC8vIEtlZXAgdGhlIHJlZiBpbiBzeW5jIHdpdGggdGhlIHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudCA9IGFjdGl2ZUNoYXQ7XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgXG4gIC8vIEluaXRpYWxpemUgc29ja2V0IGNvbm5lY3Rpb24gd2hlbiBhdXRoZW50aWNhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXVzZXIpIHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG4gICAgXG4gICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50ID0gaW8oQVBJX1VSTCwge1xuICAgICAgYXV0aDogeyB0b2tlbiB9LFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgLy8gQXVtZW50YXIgZWwgdGllbXBvIGRlIGVzcGVyYSBwYXJhIHBlcm1pdGlyIGVudsOtbyBkZSBhcmNoaXZvcyBncmFuZGVzXG4gICAgICB0aW1lb3V0OiA2MDAwMCAvLyBhdW1lbnRhciBlbCB0aWVtcG8gZGUgZXNwZXJhIGEgNjAgc2VndW5kb3NcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTb2NrZXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfbWVzc2FnZScsIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIFxuICAgICAgLy8gSWRlbnRpZmljYXIgbGEgY2xhdmUgZGUgY2hhdCBwYXJhIHNlZ3VpbWllbnRvIGRlIG5vdGlmaWNhY2lvbmVzXG4gICAgICBsZXQgY2hhdEtleSA9ICcnO1xuICAgICAgaWYgKG1lc3NhZ2Uucm9vbSkge1xuICAgICAgICBjaGF0S2V5ID0gYHJvb21fJHttZXNzYWdlLnJvb219YDtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5zZW5kZXIuX2lkICE9PSB1c2VyLmlkKSB7XG4gICAgICAgIGNoYXRLZXkgPSBgdXNlcl8ke21lc3NhZ2Uuc2VuZGVyLl9pZH1gO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnJlY2lwaWVudCkge1xuICAgICAgICBjaGF0S2V5ID0gYHVzZXJfJHttZXNzYWdlLnJlY2lwaWVudH1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTb2xvIGFncmVnYXIgZWwgbWVuc2FqZSBzaSBlcyByZWxldmFudGUgcGFyYSBlbCBjaGF0IGFjdGl2b1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3ByaXZhdGUnICYmIFxuICAgICAgICAgICgobWVzc2FnZS5zZW5kZXIuX2lkID09PSBhY3RpdmVDaGF0LmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSB1c2VyLmlkKSB8fCBcbiAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gdXNlci5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gYWN0aXZlQ2hhdC5pZCkpKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIG1lc3NhZ2Uucm9vbSA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBtZXNzYWdlXSk7XG4gICAgICB9IFxuICAgICAgLy8gU2kgZWwgbWVuc2FqZSBubyBlcyBwYXJhIGVsIGNoYXQgYWN0aXZvIHkgbm8gZnVlIGVudmlhZG8gcG9yIGVsIHVzdWFyaW8gYWN0dWFsLCBpbmNyZW1lbnRhciBjb250YWRvclxuICAgICAgZWxzZSBpZiAobWVzc2FnZS5zZW5kZXIuX2lkICE9PSB1c2VyLmlkICYmIGNoYXRLZXkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldyBtZXNzYWdlIG5vdGlmaWNhdGlvbjonLCBjaGF0S2V5LCBtZXNzYWdlKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW2NoYXRLZXldOiAocHJldltjaGF0S2V5XSB8fCAwKSArIDFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VyX3N0YXR1c19jaGFuZ2UnLCAoeyB1c2VySWQsIGlzT25saW5lIH0pID0+IHtcbiAgICAgIHNldE9ubGluZVVzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IGlzT25saW5lIH0pKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndHlwaW5nX2luZGljYXRvcicsIChkYXRhOiB7IHVzZXJJZDogc3RyaW5nLCB1c2VyTmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbiwgcm9vbUlkPzogc3RyaW5nLCBzZW5kZXJJZD86IHN0cmluZyB9KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBkYXRhLnNlbmRlcklkID09PSBhY3RpdmVDaGF0LmlkKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGRhdGEucm9vbUlkID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEFsbWFjZW5hciBub21icmUgZW4gbHVnYXIgZGUgc29sbyBsYSBiYW5kZXJhIGJvb2xlYW5hXG4gICAgICAgIHNldFR5cGluZ1VzZXJzKHByZXYgPT4gKHsgXG4gICAgICAgICAgLi4ucHJldiwgXG4gICAgICAgICAgW2RhdGEudXNlcklkXTogZGF0YS5pc1R5cGluZyA/IGRhdGEudXNlck5hbWUgOiBmYWxzZSBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdtZXNzYWdlX3JlYWQnLCAoeyBtZXNzYWdlSWQgfSkgPT4ge1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAobXNnID0+IFxuICAgICAgICAgIG1zZy5faWQgPT09IG1lc3NhZ2VJZCA/IHsgLi4ubXNnLCBpc1JlYWQ6IHRydWUgfSA6IG1zZ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBuZXcgcm9vbSBjcmVhdGlvbnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X3Jvb20nLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ05ldyByb29tIHJlY2VpdmVkOicsIHJvb20pO1xuICAgICAgc2V0Um9vbXMocHJldiA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByb29tIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHByZXYuc29tZShyID0+IHIuX2lkID09PSByb29tLl9pZCk7XG4gICAgICAgIGlmIChleGlzdHMpIHJldHVybiBwcmV2O1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIHJvb21dO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHJvb20gdXBkYXRlcyAobWVtYmVycyBhZGRlZC9yZW1vdmVkKVxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdyb29tX3VwZGF0ZWQnLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Jvb20gdXBkYXRlZDonLCByb29tKTtcbiAgICAgIGlmIChyb29tLnJlbW92ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb29tIHdhcyByZW1vdmVkIGZvciB0aGlzIHVzZXIsIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5maWx0ZXIociA9PiByLl9pZCAhPT0gcm9vbS5faWQpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIGFjdGl2ZSBjaGF0IGlzIHRoaXMgcm9vbSwgY2xlYXIgaXRcbiAgICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgYWN0aXZlQ2hhdC5pZCA9PT0gcm9vbS5faWQpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDaGF0KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJvb20gaW4gdGhlIGxpc3RcbiAgICAgICAgc2V0Um9vbXMocHJldiA9PiBwcmV2Lm1hcChyID0+IHIuX2lkID09PSByb29tLl9pZCA/IHJvb20gOiByKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9O1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCB1c2VyLCBBUElfVVJMXSk7XG4gIFxuICAvLyBMb2FkIGluaXRpYWwgZGF0YTogdXNlcnMgYW5kIHJvb21zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZldGNoSW5pdGlhbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBbdXNlcnNSZXNwb25zZSwgcm9vbXNSZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzYCksXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3Jvb21zL215YClcbiAgICAgICAgXSk7XG4gICAgICAgIFxuICAgICAgICBzZXRVc2Vycyh1c2Vyc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBzZXRSb29tcyhyb29tc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb25saW5lIHN0YXR1c1xuICAgICAgICBjb25zdCBpbml0aWFsT25saW5lU3RhdHVzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuICAgICAgICB1c2Vyc1Jlc3BvbnNlLmRhdGEuZm9yRWFjaCgodXNlcjogVXNlcikgPT4ge1xuICAgICAgICAgIGluaXRpYWxPbmxpbmVTdGF0dXNbdXNlci5faWQhXSA9IHVzZXIuaXNPbmxpbmUgfHwgZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRPbmxpbmVVc2Vycyhpbml0aWFsT25saW5lU3RhdHVzKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbml0aWFsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoSW5pdGlhbERhdGEoKTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgLy8gQ3VhbmRvIHNlIGluaWNpYSBlbCBzb2NrZXQgeSBzZSBjb25lY3RhLCBzb2xpY2l0YW1vcyBlbCBlc3RhZG8gYWN0dWFsIGRlIG1lbnNhamVzIG5vIGxlw61kb3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc29ja2V0Q29ubmVjdGVkICYmIHNvY2tldFJlZi5jdXJyZW50ICYmIHVzZXIpIHtcbiAgICAgIC8vIFNvbGljaXRhciBtZW5zYWplcyBubyBsZcOtZG9zIGFsIHNlcnZpZG9yXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdnZXRfdW5yZWFkX21lc3NhZ2VzJyk7XG4gICAgICBcbiAgICAgIC8vIEVzY3VjaGFyIGxhIHJlc3B1ZXN0YSBjb24gZWwgcmVjdWVudG8gZGUgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VucmVhZF9tZXNzYWdlc19jb3VudCcsICh1bnJlYWRDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHVucmVhZCBjb3VudHM6JywgdW5yZWFkQ291bnRzKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXModW5yZWFkQ291bnRzKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8ub2ZmKCd1bnJlYWRfbWVzc2FnZXNfY291bnQnKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc29ja2V0Q29ubmVjdGVkLCB1c2VyXSk7XG5cbiAgLy8gQXNlZ3VyYXJzZSBkZSBxdWUgbG9zIG1lbnNhamVzIHNlIG1hcnF1ZW4gY29tbyBsZcOtZG9zIGN1YW5kbyBzZSBhYnJlIHVuIGNoYXRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlQ2hhdCAmJiBzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ3JlYXIgdW5hIGNsYXZlIHBhcmEgZWwgY2hhdCBhY3R1YWxcbiAgICAgIGNvbnN0IGNoYXRLZXkgPSBhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyBcbiAgICAgICAgPyBgdXNlcl8ke2FjdGl2ZUNoYXQuaWR9YCBcbiAgICAgICAgOiBgcm9vbV8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgIFxuICAgICAgLy8gUmVzZXRlYXIgZWwgY29udGFkb3IgZGUgbWVuc2FqZXMgbm8gbGXDrWRvcyBwYXJhIGVzdGUgY2hhdFxuICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbY2hhdEtleV06IDBcbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgLy8gTm90aWZpY2FyIGFsIHNlcnZpZG9yIHF1ZSBsb3MgbWVuc2FqZXMgc2UgaGFuIGxlw61kb1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnbWFya19tZXNzYWdlc19yZWFkJywge1xuICAgICAgICBjaGF0SWQ6IGFjdGl2ZUNoYXQuaWQsXG4gICAgICAgIGNoYXRUeXBlOiBhY3RpdmVDaGF0LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2FjdGl2ZUNoYXRdKTtcbiAgXG4gIC8vIEZ1bmNpw7NuIHBhcmEgbWFuZWphciBlbCBjYW1iaW8gZGUgY2hhdCBhY3Rpdm9cbiAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSA9IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4ge1xuICAgIC8vIExpbXBpYXIgbGFzIG5vdGlmaWNhY2lvbmVzIG5vIGxlw61kYXMgY3VhbmRvIHNlIGFjdGl2YSB1biBjaGF0XG4gICAgaWYgKGNoYXQpIHtcbiAgICAgIGNvbnN0IGNoYXRLZXkgPSBjaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IGB1c2VyXyR7Y2hhdC5pZH1gIDogYHJvb21fJHtjaGF0LmlkfWA7XG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjaGF0S2V5XTogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBcbiAgICBzZXRBY3RpdmVDaGF0KGNoYXQpO1xuICB9O1xuXG4gIC8vIENhcmdhciBtZW5zYWplcyBjdWFuZG8gc2Ugc2VsZWNjaW9uYSB1biBjaGF0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICF1c2VyIHx8ICFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldE1lc3NhZ2VzKFtdKTtcbiAgICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgc2V0SXNMb2FkaW5nTWVzc2FnZXModHJ1ZSk7XG4gICAgXG4gICAgY29uc3QgZmV0Y2hNZXNzYWdlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBlbmRwb2ludCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiB1c2VyIHJvb20gZm9yIGRpcmVjdCBtZXNzYWdlc1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHVzZXJJZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL3Jvb20vJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiByb29tXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChlbmRwb2ludCk7XG4gICAgICAgIHNldE1lc3NhZ2VzKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyY2FyIGxvcyBtZW5zYWplcyBjb21vIGxlw61kb3MgZW4gZWwgc2Vydmlkb3JcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdtYXJrX21lc3NhZ2VzX3JlYWQnLCB7XG4gICAgICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlLFxuICAgICAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoTWVzc2FnZXMoKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgLSBsZWF2ZSByb29tc1xuICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3Jvb20nKSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdsZWF2ZV9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUNoYXQsIHVzZXIsIGlzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nLCBhdHRhY2htZW50czogRmlsZUF0dGFjaG1lbnRbXSA9IFtdKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFpc0F1dGhlbnRpY2F0ZWQgfHwgIXNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSW5pY2lhbGl6YXIgZXN0YWRvIGRlIGNhcmdhIHBhcmEgY2FkYSBhcmNoaXZvXG4gICAgY29uc3QgbmV3VXBsb2FkaW5nRmlsZXMgPSB7IC4uLnVwbG9hZGluZ0ZpbGVzIH07XG4gICAgXG4gICAgLy8gUGFyYSBhcmNoaXZvcyBncmFuZGVzLCBlc3BlY2lhbG1lbnRlIHZpZGVvcywgbG9zIGVudmlhbW9zIHVzYW5kbyBlbCBudWV2byBlbmRwb2ludCBvcHRpbWl6YWRvXG4gICAgbGV0IHByb2Nlc3NlZEF0dGFjaG1lbnRzOiBGaWxlQXR0YWNobWVudFtdID0gW107XG5cbiAgICAvLyBBc2lnbmFyIElEcyB0ZW1wb3JhbGVzIHBhcmEgc2VndWltaWVudG9cbiAgICBjb25zdCBhdHRhY2htZW50c1dpdGhJZHMgPSBhdHRhY2htZW50cy5tYXAoYXR0YWNobWVudCA9PiAoe1xuICAgICAgLi4uYXR0YWNobWVudCxcbiAgICAgIHRlbXBJZDogYHRlbXAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gXG4gICAgfSkpO1xuXG4gICAgLy8gRXN0YWJsZWNlciBlbCBlc3RhZG8gaW5pY2lhbCBkZSBjYXJnYSBwYXJhIGNhZGEgYXJjaGl2b1xuICAgIGF0dGFjaG1lbnRzV2l0aElkcy5mb3JFYWNoKGF0dGFjaG1lbnQgPT4ge1xuICAgICAgbmV3VXBsb2FkaW5nRmlsZXNbYXR0YWNobWVudC50ZW1wSWRdID0geyBwcm9ncmVzczogMCB9O1xuICAgIH0pO1xuICAgIHNldFVwbG9hZGluZ0ZpbGVzKG5ld1VwbG9hZGluZ0ZpbGVzKTtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHNXaXRoSWRzKSB7XG4gICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc29cbiAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBwcm9ncmVzczogMTAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gU2kgZXMgdW4gdmlkZW8gbyBhcmNoaXZvIGdyYW5kZSwgbG8gZW52aWFtb3MgdXNhbmRvIGVsIG51ZXZvIGVuZHBvaW50IG9wdGltaXphZG9cbiAgICAgICAgaWYgKGF0dGFjaG1lbnQuZmlsZVR5cGUgPT09IEZpbGVUeXBlLlZJREVPIHx8IFxuICAgICAgICAgICAgKGF0dGFjaG1lbnQuc2l6ZSAmJiBhdHRhY2htZW50LnNpemUgPiA1ICogMTAyNCAqIDEwMjQpKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFN1YmllbmRvIGFyY2hpdm8gZ3JhbmRlICgke2F0dGFjaG1lbnQuZmlsZVR5cGV9KTogJHthdHRhY2htZW50LmZpbGVuYW1lfSwgdGFtYcOxbzogJHthdHRhY2htZW50LnNpemV9IGJ5dGVzYCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQ3JlYXIgdW4gb2JqZXRvIEZvcm1EYXRhIHBhcmEgZW52aWFyIGVsIGFyY2hpdm9cbiAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpIHRlbmVtb3MgZGF0b3MgZW4gYmFzZTY0LCBjb252ZXJ0aXJsb3MgYSBCbG9iXG4gICAgICAgICAgaWYgKGF0dGFjaG1lbnQuZGF0YSAmJiBhdHRhY2htZW50LmRhdGEuc3RhcnRzV2l0aCgnZGF0YTonKSkge1xuICAgICAgICAgICAgLy8gRXh0cmFlciBsb3MgZGF0b3MgYmFzZTY0IChxdWl0YXIgZWwgcHJlZmlqbyBcImRhdGE6TUlNRTtiYXNlNjQsXCIpXG4gICAgICAgICAgICBjb25zdCBiYXNlNjREYXRhID0gYXR0YWNobWVudC5kYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSB3aW5kb3cuYXRvYihiYXNlNjREYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbYnl0ZXNdLCB7IHR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBhdHRhY2htZW50LmZpbGVuYW1lKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGF0dGFjaG1lbnQuZGF0YSkge1xuICAgICAgICAgICAgLy8gU2kgdGVuZW1vcyBkYXRvcyBiaW5hcmlvcyBkaXJlY3Rvc1xuICAgICAgICAgICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGF0dGFjaG1lbnQuZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBieXRlQXJyYXlzID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IDUxMikge1xuICAgICAgICAgICAgICBjb25zdCBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNTEyKTtcbiAgICAgICAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKTtcbiAgICAgICAgICAgICAgYnl0ZUFycmF5cy5wdXNoKGJ5dGVBcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihieXRlQXJyYXlzLCB7IHR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUgfSk7XG4gICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBibG9iLCBhdHRhY2htZW50LmZpbGVuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQcOxYWRpciBtZXRhZGF0b3MgZGVsIGFyY2hpdm9cbiAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoJ2NvbnRlbnRUeXBlJywgYXR0YWNobWVudC5jb250ZW50VHlwZSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWN0dWFsaXphciBwcm9ncmVzb1xuICAgICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICBbYXR0YWNobWVudC50ZW1wSWRdOiB7IHByb2dyZXNzOiAzMCwgZXJyb3I6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBVc2FyIGVsIG51ZXZvIGVuZHBvaW50IHBhcmEgc3ViaXIgZWwgYXJjaGl2byBkaXJlY3RhbWVudGVcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9maWxlLXN0b3JhZ2UvdXBsb2FkYCwgZm9ybURhdGEsIHtcbiAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKHByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50Q29tcGxldGVkID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAgICAgICAgIChwcm9ncmVzc0V2ZW50LmxvYWRlZCAqIDcwKSAvIChwcm9ncmVzc0V2ZW50LnRvdGFsIHx8IDEwMClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgZWwgcHJvZ3Jlc28gKDMwJSBiYXNlICsgaGFzdGEgNzAlIG3DoXMgZHVyYW50ZSBsYSBjYXJnYSlcbiAgICAgICAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBwcm9ncmVzczogMzAgKyBwZXJjZW50Q29tcGxldGVkLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVzcHVlc3RhIGRlIGNhcmdhOicsIHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmZpbGVJZCkge1xuICAgICAgICAgICAgICAvLyBBcmNoaXZvIHN1YmlkbyBjb3JyZWN0YW1lbnRlXG4gICAgICAgICAgICAgIHByb2Nlc3NlZEF0dGFjaG1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLmF0dGFjaG1lbnQsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXNwb25zZS5kYXRhLmZpbGVJZCxcbiAgICAgICAgICAgICAgICBpc0xhcmdlRmlsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBFbGltaW5hciBsb3MgZGF0b3MgYmluYXJpb3MgcGFyYSBldml0YXIgZW52aWFybG9zIGRlIG51ZXZvXG4gICAgICAgICAgICAgICAgZGF0YTogdW5kZWZpbmVkXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBwcm9ncmVzbyBhIDEwMCVcbiAgICAgICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBwcm9ncmVzczogMTAwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzZSBwdWRvIG9idGVuZXIgZWwgSUQgZGVsIGFyY2hpdm8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoICh1cGxvYWRFcnJvcjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBzdWJpciBhcmNoaXZvIGdyYW5kZTonLCB1cGxvYWRFcnJvcik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgZXN0YWRvIGNvbiBlbCBlcnJvclxuICAgICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICBbYXR0YWNobWVudC50ZW1wSWRdOiB7IFxuICAgICAgICAgICAgICAgIHByb2dyZXNzOiAwLCBcbiAgICAgICAgICAgICAgICBlcnJvcjogdXBsb2FkRXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2bydcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBDb250aW51YXIgY29uIGVsIHNpZ3VpZW50ZSBhcmNoaXZvXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3MsIGxvcyBlbnZpYW1vcyBjb24gZWwgbWVuc2FqZVxuICAgICAgICAgIHByb2Nlc3NlZEF0dGFjaG1lbnRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWN0dWFsaXphciBwcm9ncmVzb1xuICAgICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICBbYXR0YWNobWVudC50ZW1wSWRdOiB7IHByb2dyZXNzOiA4MCwgZXJyb3I6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBhdHRhY2htZW50czogcHJvY2Vzc2VkQXR0YWNobWVudHMsXG4gICAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgICAgfTtcblxuICAgICAgLy8gRW52aWFyIGVsIG1lbnNhamUgYSB0cmF2w6lzIGRlbCBzb2NrZXRcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ3NlbmRfbWVzc2FnZScsIG1lc3NhZ2VEYXRhLCAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIC8vIMOJeGl0byAtIHF1aXRhciBhcmNoaXZvcyBkZWwgZXN0YWRvIGRlIGNhcmdhXG4gICAgICAgICAgY29uc3QgZmluYWxQcm9ncmVzcyA9IHsgLi4udXBsb2FkaW5nRmlsZXMgfTtcbiAgICAgICAgICBhdHRhY2htZW50c1dpdGhJZHMuZm9yRWFjaChhdHRhY2htZW50ID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBmaW5hbFByb2dyZXNzW2F0dGFjaG1lbnQudGVtcElkXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhmaW5hbFByb2dyZXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBFcnJvciAtIGFjdHVhbGl6YXIgZXN0YWRvIGNvbiBlbCBlcnJvclxuICAgICAgICAgIGNvbnN0IGVycm9yUHJvZ3Jlc3MgPSB7IC4uLnVwbG9hZGluZ0ZpbGVzIH07XG4gICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLmZvckVhY2goYXR0YWNobWVudCA9PiB7XG4gICAgICAgICAgICBlcnJvclByb2dyZXNzW2F0dGFjaG1lbnQudGVtcElkXSA9IHsgXG4gICAgICAgICAgICAgIHByb2dyZXNzOiAwLCBcbiAgICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmVycm9yIHx8ICdFcnJvciBhbCBlbnZpYXIgZWwgbWVuc2FqZScgXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKGVycm9yUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTGltcGlhciBmb3JtdWxhcmlvIGRlc3B1w6lzIGRlIGVudmlhclxuICAgICAgaWYgKGZpbGVJbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZpbGVJbnB1dFJlZi5jdXJyZW50LnZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBzZXRTZWxlY3RlZEZpbGUobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgcHJvY2VzYXIgYXJjaGl2b3M6JywgZXJyb3IpO1xuICAgICAgLy8gQWN0dWFsaXphciBlc3RhZG8gY29uIGVsIGVycm9yXG4gICAgICBjb25zdCBlcnJvclByb2dyZXNzID0geyAuLi51cGxvYWRpbmdGaWxlcyB9O1xuICAgICAgYXR0YWNobWVudHNXaXRoSWRzLmZvckVhY2goYXR0YWNobWVudCA9PiB7XG4gICAgICAgIGVycm9yUHJvZ3Jlc3NbYXR0YWNobWVudC50ZW1wSWRdID0geyBcbiAgICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIGFsIHByb2Nlc2FyIGFyY2hpdm9zJyBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgc2V0VXBsb2FkaW5nRmlsZXMoZXJyb3JQcm9ncmVzcyk7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgY3JlYXRlUm9vbSA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uID0gJycsIGlzUHJpdmF0ZSA9IGZhbHNlLCBtZW1iZXJzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tc2AsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGlzUHJpdmF0ZSxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBObyBuZWVkIHRvIG1hbnVhbGx5IGFkZCB0byByb29tcyBhcnJheSwgdGhlIHNvY2tldCBldmVudCB3aWxsIGhhbmRsZSBpdFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgdXBkYXRlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXBkYXRlRGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZzsgaW1hZ2U/OiBzdHJpbmc7IGlzUHJpdmF0ZT86IGJvb2xlYW4gfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnB1dChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH1gLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsb2NhbCBzdGF0ZSB0byBpbW1lZGlhdGVseSByZWZsZWN0IGNoYW5nZXNcbiAgICAgIHNldFJvb21zKHByZXZSb29tcyA9PiBcbiAgICAgICAgcHJldlJvb21zLm1hcChyb29tID0+IFxuICAgICAgICAgIHJvb20uX2lkID09PSByb29tSWQgPyB7IC4uLnJvb20sIC4uLmRhdGEgfSA6IHJvb21cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgam9pblJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlciAmJiAhdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHVzZXJJZCBpcyBwcm92aWRlZCwgdXNlIGl0IChmb3IgYWRtaW4gYWRkaW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWpvaW5pbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBqb2luaW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgbGVhdmVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIHJlbW92aW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWxlYXZpbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt0YXJnZXRVc2VySWR9YCk7XG4gICAgICAvLyBSb29tIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgYnkgc29ja2V0IGV2ZW50XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBzZXRUeXBpbmcgPSAoaXNUeXBpbmc6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIXNvY2tldFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdHlwaW5nRGF0YSA9IHtcbiAgICAgIGlzVHlwaW5nLFxuICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgfTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCd0eXBpbmcnLCB0eXBpbmdEYXRhKTtcbiAgfTtcbiAgXG4gIGNvbnN0IGNsZWFyQ2hhdEhpc3RvcnkgPSBhc3luYyAocmVjaXBpZW50SWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmRlbGV0ZShgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHtyZWNpcGllbnRJZH1gKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdDaGF0IGhpc3RvcnkgY2xlYXJlZCBzdWNjZXNzZnVsbHknIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNoYXQgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ0ZhaWxlZCB0byBjbGVhciBjaGF0IGhpc3RvcnknIH07XG4gICAgfVxuICB9O1xuICBcbiAgLy8gSW1wbGVtZW50YWNpw7NuIGRlIHJldHJ5RmlsZVVwbG9hZFxuICBjb25zdCByZXRyeUZpbGVVcGxvYWQgPSAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHtcbiAgICBpZiAoIWZpbGUudGVtcElkKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVzZXQgcHJvZ3Jlc3NcbiAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgW2ZpbGUudGVtcElkIV06IHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgIH0pKTtcbiAgICBcbiAgICAvLyBQcmVwYXJlIGZvciByZS11cGxvYWRcbiAgICBpZiAoZmlsZS5kYXRhKSB7XG4gICAgICAvLyBFcyB1biBhcmNoaXZvIHlhIGNvbnZlcnRpZG8gYSBiYXNlNjRcbiAgICAgIHVwbG9hZExhcmdlRmlsZVRvU2VydmVyKGZpbGUpO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlSWQpIHtcbiAgICAgIC8vIFJlbW92ZXIgZWwgZXJyb3IgcGVybyBtYW50ZW5lciBlbCBwcm9ncmVzbyBjb21vIGNvbXBsZXRhZG9cbiAgICAgIC8vIHlhIHF1ZSBlbCBhcmNoaXZvIHlhIGVzdMOhIHN1Ymlkb1xuICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbZmlsZS50ZW1wSWQhXTogeyBwcm9ncmVzczogMTAwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBJbXBsZW1lbnRhY2nDs24gZGUgY2FuY2VsRmlsZVVwbG9hZFxuICBjb25zdCBjYW5jZWxGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIEVsaW1pbmFyIGVsIGFyY2hpdm8gZGUgbGEgY29sYSBkZSBjYXJnYVxuICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4ge1xuICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnByZXYgfTtcbiAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtmaWxlLnRlbXBJZCFdO1xuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0pO1xuICB9O1xuICBcbiAgLy8gRnVuY2nDs24gYXV4aWxpYXIgcGFyYSBzdWJpciB1biBhcmNoaXZvIGdyYW5kZSBkaXJlY3RhbWVudGUgYWwgc2Vydmlkb3JcbiAgY29uc3QgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIgPSBhc3luYyAoYXR0YWNobWVudDogRmlsZUF0dGFjaG1lbnQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgICBpZiAoIWF0dGFjaG1lbnQudGVtcElkKSB7XG4gICAgICBhdHRhY2htZW50LnRlbXBJZCA9IGB0ZW1wLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YDtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnRpciBkYXRvcyBiYXNlNjQgYSBCbG9iIHBhcmEgc3ViaXJcbiAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBhdHRhY2htZW50LmRhdGEgfHwgJyc7XG4gICAgICBjb25zdCBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYmFzZTY0RGF0YSk7XG4gICAgICBjb25zdCBieXRlQXJyYXlzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IDUxMikge1xuICAgICAgICBjb25zdCBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNTEyKTtcbiAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG4gICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgYXR0YWNobWVudC5maWxlbmFtZSwgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhciBGb3JtRGF0YSBwYXJhIGxhIHN1YmlkYVxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBJbmljaWFyIGxhIGNhcmdhIHkgYWN0dWFsaXphciBlbCBlc3RhZG9cbiAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkIV06IHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBSZWFsaXphciBsYSBzdWJpZGEgY29uIHNlZ3VpbWllbnRvIGRlIHByb2dyZXNvXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vZmlsZS1zdG9yYWdlL3VwbG9hZGAsIGZvcm1EYXRhLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGVyY2VudENvbXBsZXRlZCA9IHByb2dyZXNzRXZlbnQudG90YWwgXG4gICAgICAgICAgICA/IE1hdGgucm91bmQoKHByb2dyZXNzRXZlbnQubG9hZGVkICogMTAwKSAvIHByb2dyZXNzRXZlbnQudG90YWwpXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkIV06IHsgcHJvZ3Jlc3M6IHBlcmNlbnRDb21wbGV0ZWQsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmZpbGVJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHN1YmlyIGFyY2hpdm86JywgZXJyb3IpO1xuICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbYXR0YWNobWVudC50ZW1wSWQhXTogeyBcbiAgICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIGFsIHN1YmlyIGVsIGFyY2hpdm8nXG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBhY3RpdmVDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICByb29tcyxcbiAgICAgIHVzZXJzLFxuICAgICAgb25saW5lVXNlcnMsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZ01lc3NhZ2VzLFxuICAgICAgdW5yZWFkTWVzc2FnZXMsXG4gICAgICB1cGxvYWRpbmdGaWxlcyxcbiAgICAgIHNldEFjdGl2ZUNoYXQ6IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UsXG4gICAgICBzZW5kTWVzc2FnZSxcbiAgICAgIGNyZWF0ZVJvb20sXG4gICAgICB1cGRhdGVSb29tLFxuICAgICAgam9pblJvb20sXG4gICAgICBsZWF2ZVJvb20sXG4gICAgICBzZXRUeXBpbmcsXG4gICAgICBjbGVhckNoYXRIaXN0b3J5LFxuICAgICAgcmV0cnlGaWxlVXBsb2FkLFxuICAgICAgY2FuY2VsRmlsZVVwbG9hZCxcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NoYXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbyIsImF4aW9zIiwidXNlQXV0aCIsIkZpbGVUeXBlIiwiQ2hhdENvbnRleHQiLCJhY3RpdmVDaGF0IiwibWVzc2FnZXMiLCJyb29tcyIsIm9ubGluZVVzZXJzIiwidXNlcnMiLCJ0eXBpbmdVc2VycyIsImlzTG9hZGluZyIsImlzTG9hZGluZ01lc3NhZ2VzIiwidW5yZWFkTWVzc2FnZXMiLCJ1cGxvYWRpbmdGaWxlcyIsInNldEFjdGl2ZUNoYXQiLCJzZW5kTWVzc2FnZSIsIm1hcmtBc1JlYWQiLCJzdGFydFR5cGluZyIsInN0b3BUeXBpbmciLCJsb2FkTW9yZU1lc3NhZ2VzIiwicmV0cnlGaWxlVXBsb2FkIiwiY2FuY2VsRmlsZVVwbG9hZCIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nTWVzc2FnZXMiLCJzb2NrZXRDb25uZWN0ZWQiLCJzZXRTb2NrZXRDb25uZWN0ZWQiLCJzZXRVbnJlYWRNZXNzYWdlcyIsInNldFVwbG9hZGluZ0ZpbGVzIiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJmaWxlSW5wdXRSZWYiLCJjdXJyZW50IiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ0aW1lb3V0Iiwib24iLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImNoYXRLZXkiLCJyb29tIiwic2VuZGVyIiwiX2lkIiwiaWQiLCJyZWNpcGllbnQiLCJ0eXBlIiwicHJldiIsInVzZXJJZCIsImlzT25saW5lIiwiZGF0YSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJ1c2VyTmFtZSIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImZldGNoSW5pdGlhbERhdGEiLCJ1c2Vyc1Jlc3BvbnNlIiwicm9vbXNSZXNwb25zZSIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJpbml0aWFsT25saW5lU3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiZW1pdCIsInVucmVhZENvdW50cyIsIm9mZiIsImNoYXRJZCIsImNoYXRUeXBlIiwiaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSIsImNoYXQiLCJmZXRjaE1lc3NhZ2VzIiwiZW5kcG9pbnQiLCJyZXNwb25zZSIsImxlbmd0aCIsImNvbnRlbnQiLCJhdHRhY2htZW50cyIsIm5ld1VwbG9hZGluZ0ZpbGVzIiwicHJvY2Vzc2VkQXR0YWNobWVudHMiLCJhdHRhY2htZW50c1dpdGhJZHMiLCJhdHRhY2htZW50IiwidGVtcElkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInByb2dyZXNzIiwidW5kZWZpbmVkIiwiZmlsZVR5cGUiLCJzaXplIiwiZmlsZW5hbWUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwic3RhcnRzV2l0aCIsImJhc2U2NERhdGEiLCJzcGxpdCIsImJpbmFyeVN0cmluZyIsIndpbmRvdyIsImF0b2IiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImJsb2IiLCJCbG9iIiwiY29udGVudFR5cGUiLCJhcHBlbmQiLCJieXRlQ2hhcmFjdGVycyIsImJ5dGVBcnJheXMiLCJvZmZzZXQiLCJzbGljZSIsImJ5dGVOdW1iZXJzIiwiQXJyYXkiLCJieXRlQXJyYXkiLCJwdXNoIiwicG9zdCIsImhlYWRlcnMiLCJvblVwbG9hZFByb2dyZXNzIiwicHJvZ3Jlc3NFdmVudCIsInBlcmNlbnRDb21wbGV0ZWQiLCJyb3VuZCIsImxvYWRlZCIsInRvdGFsIiwiZmlsZUlkIiwiaXNMYXJnZUZpbGUiLCJFcnJvciIsInVwbG9hZEVycm9yIiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsInN1Y2Nlc3MiLCJmaW5hbFByb2dyZXNzIiwiZXJyb3JQcm9ncmVzcyIsInZhbHVlIiwiY3JlYXRlUm9vbSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImlzUHJpdmF0ZSIsIm1lbWJlcnMiLCJ1cGRhdGVSb29tIiwidXBkYXRlRGF0YSIsInB1dCIsInByZXZSb29tcyIsImpvaW5Sb29tIiwidGFyZ2V0VXNlcklkIiwibGVhdmVSb29tIiwiZGVsZXRlIiwic2V0VHlwaW5nIiwidHlwaW5nRGF0YSIsImNsZWFyQ2hhdEhpc3RvcnkiLCJmaWxlIiwidXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIiLCJuZXdTdGF0ZSIsIkZpbGUiLCJQcm92aWRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});