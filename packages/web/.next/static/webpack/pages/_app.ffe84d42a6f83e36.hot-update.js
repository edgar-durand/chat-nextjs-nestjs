"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>0,\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFiles, setUploadingFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envío de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room_\".concat(message.room);\n            } else if (message.sender._id !== user.id) {\n                chatKey = \"user_\".concat(message.sender._id);\n            } else if (message.recipient) {\n                chatKey = \"user_\".concat(message.recipient);\n            }\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leídos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leídos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leídos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leídos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = activeChat.type === \"private\" ? \"user_\".concat(activeChat.id) : \"room_\".concat(activeChat.id);\n            // Resetear el contador de mensajes no leídos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leído\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // Función para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leídas cuando se activa un chat\n        if (chat) {\n            const chatKey = chat.type === \"private\" ? \"user_\".concat(chat.id) : \"room_\".concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Cargar mensajes cuando se selecciona un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !user || !isAuthenticated) {\n            setMessages([]);\n            setIsLoadingMessages(false);\n            return;\n        }\n        setIsLoadingMessages(true);\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leídos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    const sendMessage = async (content, attachments)=>{\n        if (!socketRef.current || !activeChat) return;\n        try {\n            // Generar tempIds para los archivos y convertirlos a FileAttachment\n            const attachmentsWithIds = [];\n            if (attachments && attachments.length > 0) {\n                for (const file of attachments){\n                    const tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n                    // Determinar tipo de archivo de forma segura\n                    let fileType = \"document\";\n                    const fileTypeString = file.type || \"\"; // Usar string vacío si type es undefined\n                    if (fileTypeString.startsWith(\"image/\")) {\n                        fileType = \"image\";\n                    } else if (fileTypeString.startsWith(\"video/\")) {\n                        fileType = \"video\";\n                    } else if (fileTypeString.startsWith(\"audio/\")) {\n                        fileType = \"audio\";\n                    } else {\n                        fileType = \"document\";\n                    }\n                    // Crear objeto FileAttachment para el archivo\n                    const attachment = {\n                        tempId,\n                        filename: file.name || \"archivo\",\n                        contentType: file.type || \"application/octet-stream\",\n                        fileType,\n                        size: file.size || 0\n                    };\n                    // Si es un archivo grande, lo procesamos para subida en segundo plano\n                    if (file.size > 5 * 1024 * 1024) {\n                        attachment.isLargeFile = true;\n                        // Leer como base64 para preprocesamiento\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Iniciar subida en segundo plano\n                        setUploadingFiles((prev)=>({\n                                ...prev,\n                                [tempId]: {\n                                    progress: 0,\n                                    error: undefined\n                                }\n                            }));\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                        // Iniciar subida en segundo plano\n                        uploadLargeFileToServer(attachment).then((fileId)=>{\n                            if (fileId) {\n                                // Actualizar el attachment con el fileId\n                                attachment.fileId = fileId;\n                                attachment.isLargeFile = true;\n                                attachment.data = undefined; // Eliminar los datos binarios\n                                // Actualizar progreso a 100%\n                                setUploadingFiles((prev)=>({\n                                        ...prev,\n                                        [tempId]: {\n                                            progress: 100,\n                                            error: undefined\n                                        }\n                                    }));\n                            }\n                        }).catch((error)=>{\n                            console.error(\"Error subiendo archivo:\", error);\n                            setUploadingFiles((prev)=>({\n                                    ...prev,\n                                    [tempId]: {\n                                        progress: 0,\n                                        error: error.message || \"Error al subir el archivo\"\n                                    }\n                                }));\n                        });\n                    } else {\n                        // Para archivos pequeños (<5MB), leerlos como base64 y enviar con el mensaje\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                    }\n                }\n            }\n            // Preparar datos del mensaje\n            const messageData = {\n                content,\n                attachments: attachmentsWithIds,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            // Enviar el mensaje a través del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                if (!response.success) {\n                    console.error(\"Error al enviar mensaje:\", response.error);\n                }\n            });\n            // Limpiar formulario después de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar mensaje:\", error);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // Implementación de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        setUploadingFiles((prev)=>({\n                ...prev,\n                [file.tempId]: {\n                    progress: 0,\n                    error: undefined\n                }\n            }));\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya está subido\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [file.tempId]: {\n                        progress: 100,\n                        error: undefined\n                    }\n                }));\n        }\n    };\n    // Implementación de cancelFileUpload\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Eliminar el archivo de la cola de carga\n        setUploadingFiles((prev)=>{\n            const newState = {\n                ...prev\n            };\n            delete newState[file.tempId];\n            return newState;\n        });\n    };\n    // Función auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [attachment.tempId]: {\n                        progress: 0,\n                        error: undefined\n                    }\n                }));\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: percentCompleted,\n                                error: undefined\n                            }\n                        }));\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            setUploadingFiles((prev)=>({\n                    ...prev,\n                    [attachment.tempId]: {\n                        progress: 0,\n                        error: error.message || \"Error al subir el archivo\"\n                    }\n                }));\n            return null;\n        }\n    };\n    // Esta función se encarga de marcar un mensaje como leído\n    const handleMarkAsRead = (messageId)=>{\n        if (!socketRef.current) return;\n        socketRef.current.emit(\"mark_message_read\", {\n            messageId\n        });\n        // Actualizar el estado de mensajes localmente\n        setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                    ...msg,\n                    isRead: true\n                } : msg));\n    };\n    // Esta función carga más mensajes para la paginación\n    const fetchMoreMessages = async (beforeMessageId)=>{\n        if (!activeChat || !isAuthenticated) return;\n        try {\n            let endpoint = \"\";\n            if (activeChat.type === \"private\") {\n                endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            } else {\n                endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            }\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n            // Añadir los mensajes anteriores al inicio del array de mensajes\n            setMessages((prev)=>[\n                    ...response.data,\n                    ...prev\n                ]);\n            return response.data.length;\n        } catch (error) {\n            console.error(\"Error al cargar m\\xe1s mensajes:\", error);\n            return 0;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            markAsRead: handleMarkAsRead,\n            startTyping: ()=>setTyping(true),\n            stopTyping: ()=>setTyping(false),\n            loadMoreMessages: fetchMoreMessages,\n            retryFileUpload,\n            cancelFileUpload\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 760,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"ygKBXQHUDveXc83kNn6UfJuKVi4=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bnRleHRzL0NoYXRDb250ZXh0LnRzeD8wYjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4vQXV0aENvbnRleHQnO1xuXG5pbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIF9pZD86IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhdmF0YXI6IHN0cmluZztcbiAgaXNPbmxpbmU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZW51bSBGaWxlVHlwZSB7XG4gIElNQUdFID0gJ2ltYWdlJyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBET0NVTUVOVCA9ICdkb2N1bWVudCcsXG4gIEFVRElPID0gJ2F1ZGlvJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVBdHRhY2htZW50IHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgZmlsZVR5cGU6IEZpbGVUeXBlO1xuICBkYXRhPzogc3RyaW5nOyAvLyBCYXNlNjQgZW5jb2RlZCBkYXRhIHBhcmEgYXJjaGl2b3MgcGVxdWXDsW9zXG4gIHNpemU/OiBudW1iZXI7XG4gIGZpbGVJZD86IHN0cmluZzsgLy8gSUQgcGFyYSBhcmNoaXZvcyBncmFuZGVzIGFsbWFjZW5hZG9zIHBvciBzZXBhcmFkb1xuICBpc0xhcmdlRmlsZT86IGJvb2xlYW47IC8vIEluZGljYSBzaSBlbCBhcmNoaXZvIGVzdMOhIGFsbWFjZW5hZG8gcG9yIHNlcGFyYWRvXG4gIGlzQ2h1bms/OiBib29sZWFuO1xuICBvcmlnaW5hbEZpbGVuYW1lPzogc3RyaW5nO1xuICBjaHVua0luZGV4PzogbnVtYmVyO1xuICB0b3RhbENodW5rcz86IG51bWJlcjtcbiAgdGVtcElkPzogc3RyaW5nOyAvLyBJRCB0ZW1wb3JhbCBwYXJhIHNlZ3VpbWllbnRvIGRlIGNhcmdhXG59XG5cbmludGVyZmFjZSBNZXNzYWdlIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGNvbnRlbnQ/OiBzdHJpbmc7XG4gIGF0dGFjaG1lbnRzPzogRmlsZUF0dGFjaG1lbnRbXTtcbiAgc2VuZGVyOiBVc2VyO1xuICByZWNpcGllbnQ/OiBzdHJpbmc7XG4gIHJvb20/OiBzdHJpbmc7XG4gIGlzUmVhZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSb29tIHtcbiAgX2lkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGltYWdlPzogc3RyaW5nO1xuICBjcmVhdG9yOiBVc2VyO1xuICBtZW1iZXJzOiBVc2VyW107XG4gIGlzUHJpdmF0ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIHJlbW92ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ2hhdENvbnRleHRUeXBlIHtcbiAgYWN0aXZlQ2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHJvb21zOiBSb29tW107XG4gIG9ubGluZVVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcbiAgdXNlcnM6IFVzZXJbXTtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmc+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBib29sZWFuO1xuICB1bnJlYWRNZXNzYWdlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgdXBsb2FkaW5nRmlsZXM6IFJlY29yZDxzdHJpbmcsIHsgcHJvZ3Jlc3M6IG51bWJlciwgZXJyb3I/OiBzdHJpbmcgfT47XG4gIHNldEFjdGl2ZUNoYXQ6IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcsIGF0dGFjaG1lbnRzPzogRmlsZVtdKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBtYXJrQXNSZWFkOiAobWVzc2FnZUlkOiBzdHJpbmcpID0+IHZvaWQ7XG4gIHN0YXJ0VHlwaW5nOiAoKSA9PiB2b2lkO1xuICBzdG9wVHlwaW5nOiAoKSA9PiB2b2lkO1xuICBsb2FkTW9yZU1lc3NhZ2VzOiAoYmVmb3JlTWVzc2FnZUlkOiBzdHJpbmcpID0+IFByb21pc2U8bnVtYmVyPjtcbiAgcmV0cnlGaWxlVXBsb2FkOiAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHZvaWQ7XG4gIGNhbmNlbEZpbGVVcGxvYWQ6IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZT4oe1xuICBhY3RpdmVDaGF0OiBudWxsLFxuICBtZXNzYWdlczogW10sXG4gIHJvb21zOiBbXSxcbiAgb25saW5lVXNlcnM6IHt9LFxuICB1c2VyczogW10sXG4gIHR5cGluZ1VzZXJzOiB7fSxcbiAgaXNMb2FkaW5nOiB0cnVlLFxuICBpc0xvYWRpbmdNZXNzYWdlczogZmFsc2UsXG4gIHVucmVhZE1lc3NhZ2VzOiB7fSxcbiAgdXBsb2FkaW5nRmlsZXM6IHt9LFxuICBzZXRBY3RpdmVDaGF0OiAoKSA9PiB7fSxcbiAgc2VuZE1lc3NhZ2U6IGFzeW5jICgpID0+IHt9LFxuICBtYXJrQXNSZWFkOiAoKSA9PiB7fSxcbiAgc3RhcnRUeXBpbmc6ICgpID0+IHt9LFxuICBzdG9wVHlwaW5nOiAoKSA9PiB7fSxcbiAgbG9hZE1vcmVNZXNzYWdlczogYXN5bmMgKCkgPT4gMCxcbiAgcmV0cnlGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbiAgY2FuY2VsRmlsZVVwbG9hZDogKCkgPT4ge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IENoYXRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IHVzZXIsIGlzQXV0aGVudGljYXRlZCB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbYWN0aXZlQ2hhdCwgc2V0QWN0aXZlQ2hhdF0gPSB1c2VTdGF0ZTx7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtyb29tcywgc2V0Um9vbXNdID0gdXNlU3RhdGU8Um9vbVtdPihbXSk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8VXNlcltdPihbXSk7XG4gIGNvbnN0IFtvbmxpbmVVc2Vycywgc2V0T25saW5lVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcbiAgY29uc3QgW3R5cGluZ1VzZXJzLCBzZXRUeXBpbmdVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgc3RyaW5nPj4oe30pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmdNZXNzYWdlcywgc2V0SXNMb2FkaW5nTWVzc2FnZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc29ja2V0Q29ubmVjdGVkLCBzZXRTb2NrZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdW5yZWFkTWVzc2FnZXMsIHNldFVucmVhZE1lc3NhZ2VzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KHt9KTtcbiAgY29uc3QgW3VwbG9hZGluZ0ZpbGVzLCBzZXRVcGxvYWRpbmdGaWxlc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCB7IHByb2dyZXNzOiBudW1iZXIsIGVycm9yPzogc3RyaW5nIH0+Pih7fSk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIFxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRBY3RpdmVDaGF0UmVmID0gdXNlUmVmKGFjdGl2ZUNoYXQpO1xuICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XG4gIFxuICAvLyBLZWVwIHRoZSByZWYgaW4gc3luYyB3aXRoIHRoZSBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQgPSBhY3RpdmVDaGF0O1xuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gIFxuICAvLyBJbml0aWFsaXplIHNvY2tldCBjb25uZWN0aW9uIHdoZW4gYXV0aGVudGljYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkIHx8ICF1c2VyKSB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIFxuICAgIGlmICghdG9rZW4pIHJldHVybjtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKEFQSV9VUkwsIHtcbiAgICAgIGF1dGg6IHsgdG9rZW4gfSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgIC8vIEF1bWVudGFyIGVsIHRpZW1wbyBkZSBlc3BlcmEgcGFyYSBwZXJtaXRpciBlbnbDrW8gZGUgYXJjaGl2b3MgZ3JhbmRlc1xuICAgICAgdGltZW91dDogNjAwMDAgLy8gYXVtZW50YXIgZWwgdGllbXBvIGRlIGVzcGVyYSBhIDYwIHNlZ3VuZG9zXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU29ja2V0IGV2ZW50IGxpc3RlbmVyc1xuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZCh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X21lc3NhZ2UnLCAobWVzc2FnZTogTWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICBcbiAgICAgIC8vIElkZW50aWZpY2FyIGxhIGNsYXZlIGRlIGNoYXQgcGFyYSBzZWd1aW1pZW50byBkZSBub3RpZmljYWNpb25lc1xuICAgICAgbGV0IGNoYXRLZXkgPSAnJztcbiAgICAgIGlmIChtZXNzYWdlLnJvb20pIHtcbiAgICAgICAgY2hhdEtleSA9IGByb29tXyR7bWVzc2FnZS5yb29tfWA7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyLl9pZCAhPT0gdXNlci5pZCkge1xuICAgICAgICBjaGF0S2V5ID0gYHVzZXJfJHttZXNzYWdlLnNlbmRlci5faWR9YDtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5yZWNpcGllbnQpIHtcbiAgICAgICAgY2hhdEtleSA9IGB1c2VyXyR7bWVzc2FnZS5yZWNpcGllbnR9YDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU29sbyBhZ3JlZ2FyIGVsIG1lbnNhamUgc2kgZXMgcmVsZXZhbnRlIHBhcmEgZWwgY2hhdCBhY3Rpdm9cbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBcbiAgICAgICAgICAoKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gYWN0aXZlQ2hhdC5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gdXNlci5pZCkgfHwgXG4gICAgICAgICAgIChtZXNzYWdlLnNlbmRlci5faWQgPT09IHVzZXIuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IGFjdGl2ZUNoYXQuaWQpKSkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBtZXNzYWdlLnJvb20gPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZV0pO1xuICAgICAgfSBcbiAgICAgIC8vIFNpIGVsIG1lbnNhamUgbm8gZXMgcGFyYSBlbCBjaGF0IGFjdGl2byB5IG5vIGZ1ZSBlbnZpYWRvIHBvciBlbCB1c3VhcmlvIGFjdHVhbCwgaW5jcmVtZW50YXIgY29udGFkb3JcbiAgICAgIGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyLl9pZCAhPT0gdXNlci5pZCAmJiBjaGF0S2V5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZXcgbWVzc2FnZSBub3RpZmljYXRpb246JywgY2hhdEtleSwgbWVzc2FnZSk7XG4gICAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIFtjaGF0S2V5XTogKHByZXZbY2hhdEtleV0gfHwgMCkgKyAxXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcl9zdGF0dXNfY2hhbmdlJywgKHsgdXNlcklkLCBpc09ubGluZSB9KSA9PiB7XG4gICAgICBzZXRPbmxpbmVVc2VycyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBpc09ubGluZSB9KSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3R5cGluZ19pbmRpY2F0b3InLCAoZGF0YTogeyB1c2VySWQ6IHN0cmluZywgdXNlck5hbWU6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4sIHJvb21JZD86IHN0cmluZywgc2VuZGVySWQ/OiBzdHJpbmcgfSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgZGF0YS5zZW5kZXJJZCA9PT0gYWN0aXZlQ2hhdC5pZCkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBkYXRhLnJvb21JZCA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICAvLyBBbG1hY2VuYXIgbm9tYnJlIGVuIGx1Z2FyIGRlIHNvbG8gbGEgYmFuZGVyYSBib29sZWFuYVxuICAgICAgICBzZXRUeXBpbmdVc2VycyhwcmV2ID0+ICh7IFxuICAgICAgICAgIC4uLnByZXYsIFxuICAgICAgICAgIFtkYXRhLnVzZXJJZF06IGRhdGEuaXNUeXBpbmcgPyBkYXRhLnVzZXJOYW1lIDogZmFsc2UgXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbWVzc2FnZV9yZWFkJywgKHsgbWVzc2FnZUlkIH0pID0+IHtcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgbmV3IHJvb20gY3JlYXRpb25zXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19yb29tJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgcm9vbSByZWNlaXZlZDonLCByb29tKTtcbiAgICAgIHNldFJvb21zKHByZXYgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm9vbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LnNvbWUociA9PiByLl9pZCA9PT0gcm9vbS5faWQpO1xuICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcHJldjtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCByb29tXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSByb29tIHVwZGF0ZXMgKG1lbWJlcnMgYWRkZWQvcmVtb3ZlZClcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigncm9vbV91cGRhdGVkJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdSb29tIHVwZGF0ZWQ6Jywgcm9vbSk7XG4gICAgICBpZiAocm9vbS5yZW1vdmVkKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vbSB3YXMgcmVtb3ZlZCBmb3IgdGhpcyB1c2VyLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYuZmlsdGVyKHIgPT4gci5faWQgIT09IHJvb20uX2lkKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBhY3RpdmUgY2hhdCBpcyB0aGlzIHJvb20sIGNsZWFyIGl0XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGFjdGl2ZUNoYXQuaWQgPT09IHJvb20uX2lkKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ2hhdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5tYXAociA9PiByLl9pZCA9PT0gcm9vbS5faWQgPyByb29tIDogcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgdXNlciwgQVBJX1VSTF0pO1xuICBcbiAgLy8gTG9hZCBpbml0aWFsIGRhdGE6IHVzZXJzIGFuZCByb29tc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmZXRjaEluaXRpYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgW3VzZXJzUmVzcG9uc2UsIHJvb21zUmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS91c2Vyc2ApLFxuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS9yb29tcy9teWApXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgc2V0VXNlcnModXNlcnNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgc2V0Um9vbXMocm9vbXNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBpbml0aWFsIG9ubGluZSBzdGF0dXNcbiAgICAgICAgY29uc3QgaW5pdGlhbE9ubGluZVN0YXR1czogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbiAgICAgICAgdXNlcnNSZXNwb25zZS5kYXRhLmZvckVhY2goKHVzZXI6IFVzZXIpID0+IHtcbiAgICAgICAgICBpbml0aWFsT25saW5lU3RhdHVzW3VzZXIuX2lkIV0gPSB1c2VyLmlzT25saW5lIHx8IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0T25saW5lVXNlcnMoaW5pdGlhbE9ubGluZVN0YXR1cyk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgaW5pdGlhbCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaEluaXRpYWxEYXRhKCk7XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIEN1YW5kbyBzZSBpbmljaWEgZWwgc29ja2V0IHkgc2UgY29uZWN0YSwgc29saWNpdGFtb3MgZWwgZXN0YWRvIGFjdHVhbCBkZSBtZW5zYWplcyBubyBsZcOtZG9zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNvY2tldENvbm5lY3RlZCAmJiBzb2NrZXRSZWYuY3VycmVudCAmJiB1c2VyKSB7XG4gICAgICAvLyBTb2xpY2l0YXIgbWVuc2FqZXMgbm8gbGXDrWRvcyBhbCBzZXJ2aWRvclxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnZ2V0X3VucmVhZF9tZXNzYWdlcycpO1xuICAgICAgXG4gICAgICAvLyBFc2N1Y2hhciBsYSByZXNwdWVzdGEgY29uIGVsIHJlY3VlbnRvIGRlIG1lbnNhamVzIG5vIGxlw61kb3NcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1bnJlYWRfbWVzc2FnZXNfY291bnQnLCAodW5yZWFkQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCB1bnJlYWQgY291bnRzOicsIHVucmVhZENvdW50cyk7XG4gICAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHVucmVhZENvdW50cyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/Lm9mZigndW5yZWFkX21lc3NhZ2VzX2NvdW50Jyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3NvY2tldENvbm5lY3RlZCwgdXNlcl0pO1xuXG4gIC8vIEFzZWd1cmFyc2UgZGUgcXVlIGxvcyBtZW5zYWplcyBzZSBtYXJxdWVuIGNvbW8gbGXDrWRvcyBjdWFuZG8gc2UgYWJyZSB1biBjaGF0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZUNoYXQgJiYgc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIENyZWFyIHVuYSBjbGF2ZSBwYXJhIGVsIGNoYXQgYWN0dWFsXG4gICAgICBjb25zdCBjaGF0S2V5ID0gYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgXG4gICAgICAgID8gYHVzZXJfJHthY3RpdmVDaGF0LmlkfWAgXG4gICAgICAgIDogYHJvb21fJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0ZWFyIGVsIGNvbnRhZG9yIGRlIG1lbnNhamVzIG5vIGxlw61kb3MgcGFyYSBlc3RlIGNoYXRcbiAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2NoYXRLZXldOiAwXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmaWNhciBhbCBzZXJ2aWRvciBxdWUgbG9zIG1lbnNhamVzIHNlIGhhbiBsZcOtZG9cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ21hcmtfbWVzc2FnZXNfcmVhZCcsIHtcbiAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkLFxuICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICAvLyBGdW5jacOzbiBwYXJhIG1hbmVqYXIgZWwgY2FtYmlvIGRlIGNoYXQgYWN0aXZvXG4gIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UgPSAoY2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGwpID0+IHtcbiAgICAvLyBMaW1waWFyIGxhcyBub3RpZmljYWNpb25lcyBubyBsZcOtZGFzIGN1YW5kbyBzZSBhY3RpdmEgdW4gY2hhdFxuICAgIGlmIChjaGF0KSB7XG4gICAgICBjb25zdCBjaGF0S2V5ID0gY2hhdC50eXBlID09PSAncHJpdmF0ZScgPyBgdXNlcl8ke2NoYXQuaWR9YCA6IGByb29tXyR7Y2hhdC5pZH1gO1xuICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbY2hhdEtleV06IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgXG4gICAgc2V0QWN0aXZlQ2hhdChjaGF0KTtcbiAgfTtcblxuICAvLyBDYXJnYXIgbWVuc2FqZXMgY3VhbmRvIHNlIHNlbGVjY2lvbmEgdW4gY2hhdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhdXNlciB8fCAhaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKHRydWUpO1xuICAgIFxuICAgIGNvbnN0IGZldGNoTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZW5kcG9pbnQgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEpvaW4gdXNlciByb29tIGZvciBkaXJlY3QgbWVzc2FnZXNcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyB1c2VySWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9yb29tLyR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEpvaW4gcm9vbVxuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoZW5kcG9pbnQpO1xuICAgICAgICBzZXRNZXNzYWdlcyhyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmNhciBsb3MgbWVuc2FqZXMgY29tbyBsZcOtZG9zIGVuIGVsIHNlcnZpZG9yXG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbWFya19tZXNzYWdlc19yZWFkJywge1xuICAgICAgICAgICAgY2hhdFR5cGU6IGFjdGl2ZUNoYXQudHlwZSxcbiAgICAgICAgICAgIGNoYXRJZDogYWN0aXZlQ2hhdC5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtZXNzYWdlczonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaE1lc3NhZ2VzKCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIC0gbGVhdmUgcm9vbXNcbiAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdyb29tJykge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbGVhdmVfcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthY3RpdmVDaGF0LCB1c2VyLCBpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkxdKTtcbiAgXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgYXR0YWNobWVudHM/OiBGaWxlW10pID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50IHx8ICFhY3RpdmVDaGF0KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXIgdGVtcElkcyBwYXJhIGxvcyBhcmNoaXZvcyB5IGNvbnZlcnRpcmxvcyBhIEZpbGVBdHRhY2htZW50XG4gICAgICBjb25zdCBhdHRhY2htZW50c1dpdGhJZHM6IEZpbGVBdHRhY2htZW50W10gPSBbXTtcbiAgICAgIFxuICAgICAgaWYgKGF0dGFjaG1lbnRzICYmIGF0dGFjaG1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgdGVtcElkID0gYHRlbXAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERldGVybWluYXIgdGlwbyBkZSBhcmNoaXZvIGRlIGZvcm1hIHNlZ3VyYVxuICAgICAgICAgIGxldCBmaWxlVHlwZSA9IEZpbGVUeXBlLkRPQ1VNRU5UO1xuICAgICAgICAgIGNvbnN0IGZpbGVUeXBlU3RyaW5nID0gZmlsZS50eXBlIHx8ICcnOyAvLyBVc2FyIHN0cmluZyB2YWPDrW8gc2kgdHlwZSBlcyB1bmRlZmluZWRcbiAgICAgICAgICBpZiAoZmlsZVR5cGVTdHJpbmcuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuSU1BR0U7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWxlVHlwZVN0cmluZy5zdGFydHNXaXRoKCd2aWRlby8nKSkge1xuICAgICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5WSURFTztcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVUeXBlU3RyaW5nLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLkFVRElPO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLkRPQ1VNRU5UO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhciBvYmpldG8gRmlsZUF0dGFjaG1lbnQgcGFyYSBlbCBhcmNoaXZvXG4gICAgICAgICAgY29uc3QgYXR0YWNobWVudDogRmlsZUF0dGFjaG1lbnQgPSB7XG4gICAgICAgICAgICB0ZW1wSWQsXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5uYW1lIHx8ICdhcmNoaXZvJyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmaWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICBmaWxlVHlwZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSB8fCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSBlcyB1biBhcmNoaXZvIGdyYW5kZSwgbG8gcHJvY2VzYW1vcyBwYXJhIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDUgKiAxMDI0ICogMTAyNCkgeyAvLyBNw6FzIGRlIDVNQlxuICAgICAgICAgICAgYXR0YWNobWVudC5pc0xhcmdlRmlsZSA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExlZXIgY29tbyBiYXNlNjQgcGFyYSBwcmVwcm9jZXNhbWllbnRvXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAgIC8vIFF1aXRhciBlbCBwcmVmaWpvIChlai4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NENsZWFuID0gYmFzZTY0ZGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IGJhc2U2NENsZWFuO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJbmljaWFyIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgIFt0ZW1wSWRdOiB7IHByb2dyZXNzOiAwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWdyZWdhciBhIGxhIGxpc3RhIGRlIGFkanVudG9zXG4gICAgICAgICAgICBhdHRhY2htZW50c1dpdGhJZHMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSW5pY2lhciBzdWJpZGEgZW4gc2VndW5kbyBwbGFub1xuICAgICAgICAgICAgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIoYXR0YWNobWVudCkudGhlbihmaWxlSWQgPT4ge1xuICAgICAgICAgICAgICBpZiAoZmlsZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsaXphciBlbCBhdHRhY2htZW50IGNvbiBlbCBmaWxlSWRcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmlzTGFyZ2VGaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdHRhY2htZW50LmRhdGEgPSB1bmRlZmluZWQ7IC8vIEVsaW1pbmFyIGxvcyBkYXRvcyBiaW5hcmlvc1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc28gYSAxMDAlXG4gICAgICAgICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAgIFt0ZW1wSWRdOiB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzdWJpZW5kbyBhcmNoaXZvOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgICAgICAgW3RlbXBJZF06IHsgXG4gICAgICAgICAgICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2bydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIHBlcXVlw7FvcyAoPDVNQiksIGxlZXJsb3MgY29tbyBiYXNlNjQgeSBlbnZpYXIgY29uIGVsIG1lbnNhamVcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ZGF0YSA9IHJlYWRlci5yZXN1bHQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgICAgICAgICAgLy8gUXVpdGFyIGVsIHByZWZpam8gKGVqLiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIpXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZTY0Q2xlYW4gPSBiYXNlNjRkYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gYmFzZTY0Q2xlYW47XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFncmVnYXIgYSBsYSBsaXN0YSBkZSBhZGp1bnRvc1xuICAgICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByZXBhcmFyIGRhdG9zIGRlbCBtZW5zYWplXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzV2l0aElkcyxcbiAgICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBFbnZpYXIgZWwgbWVuc2FqZSBhIHRyYXbDqXMgZGVsIHNvY2tldFxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnc2VuZF9tZXNzYWdlJywgbWVzc2FnZURhdGEsIChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVudmlhciBtZW5zYWplOicsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExpbXBpYXIgZm9ybXVsYXJpbyBkZXNwdcOpcyBkZSBlbnZpYXJcbiAgICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICBmaWxlSW5wdXRSZWYuY3VycmVudC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHByb2Nlc2FyIG1lbnNhamU6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGNyZWF0ZVJvb20gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbiA9ICcnLCBpc1ByaXZhdGUgPSBmYWxzZSwgbWVtYmVyczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXNgLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBpc1ByaXZhdGUsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTm8gbmVlZCB0byBtYW51YWxseSBhZGQgdG8gcm9vbXMgYXJyYXksIHRoZSBzb2NrZXQgZXZlbnQgd2lsbCBoYW5kbGUgaXRcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHVwZGF0ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IHsgbmFtZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGltYWdlPzogc3RyaW5nOyBpc1ByaXZhdGU/OiBib29sZWFuIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wdXQoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9YCwgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbG9jYWwgc3RhdGUgdG8gaW1tZWRpYXRlbHkgcmVmbGVjdCBjaGFuZ2VzXG4gICAgICBzZXRSb29tcyhwcmV2Um9vbXMgPT4gXG4gICAgICAgIHByZXZSb29tcy5tYXAocm9vbSA9PiBcbiAgICAgICAgICByb29tLl9pZCA9PT0gcm9vbUlkID8geyAuLi5yb29tLCAuLi5kYXRhIH0gOiByb29tXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGpvaW5Sb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIGFkZGluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1qb2luaW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igam9pbmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGxlYXZlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiByZW1vdmluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1sZWF2aW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsZWF2aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgc2V0VHlwaW5nID0gKGlzVHlwaW5nOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHR5cGluZ0RhdGEgPSB7XG4gICAgICBpc1R5cGluZyxcbiAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgIH07XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgndHlwaW5nJywgdHlwaW5nRGF0YSk7XG4gIH07XG4gIFxuICBjb25zdCBjbGVhckNoYXRIaXN0b3J5ID0gYXN5bmMgKHJlY2lwaWVudElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7cmVjaXBpZW50SWR9YCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQ2hhdCBoaXN0b3J5IGNsZWFyZWQgc3VjY2Vzc2Z1bGx5JyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBjaGF0IGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2xlYXIgY2hhdCBoaXN0b3J5JyB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEltcGxlbWVudGFjacOzbiBkZSByZXRyeUZpbGVVcGxvYWRcbiAgY29uc3QgcmV0cnlGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlc2V0IHByb2dyZXNzXG4gICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIFtmaWxlLnRlbXBJZCFdOiB7IHByb2dyZXNzOiAwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICB9KSk7XG4gICAgXG4gICAgLy8gUHJlcGFyZSBmb3IgcmUtdXBsb2FkXG4gICAgaWYgKGZpbGUuZGF0YSkge1xuICAgICAgLy8gRXMgdW4gYXJjaGl2byB5YSBjb252ZXJ0aWRvIGEgYmFzZTY0XG4gICAgICB1cGxvYWRMYXJnZUZpbGVUb1NlcnZlcihmaWxlKTtcbiAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZUlkKSB7XG4gICAgICAvLyBSZW1vdmVyIGVsIGVycm9yIHBlcm8gbWFudGVuZXIgZWwgcHJvZ3Jlc28gY29tbyBjb21wbGV0YWRvXG4gICAgICAvLyB5YSBxdWUgZWwgYXJjaGl2byB5YSBlc3TDoSBzdWJpZG9cbiAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2ZpbGUudGVtcElkIV06IHsgcHJvZ3Jlc3M6IDEwMCwgZXJyb3I6IHVuZGVmaW5lZCB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gSW1wbGVtZW50YWNpw7NuIGRlIGNhbmNlbEZpbGVVcGxvYWRcbiAgY29uc3QgY2FuY2VsRmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIGlmICghZmlsZS50ZW1wSWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBFbGltaW5hciBlbCBhcmNoaXZvIGRlIGxhIGNvbGEgZGUgY2FyZ2FcbiAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XG4gICAgICBkZWxldGUgbmV3U3RhdGVbZmlsZS50ZW1wSWQhXTtcbiAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICB9KTtcbiAgfTtcbiAgXG4gIC8vIEZ1bmNpw7NuIGF1eGlsaWFyIHBhcmEgc3ViaXIgdW4gYXJjaGl2byBncmFuZGUgZGlyZWN0YW1lbnRlIGFsIHNlcnZpZG9yXG4gIGNvbnN0IHVwbG9hZExhcmdlRmlsZVRvU2VydmVyID0gYXN5bmMgKGF0dGFjaG1lbnQ6IEZpbGVBdHRhY2htZW50KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFhdHRhY2htZW50LnRlbXBJZCkge1xuICAgICAgYXR0YWNobWVudC50ZW1wSWQgPSBgdGVtcC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWA7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0aXIgZGF0b3MgYmFzZTY0IGEgQmxvYiBwYXJhIHN1YmlyXG4gICAgICBjb25zdCBiYXNlNjREYXRhID0gYXR0YWNobWVudC5kYXRhIHx8ICcnO1xuICAgICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGJhc2U2NERhdGEpO1xuICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSA1MTIpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBieXRlQ2hhcmFjdGVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIDUxMik7XG4gICAgICAgIGNvbnN0IGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KHNsaWNlLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuICAgICAgICBieXRlQXJyYXlzLnB1c2goYnl0ZUFycmF5KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZSB9KTtcbiAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShbYmxvYl0sIGF0dGFjaG1lbnQuZmlsZW5hbWUsIHsgdHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZSB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXIgRm9ybURhdGEgcGFyYSBsYSBzdWJpZGFcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gSW5pY2lhciBsYSBjYXJnYSB5IGFjdHVhbGl6YXIgZWwgZXN0YWRvXG4gICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFthdHRhY2htZW50LnRlbXBJZCFdOiB7IHByb2dyZXNzOiAwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgIH0pKTtcbiAgICAgIFxuICAgICAgLy8gUmVhbGl6YXIgbGEgc3ViaWRhIGNvbiBzZWd1aW1pZW50byBkZSBwcm9ncmVzb1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L2ZpbGUtc3RvcmFnZS91cGxvYWRgLCBmb3JtRGF0YSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnRDb21wbGV0ZWQgPSBwcm9ncmVzc0V2ZW50LnRvdGFsIFxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKChwcm9ncmVzc0V2ZW50LmxvYWRlZCAqIDEwMCkgLyBwcm9ncmVzc0V2ZW50LnRvdGFsKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgIFthdHRhY2htZW50LnRlbXBJZCFdOiB7IHByb2dyZXNzOiBwZXJjZW50Q29tcGxldGVkLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmZpbGVJZCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5maWxlSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBzdWJpciBhcmNoaXZvOicsIGVycm9yKTtcbiAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkIV06IHsgXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsIFxuICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBzdWJpciBlbCBhcmNoaXZvJ1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBFc3RhIGZ1bmNpw7NuIHNlIGVuY2FyZ2EgZGUgbWFyY2FyIHVuIG1lbnNhamUgY29tbyBsZcOtZG9cbiAgY29uc3QgaGFuZGxlTWFya0FzUmVhZCA9IChtZXNzYWdlSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghc29ja2V0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdtYXJrX21lc3NhZ2VfcmVhZCcsIHsgbWVzc2FnZUlkIH0pO1xuICAgIFxuICAgIC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvIGRlIG1lbnNhamVzIGxvY2FsbWVudGVcbiAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFxuICAgICAgcHJldi5tYXAobXNnID0+IFxuICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgIClcbiAgICApO1xuICB9O1xuICBcbiAgLy8gRXN0YSBmdW5jacOzbiBjYXJnYSBtw6FzIG1lbnNhamVzIHBhcmEgbGEgcGFnaW5hY2nDs25cbiAgY29uc3QgZmV0Y2hNb3JlTWVzc2FnZXMgPSBhc3luYyAoYmVmb3JlTWVzc2FnZUlkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIWlzQXV0aGVudGljYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBsZXQgZW5kcG9pbnQgPSAnJztcbiAgICAgIFxuICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7YWN0aXZlQ2hhdC5pZH0/YmVmb3JlPSR7YmVmb3JlTWVzc2FnZUlkfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL3Jvb20vJHthY3RpdmVDaGF0LmlkfT9iZWZvcmU9JHtiZWZvcmVNZXNzYWdlSWR9YDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoZW5kcG9pbnQpO1xuICAgICAgXG4gICAgICAvLyBBw7FhZGlyIGxvcyBtZW5zYWplcyBhbnRlcmlvcmVzIGFsIGluaWNpbyBkZWwgYXJyYXkgZGUgbWVuc2FqZXNcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnJlc3BvbnNlLmRhdGEsIC4uLnByZXZdKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBjYXJnYXIgbcOhcyBtZW5zYWplczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gKFxuICAgIDxDaGF0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgYWN0aXZlQ2hhdCxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgcm9vbXMsXG4gICAgICBvbmxpbmVVc2VycyxcbiAgICAgIHVzZXJzLFxuICAgICAgdHlwaW5nVXNlcnMsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc0xvYWRpbmdNZXNzYWdlcyxcbiAgICAgIHVucmVhZE1lc3NhZ2VzLFxuICAgICAgdXBsb2FkaW5nRmlsZXMsXG4gICAgICBzZXRBY3RpdmVDaGF0OiBoYW5kbGVBY3RpdmVDaGF0Q2hhbmdlLFxuICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICBtYXJrQXNSZWFkOiBoYW5kbGVNYXJrQXNSZWFkLFxuICAgICAgc3RhcnRUeXBpbmc6ICgpID0+IHNldFR5cGluZyh0cnVlKSxcbiAgICAgIHN0b3BUeXBpbmc6ICgpID0+IHNldFR5cGluZyhmYWxzZSksXG4gICAgICBsb2FkTW9yZU1lc3NhZ2VzOiBmZXRjaE1vcmVNZXNzYWdlcyxcbiAgICAgIHJldHJ5RmlsZVVwbG9hZCxcbiAgICAgIGNhbmNlbEZpbGVVcGxvYWRcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NoYXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbyIsImF4aW9zIiwidXNlQXV0aCIsIkZpbGVUeXBlIiwiQ2hhdENvbnRleHQiLCJhY3RpdmVDaGF0IiwibWVzc2FnZXMiLCJyb29tcyIsIm9ubGluZVVzZXJzIiwidXNlcnMiLCJ0eXBpbmdVc2VycyIsImlzTG9hZGluZyIsImlzTG9hZGluZ01lc3NhZ2VzIiwidW5yZWFkTWVzc2FnZXMiLCJ1cGxvYWRpbmdGaWxlcyIsInNldEFjdGl2ZUNoYXQiLCJzZW5kTWVzc2FnZSIsIm1hcmtBc1JlYWQiLCJzdGFydFR5cGluZyIsInN0b3BUeXBpbmciLCJsb2FkTW9yZU1lc3NhZ2VzIiwicmV0cnlGaWxlVXBsb2FkIiwiY2FuY2VsRmlsZVVwbG9hZCIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nTWVzc2FnZXMiLCJzb2NrZXRDb25uZWN0ZWQiLCJzZXRTb2NrZXRDb25uZWN0ZWQiLCJzZXRVbnJlYWRNZXNzYWdlcyIsInNldFVwbG9hZGluZ0ZpbGVzIiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJmaWxlSW5wdXRSZWYiLCJjdXJyZW50IiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ0aW1lb3V0Iiwib24iLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImNoYXRLZXkiLCJyb29tIiwic2VuZGVyIiwiX2lkIiwiaWQiLCJyZWNpcGllbnQiLCJ0eXBlIiwicHJldiIsInVzZXJJZCIsImlzT25saW5lIiwiZGF0YSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJ1c2VyTmFtZSIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImZldGNoSW5pdGlhbERhdGEiLCJ1c2Vyc1Jlc3BvbnNlIiwicm9vbXNSZXNwb25zZSIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJpbml0aWFsT25saW5lU3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiZW1pdCIsInVucmVhZENvdW50cyIsIm9mZiIsImNoYXRJZCIsImNoYXRUeXBlIiwiaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSIsImNoYXQiLCJmZXRjaE1lc3NhZ2VzIiwiZW5kcG9pbnQiLCJyZXNwb25zZSIsImxlbmd0aCIsImNvbnRlbnQiLCJhdHRhY2htZW50cyIsImF0dGFjaG1lbnRzV2l0aElkcyIsImZpbGUiLCJ0ZW1wSWQiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZmlsZVR5cGUiLCJmaWxlVHlwZVN0cmluZyIsInN0YXJ0c1dpdGgiLCJhdHRhY2htZW50IiwiZmlsZW5hbWUiLCJuYW1lIiwiY29udGVudFR5cGUiLCJzaXplIiwiaXNMYXJnZUZpbGUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsInJlc29sdmUiLCJvbmxvYWQiLCJiYXNlNjRkYXRhIiwicmVzdWx0IiwiYmFzZTY0Q2xlYW4iLCJzcGxpdCIsInByb2dyZXNzIiwidW5kZWZpbmVkIiwicHVzaCIsInVwbG9hZExhcmdlRmlsZVRvU2VydmVyIiwidGhlbiIsImZpbGVJZCIsImNhdGNoIiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsInN1Y2Nlc3MiLCJ2YWx1ZSIsImNyZWF0ZVJvb20iLCJkZXNjcmlwdGlvbiIsImlzUHJpdmF0ZSIsIm1lbWJlcnMiLCJwb3N0IiwidXBkYXRlUm9vbSIsInVwZGF0ZURhdGEiLCJwdXQiLCJwcmV2Um9vbXMiLCJqb2luUm9vbSIsInRhcmdldFVzZXJJZCIsImxlYXZlUm9vbSIsImRlbGV0ZSIsInNldFR5cGluZyIsInR5cGluZ0RhdGEiLCJjbGVhckNoYXRIaXN0b3J5IiwibmV3U3RhdGUiLCJiYXNlNjREYXRhIiwiYnl0ZUNoYXJhY3RlcnMiLCJhdG9iIiwiYnl0ZUFycmF5cyIsIm9mZnNldCIsInNsaWNlIiwiYnl0ZU51bWJlcnMiLCJBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiYnl0ZUFycmF5IiwiVWludDhBcnJheSIsImJsb2IiLCJCbG9iIiwiRmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJoZWFkZXJzIiwib25VcGxvYWRQcm9ncmVzcyIsInByb2dyZXNzRXZlbnQiLCJwZXJjZW50Q29tcGxldGVkIiwidG90YWwiLCJyb3VuZCIsImxvYWRlZCIsImhhbmRsZU1hcmtBc1JlYWQiLCJmZXRjaE1vcmVNZXNzYWdlcyIsImJlZm9yZU1lc3NhZ2VJZCIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});