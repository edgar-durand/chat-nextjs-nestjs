"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>0,\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{},\n    deleteMessage: async ()=>false\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFilesByChat, setUploadingFilesByChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const uploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!activeChat) return {};\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        return uploadingFilesByChat[chatId] || {};\n    }, [\n        activeChat,\n        uploadingFilesByChat\n    ]);\n    const updateUploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chatId, fileId, data)=>{\n        console.log(\"Actualizando estado de archivo \".concat(fileId, \" en chat \").concat(chatId, \":\"), data);\n        setUploadingFilesByChat((prev)=>{\n            const newState = {\n                ...prev\n            };\n            // Si no existe el chat, lo creamos\n            if (!newState[chatId]) {\n                newState[chatId] = {};\n            }\n            // Si data es null, eliminamos el archivo\n            if (data === null) {\n                if (newState[chatId][fileId]) {\n                    const { [fileId]: _, ...restFiles } = newState[chatId];\n                    newState[chatId] = restFiles;\n                    console.log(\"Eliminado archivo \".concat(fileId, \" de chat \").concat(chatId));\n                }\n            } else {\n                // Actualizamos o agregamos el archivo\n                newState[chatId][fileId] = data;\n                console.log(\"Actualizado archivo \".concat(fileId, \" en chat \").concat(chatId, \" con progreso \").concat(data.progress, \"%\"));\n            }\n            return newState;\n        });\n    }, []);\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId || !activeChat) return;\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, null);\n    };\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envÃ­o de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room-\".concat(message.room);\n            } else {\n                chatKey = message.sender._id === user.id ? \"private-\".concat(message.recipient) : \"private-\".concat(message.sender._id);\n            }\n            console.log(\"Mensaje recibido:\", message, \"Chat activo:\", activeChat);\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                console.log(\"Agregando mensaje al chat activo:\", message);\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leÃ­dos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leÃ­dos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leÃ­dos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leÃ­dos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n            // Resetear el contador de mensajes no leÃ­dos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leÃ­do\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // FunciÃ³n para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leÃ­das cuando se activa un chat\n        if (chat) {\n            const chatKey = \"\".concat(chat.type, \"-\").concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Efecto para actualizar los mensajes cuando cambia el chat activo\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated) return;\n        // Resetear el estado al cambiar de chat\n        setMessages([]);\n        setIsLoadingMessages(true);\n        // Reiniciar estados de mensajes no leÃ­dos y archivos en carga\n        if (activeChat) {\n            // Limpiar mensajes no leÃ­dos\n            setUnreadMessages((prev)=>{\n                const chatKey = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n                if (prev[chatKey]) {\n                    const newState = {\n                        ...prev\n                    };\n                    delete newState[chatKey];\n                    return newState;\n                }\n                return prev;\n            });\n            // Asegurarnos de que la secciÃ³n \"Archivos en proceso\" desaparezca al cambiar de chat\n            // incluso cuando ya habÃ­a terminado la carga con 100%\n            const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n            if (chatId in uploadingFilesByChat) {\n                const hasCompletedUploads = Object.values(uploadingFilesByChat[chatId]).some((status)=>status.progress === 100);\n                if (hasCompletedUploads) {\n                    setUploadingFilesByChat((prev)=>{\n                        const newState = {\n                            ...prev\n                        };\n                        delete newState[chatId];\n                        return newState;\n                    });\n                }\n            }\n        }\n        // Solicitar mensajes al servidor\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leÃ­dos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    // Efecto para limpiar archivos completados automÃ¡ticamente\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Revisa cada 2 segundos si hay archivos que estÃ¡n al 100% que deban eliminarse\n        const cleanupInterval = setInterval(()=>{\n            setUploadingFilesByChat((prev)=>{\n                const newState = {\n                    ...prev\n                };\n                let hasChanges = false;\n                // Revisar todos los chats\n                Object.keys(newState).forEach((chatId)=>{\n                    // Revisar todos los archivos en ese chat\n                    Object.keys(newState[chatId]).forEach((fileId)=>{\n                        // Si un archivo estÃ¡ al 100%, eliminarlo\n                        if (newState[chatId][fileId].progress === 100) {\n                            delete newState[chatId][fileId];\n                            hasChanges = true;\n                        }\n                    });\n                    // Si el chat ya no tiene archivos, eliminar el chat\n                    if (Object.keys(newState[chatId]).length === 0) {\n                        delete newState[chatId];\n                        hasChanges = true;\n                    }\n                });\n                return hasChanges ? newState : prev;\n            });\n        }, 2000);\n        return ()=>clearInterval(cleanupInterval);\n    }, []);\n    const sendMessage = async (content, selectedFile)=>{\n        if (!socketRef.current || !activeChat) return;\n        try {\n            // Generar tempIds para los archivos y convertirlos a FileAttachment\n            const attachmentsWithIds = [];\n            if (selectedFile) {\n                const tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n                // Determinar tipo de archivo de forma segura\n                let fileType = \"document\";\n                const fileTypeString = selectedFile.type || \"\"; // Usar string vacÃ­o si type es undefined\n                if (fileTypeString.startsWith(\"image/\")) {\n                    fileType = \"image\";\n                } else if (fileTypeString.startsWith(\"video/\")) {\n                    fileType = \"video\";\n                } else if (fileTypeString.startsWith(\"audio/\")) {\n                    fileType = \"audio\";\n                } else {\n                    fileType = \"document\";\n                }\n                // Crear objeto FileAttachment para el archivo\n                const attachment = {\n                    tempId,\n                    filename: selectedFile.name || \"archivo\",\n                    contentType: selectedFile.type || \"application/octet-stream\",\n                    fileType,\n                    size: selectedFile.size || 0\n                };\n                // Iniciar indicador de carga inmediatamente para todos los archivos\n                const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n                updateUploadingFiles(chatId, tempId, {\n                    progress: 0,\n                    error: undefined\n                });\n                // Si es un archivo grande, lo procesamos para subida en segundo plano\n                if (selectedFile.size > 5 * 1024 * 1024) {\n                    attachment.isLargeFile = true;\n                    // Leer como base64 para preprocesamiento\n                    const reader = new FileReader();\n                    reader.readAsDataURL(selectedFile);\n                    await new Promise((resolve)=>{\n                        reader.onload = ()=>{\n                            var _reader_result;\n                            const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                            // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                            const base64Clean = base64data.split(\",\")[1];\n                            attachment.data = base64Clean;\n                            resolve();\n                        };\n                    });\n                    // Agregar a la lista de adjuntos\n                    attachmentsWithIds.push(attachment);\n                    // Iniciar subida en segundo plano\n                    uploadLargeFileToServer(attachment).then((fileId)=>{\n                        if (fileId) {\n                            // Actualizar el attachment con el fileId\n                            attachment.fileId = fileId;\n                            attachment.isLargeFile = true;\n                            attachment.data = undefined; // Eliminar los datos binarios\n                            // Actualizar progreso a 100%\n                            updateUploadingFiles(chatId, tempId, {\n                                progress: 100,\n                                error: undefined\n                            });\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Error subiendo archivo:\", error);\n                        updateUploadingFiles(chatId, tempId, {\n                            progress: 0,\n                            error: error.message || \"Error al subir el archivo\"\n                        });\n                    });\n                } else {\n                    // Para archivos pequeÃ±os (<5MB), leerlos como base64 y enviar con el mensaje\n                    const reader = new FileReader();\n                    reader.readAsDataURL(selectedFile);\n                    await new Promise((resolve)=>{\n                        reader.onload = ()=>{\n                            var _reader_result;\n                            const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                            // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                            const base64Clean = base64data.split(\",\")[1];\n                            attachment.data = base64Clean;\n                            resolve();\n                        };\n                    });\n                    // Agregar a la lista de adjuntos\n                    attachmentsWithIds.push(attachment);\n                    // Marcar como completado tambiÃ©n para archivos pequeÃ±os\n                    updateUploadingFiles(chatId, tempId, {\n                        progress: 100,\n                        error: undefined\n                    });\n                }\n            }\n            // Preparar datos del mensaje\n            const messageData = {\n                content,\n                attachments: attachmentsWithIds,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            console.log(\"Enviando mensaje:\", messageData);\n            // Enviar el mensaje a travÃ©s del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                console.log(\"Respuesta al enviar mensaje:\", response);\n                if (!response.success) {\n                    console.error(\"Error al enviar mensaje:\", response.error);\n                }\n            });\n            // Limpiar formulario despuÃ©s de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar mensaje:\", error);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // ImplementaciÃ³n de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, {\n            progress: 0,\n            error: undefined\n        });\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya estÃ¡ subido\n            updateUploadingFiles(chatId, file.tempId, {\n                progress: 100,\n                error: undefined\n            });\n        }\n    };\n    // FunciÃ³n auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: undefined\n            });\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    console.log(\"Progreso de subida para \".concat(attachment.tempId, \": \").concat(percentCompleted, \"%\"));\n                    updateUploadingFiles(chatId, attachment.tempId, {\n                        progress: percentCompleted,\n                        error: undefined\n                    });\n                    // Si el archivo ha terminado de cargarse (100%), lo eliminamos de la lista despuÃ©s de un segundo\n                    if (percentCompleted === 100) {\n                        console.log(\"Subida completada para \".concat(attachment.tempId, \", eliminando en 1 segundo\"));\n                        // Esperar un segundo para que el usuario vea que se completÃ³ y luego eliminar\n                        setTimeout(()=>{\n                            updateUploadingFiles(chatId, attachment.tempId, null);\n                        }, 1000);\n                    }\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: error.message || \"Error al subir el archivo\"\n            });\n            return null;\n        }\n    };\n    // Esta funciÃ³n se encarga de marcar un mensaje como leÃ­do\n    const handleMarkAsRead = (messageId)=>{\n        if (!socketRef.current) return;\n        socketRef.current.emit(\"mark_message_read\", {\n            messageId\n        });\n        // Actualizar el estado de mensajes localmente\n        setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                    ...msg,\n                    isRead: true\n                } : msg));\n    };\n    // Esta funciÃ³n carga mÃ¡s mensajes para la paginaciÃ³n\n    const fetchMoreMessages = async (page)=>{\n        if (!activeChat || !user || !isAuthenticated) return;\n        try {\n            let endpoint = \"\";\n            if (activeChat.type === \"private\") {\n                endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id, \"?page=\").concat(page);\n            } else {\n                endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id, \"?page=\").concat(page);\n            }\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n            // AÃ±adir los mensajes anteriores al inicio del array de mensajes\n            setMessages((prev)=>[\n                    ...response.data,\n                    ...prev\n                ]);\n            return response.data.length;\n        } catch (error) {\n            console.error(\"Error al cargar m\\xe1s mensajes:\", error);\n            return 0;\n        }\n    };\n    const deleteMessage = async (messageId, deleteForEveryone)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/message/\").concat(messageId), {\n                params: {\n                    deleteForEveryone\n                }\n            });\n            if (response.data.success) {\n                // Eliminar el mensaje del estado local\n                setMessages((prev)=>prev.filter((msg)=>msg._id !== messageId));\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error al eliminar mensaje:\", error);\n            return false;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            markAsRead: handleMarkAsRead,\n            startTyping: ()=>setTyping(true),\n            stopTyping: ()=>setTyping(false),\n            loadMoreMessages: fetchMoreMessages,\n            retryFileUpload,\n            cancelFileUpload,\n            deleteMessage\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 874,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"WkNbpqBjcVKNxVZQELMlCtrIcQo=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aEQsT0FBTztZQUMzQnpKO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDLGVBQWU2RjtZQUNmNUY7WUFDQUMsWUFBWXdMO1lBQ1p2TCxhQUFhLElBQU0wSixVQUFVO1lBQzdCekosWUFBWSxJQUFNeUosVUFBVTtZQUM1QnhKLGtCQUFrQnNMO1lBQ2xCckw7WUFDQUM7WUFDQUM7UUFDRjtrQkFDR0c7Ozs7OztBQUdQLEVBQUU7SUF4eEJXRDs7UUFDdUJ2QixpREFBT0E7OztLQUQ5QnVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9DaGF0Q29udGV4dC50c3g/MGI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgX2lkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGF2YXRhcjogc3RyaW5nO1xuICBpc09ubGluZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIEZpbGVUeXBlIHtcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBWSURFTyA9ICd2aWRlbycsXG4gIERPQ1VNRU5UID0gJ2RvY3VtZW50JyxcbiAgQVVESU8gPSAnYXVkaW8nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUF0dGFjaG1lbnQge1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBmaWxlVHlwZTogRmlsZVR5cGU7XG4gIGRhdGE/OiBzdHJpbmc7IC8vIEJhc2U2NCBlbmNvZGVkIGRhdGEgcGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3NcbiAgc2l6ZT86IG51bWJlcjtcbiAgZmlsZUlkPzogc3RyaW5nOyAvLyBJRCBwYXJhIGFyY2hpdm9zIGdyYW5kZXMgYWxtYWNlbmFkb3MgcG9yIHNlcGFyYWRvXG4gIGlzTGFyZ2VGaWxlPzogYm9vbGVhbjsgLy8gSW5kaWNhIHNpIGVsIGFyY2hpdm8gZXN0w6EgYWxtYWNlbmFkbyBwb3Igc2VwYXJhZG9cbiAgaXNDaHVuaz86IGJvb2xlYW47XG4gIG9yaWdpbmFsRmlsZW5hbWU/OiBzdHJpbmc7XG4gIGNodW5rSW5kZXg/OiBudW1iZXI7XG4gIHRvdGFsQ2h1bmtzPzogbnVtYmVyO1xuICB0ZW1wSWQ/OiBzdHJpbmc7IC8vIElEIHRlbXBvcmFsIHBhcmEgc2VndWltaWVudG8gZGUgY2FyZ2Fcbn1cblxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBfaWQ6IHN0cmluZztcbiAgY29udGVudD86IHN0cmluZztcbiAgYXR0YWNobWVudHM/OiBGaWxlQXR0YWNobWVudFtdO1xuICBzZW5kZXI6IFVzZXI7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgcm9vbT86IHN0cmluZztcbiAgaXNSZWFkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJvb20ge1xuICBfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNyZWF0b3I6IFVzZXI7XG4gIG1lbWJlcnM6IFVzZXJbXTtcbiAgaXNQcml2YXRlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgcmVtb3ZlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBhY3RpdmVDaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbDtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgcm9vbXM6IFJvb21bXTtcbiAgb25saW5lVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICB1c2VyczogVXNlcltdO1xuICB0eXBpbmdVc2VyczogUmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZz47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgaXNMb2FkaW5nTWVzc2FnZXM6IGJvb2xlYW47XG4gIHVucmVhZE1lc3NhZ2VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB1cGxvYWRpbmdGaWxlczogUmVjb3JkPHN0cmluZywgeyBwcm9ncmVzczogbnVtYmVyLCBlcnJvcj86IHN0cmluZyB9PjtcbiAgc2V0QWN0aXZlQ2hhdDogKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB2b2lkO1xuICBzZW5kTWVzc2FnZTogKGNvbnRlbnQ6IHN0cmluZywgc2VsZWN0ZWRGaWxlOiBGaWxlIHwgbnVsbCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgbWFya0FzUmVhZDogKG1lc3NhZ2VJZDogc3RyaW5nKSA9PiB2b2lkO1xuICBzdGFydFR5cGluZzogKCkgPT4gdm9pZDtcbiAgc3RvcFR5cGluZzogKCkgPT4gdm9pZDtcbiAgbG9hZE1vcmVNZXNzYWdlczogKHBhZ2U6IG51bWJlcikgPT4gUHJvbWlzZTxudW1iZXI+O1xuICByZXRyeUZpbGVVcGxvYWQ6IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4gdm9pZDtcbiAgY2FuY2VsRmlsZVVwbG9hZDogKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB2b2lkO1xuICBkZWxldGVNZXNzYWdlOiAobWVzc2FnZUlkOiBzdHJpbmcsIGRlbGV0ZUZvckV2ZXJ5b25lOiBib29sZWFuKSA9PiBQcm9taXNlPGJvb2xlYW4+O1xufVxuXG5jb25zdCBDaGF0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2hhdENvbnRleHRUeXBlPih7XG4gIGFjdGl2ZUNoYXQ6IG51bGwsXG4gIG1lc3NhZ2VzOiBbXSxcbiAgcm9vbXM6IFtdLFxuICBvbmxpbmVVc2Vyczoge30sXG4gIHVzZXJzOiBbXSxcbiAgdHlwaW5nVXNlcnM6IHt9LFxuICBpc0xvYWRpbmc6IHRydWUsXG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBmYWxzZSxcbiAgdW5yZWFkTWVzc2FnZXM6IHt9LFxuICB1cGxvYWRpbmdGaWxlczoge30sXG4gIHNldEFjdGl2ZUNoYXQ6ICgpID0+IHt9LFxuICBzZW5kTWVzc2FnZTogYXN5bmMgKCkgPT4ge30sXG4gIG1hcmtBc1JlYWQ6ICgpID0+IHt9LFxuICBzdGFydFR5cGluZzogKCkgPT4ge30sXG4gIHN0b3BUeXBpbmc6ICgpID0+IHt9LFxuICBsb2FkTW9yZU1lc3NhZ2VzOiBhc3luYyAoKSA9PiAwLFxuICByZXRyeUZpbGVVcGxvYWQ6ICgpID0+IHt9LFxuICBjYW5jZWxGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbiAgZGVsZXRlTWVzc2FnZTogYXN5bmMgKCkgPT4gZmFsc2UsXG59KTtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IENoYXRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IHVzZXIsIGlzQXV0aGVudGljYXRlZCB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbYWN0aXZlQ2hhdCwgc2V0QWN0aXZlQ2hhdF0gPSB1c2VTdGF0ZTx7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtyb29tcywgc2V0Um9vbXNdID0gdXNlU3RhdGU8Um9vbVtdPihbXSk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8VXNlcltdPihbXSk7XG4gIGNvbnN0IFtvbmxpbmVVc2Vycywgc2V0T25saW5lVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcbiAgY29uc3QgW3R5cGluZ1VzZXJzLCBzZXRUeXBpbmdVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgc3RyaW5nPj4oe30pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmdNZXNzYWdlcywgc2V0SXNMb2FkaW5nTWVzc2FnZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc29ja2V0Q29ubmVjdGVkLCBzZXRTb2NrZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdW5yZWFkTWVzc2FnZXMsIHNldFVucmVhZE1lc3NhZ2VzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KHt9KTtcbiAgY29uc3QgW3VwbG9hZGluZ0ZpbGVzQnlDaGF0LCBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdF0gPSB1c2VTdGF0ZTx7XG4gICAgW2NoYXRJZDogc3RyaW5nXToge1xuICAgICAgW2ZpbGVJZDogc3RyaW5nXToge1xuICAgICAgICBwcm9ncmVzczogbnVtYmVyO1xuICAgICAgICBlcnJvcj86IHN0cmluZztcbiAgICAgIH1cbiAgICB9XG4gIH0+KHt9KTtcbiAgY29uc3QgW3NlbGVjdGVkRmlsZSwgc2V0U2VsZWN0ZWRGaWxlXSA9IHVzZVN0YXRlPEZpbGUgfCBudWxsPihudWxsKTtcbiAgXG4gIGNvbnN0IHVwbG9hZGluZ0ZpbGVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0KSByZXR1cm4ge307XG4gICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdC50eXBlfS0ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICByZXR1cm4gdXBsb2FkaW5nRmlsZXNCeUNoYXRbY2hhdElkXSB8fCB7fTtcbiAgfSwgW2FjdGl2ZUNoYXQsIHVwbG9hZGluZ0ZpbGVzQnlDaGF0XSk7XG5cbiAgY29uc3QgdXBkYXRlVXBsb2FkaW5nRmlsZXMgPSB1c2VDYWxsYmFjaygoXG4gICAgY2hhdElkOiBzdHJpbmcsXG4gICAgZmlsZUlkOiBzdHJpbmcsXG4gICAgZGF0YTogeyBwcm9ncmVzczogbnVtYmVyOyBlcnJvcj86IHN0cmluZyB9IHwgbnVsbFxuICApID0+IHtcbiAgICBjb25zb2xlLmxvZyhgQWN0dWFsaXphbmRvIGVzdGFkbyBkZSBhcmNoaXZvICR7ZmlsZUlkfSBlbiBjaGF0ICR7Y2hhdElkfTpgLCBkYXRhKTtcbiAgICBcbiAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XG4gICAgICBcbiAgICAgIC8vIFNpIG5vIGV4aXN0ZSBlbCBjaGF0LCBsbyBjcmVhbW9zXG4gICAgICBpZiAoIW5ld1N0YXRlW2NoYXRJZF0pIHtcbiAgICAgICAgbmV3U3RhdGVbY2hhdElkXSA9IHt9O1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBTaSBkYXRhIGVzIG51bGwsIGVsaW1pbmFtb3MgZWwgYXJjaGl2b1xuICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXSkge1xuICAgICAgICAgIGNvbnN0IHsgW2ZpbGVJZF06IF8sIC4uLnJlc3RGaWxlcyB9ID0gbmV3U3RhdGVbY2hhdElkXTtcbiAgICAgICAgICBuZXdTdGF0ZVtjaGF0SWRdID0gcmVzdEZpbGVzO1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBFbGltaW5hZG8gYXJjaGl2byAke2ZpbGVJZH0gZGUgY2hhdCAke2NoYXRJZH1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWN0dWFsaXphbW9zIG8gYWdyZWdhbW9zIGVsIGFyY2hpdm9cbiAgICAgICAgbmV3U3RhdGVbY2hhdElkXVtmaWxlSWRdID0gZGF0YTtcbiAgICAgICAgY29uc29sZS5sb2coYEFjdHVhbGl6YWRvIGFyY2hpdm8gJHtmaWxlSWR9IGVuIGNoYXQgJHtjaGF0SWR9IGNvbiBwcm9ncmVzbyAke2RhdGEucHJvZ3Jlc3N9JWApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjYW5jZWxGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCB8fCAhYWN0aXZlQ2hhdCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCBmaWxlLnRlbXBJZCwgbnVsbCk7XG4gIH07XG5cbiAgY29uc3Qgc29ja2V0UmVmID0gdXNlUmVmPFNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjdXJyZW50QWN0aXZlQ2hhdFJlZiA9IHVzZVJlZihhY3RpdmVDaGF0KTtcbiAgY29uc3QgZmlsZUlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xuICBcbiAgLy8gS2VlcCB0aGUgcmVmIGluIHN5bmMgd2l0aCB0aGUgc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50ID0gYWN0aXZlQ2hhdDtcbiAgfSwgW2FjdGl2ZUNoYXRdKTtcbiAgXG4gIGNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBzb2NrZXQgY29ubmVjdGlvbiB3aGVuIGF1dGhlbnRpY2F0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCB8fCAhdXNlcikge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICBcbiAgICBpZiAoIXRva2VuKSByZXR1cm47XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQgPSBpbyhBUElfVVJMLCB7XG4gICAgICBhdXRoOiB7IHRva2VuIH0sXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICAvLyBBdW1lbnRhciBlbCB0aWVtcG8gZGUgZXNwZXJhIHBhcmEgcGVybWl0aXIgZW52w61vIGRlIGFyY2hpdm9zIGdyYW5kZXNcbiAgICAgIHRpbWVvdXQ6IDYwMDAwIC8vIGF1bWVudGFyIGVsIHRpZW1wbyBkZSBlc3BlcmEgYSA2MCBzZWd1bmRvc1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNvY2tldCBldmVudCBsaXN0ZW5lcnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19tZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgXG4gICAgICAvLyBJZGVudGlmaWNhciBsYSBjbGF2ZSBkZSBjaGF0IHBhcmEgc2VndWltaWVudG8gZGUgbm90aWZpY2FjaW9uZXNcbiAgICAgIGxldCBjaGF0S2V5ID0gJyc7XG4gICAgICBpZiAobWVzc2FnZS5yb29tKSB7XG4gICAgICAgIGNoYXRLZXkgPSBgcm9vbS0ke21lc3NhZ2Uucm9vbX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhdEtleSA9IG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gdXNlci5pZCA/IGBwcml2YXRlLSR7bWVzc2FnZS5yZWNpcGllbnR9YCA6IGBwcml2YXRlLSR7bWVzc2FnZS5zZW5kZXIuX2lkfWA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdNZW5zYWplIHJlY2liaWRvOicsIG1lc3NhZ2UsICdDaGF0IGFjdGl2bzonLCBhY3RpdmVDaGF0KTtcbiAgICAgIFxuICAgICAgLy8gU29sbyBhZ3JlZ2FyIGVsIG1lbnNhamUgc2kgZXMgcmVsZXZhbnRlIHBhcmEgZWwgY2hhdCBhY3Rpdm9cbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBcbiAgICAgICAgICAoKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gYWN0aXZlQ2hhdC5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gdXNlci5pZCkgfHwgXG4gICAgICAgICAgIChtZXNzYWdlLnNlbmRlci5faWQgPT09IHVzZXIuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IGFjdGl2ZUNoYXQuaWQpKSkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBtZXNzYWdlLnJvb20gPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0FncmVnYW5kbyBtZW5zYWplIGFsIGNoYXQgYWN0aXZvOicsIG1lc3NhZ2UpO1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBtZXNzYWdlXSk7XG4gICAgICB9IFxuICAgICAgLy8gU2kgZWwgbWVuc2FqZSBubyBlcyBwYXJhIGVsIGNoYXQgYWN0aXZvIHkgbm8gZnVlIGVudmlhZG8gcG9yIGVsIHVzdWFyaW8gYWN0dWFsLCBpbmNyZW1lbnRhciBjb250YWRvclxuICAgICAgZWxzZSBpZiAobWVzc2FnZS5zZW5kZXIuX2lkICE9PSB1c2VyLmlkICYmIGNoYXRLZXkpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ05ldyBtZXNzYWdlIG5vdGlmaWNhdGlvbjonLCBjaGF0S2V5LCBtZXNzYWdlKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgW2NoYXRLZXldOiAocHJldltjaGF0S2V5XSB8fCAwKSArIDFcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VyX3N0YXR1c19jaGFuZ2UnLCAoeyB1c2VySWQsIGlzT25saW5lIH0pID0+IHtcbiAgICAgIHNldE9ubGluZVVzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IGlzT25saW5lIH0pKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndHlwaW5nX2luZGljYXRvcicsIChkYXRhOiB7IHVzZXJJZDogc3RyaW5nLCB1c2VyTmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbiwgcm9vbUlkPzogc3RyaW5nLCBzZW5kZXJJZD86IHN0cmluZyB9KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBkYXRhLnNlbmRlcklkID09PSBhY3RpdmVDaGF0LmlkKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGRhdGEucm9vbUlkID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIC8vIEFsbWFjZW5hciBub21icmUgZW4gbHVnYXIgZGUgc29sbyBsYSBiYW5kZXJhIGJvb2xlYW5hXG4gICAgICAgIHNldFR5cGluZ1VzZXJzKHByZXYgPT4gKHsgXG4gICAgICAgICAgLi4ucHJldiwgXG4gICAgICAgICAgW2RhdGEudXNlcklkXTogZGF0YS5pc1R5cGluZyA/IGRhdGEudXNlck5hbWUgOiBmYWxzZSBcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdtZXNzYWdlX3JlYWQnLCAoeyBtZXNzYWdlSWQgfSkgPT4ge1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAobXNnID0+IFxuICAgICAgICAgIG1zZy5faWQgPT09IG1lc3NhZ2VJZCA/IHsgLi4ubXNnLCBpc1JlYWQ6IHRydWUgfSA6IG1zZ1xuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSBuZXcgcm9vbSBjcmVhdGlvbnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X3Jvb20nLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ05ldyByb29tIHJlY2VpdmVkOicsIHJvb20pO1xuICAgICAgc2V0Um9vbXMocHJldiA9PiB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSByb29tIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIGNvbnN0IGV4aXN0cyA9IHByZXYuc29tZShyID0+IHIuX2lkID09PSByb29tLl9pZCk7XG4gICAgICAgIGlmIChleGlzdHMpIHJldHVybiBwcmV2O1xuICAgICAgICByZXR1cm4gWy4uLnByZXYsIHJvb21dO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIHJvb20gdXBkYXRlcyAobWVtYmVycyBhZGRlZC9yZW1vdmVkKVxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdyb29tX3VwZGF0ZWQnLCAocm9vbTogUm9vbSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1Jvb20gdXBkYXRlZDonLCByb29tKTtcbiAgICAgIGlmIChyb29tLnJlbW92ZWQpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb29tIHdhcyByZW1vdmVkIGZvciB0aGlzIHVzZXIsIHJlbW92ZSBpdCBmcm9tIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5maWx0ZXIociA9PiByLl9pZCAhPT0gcm9vbS5faWQpKTtcbiAgICAgICAgXG4gICAgICAgIC8vIElmIGFjdGl2ZSBjaGF0IGlzIHRoaXMgcm9vbSwgY2xlYXIgaXRcbiAgICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgYWN0aXZlQ2hhdC5pZCA9PT0gcm9vbS5faWQpIHtcbiAgICAgICAgICBzZXRBY3RpdmVDaGF0KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJvb20gaW4gdGhlIGxpc3RcbiAgICAgICAgc2V0Um9vbXMocHJldiA9PiBwcmV2Lm1hcChyID0+IHIuX2lkID09PSByb29tLl9pZCA/IHJvb20gOiByKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Rpc2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGRpc2Nvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICB9O1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCB1c2VyLCBBUElfVVJMXSk7XG4gIFxuICAvLyBMb2FkIGluaXRpYWwgZGF0YTogdXNlcnMgYW5kIHJvb21zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZldGNoSW5pdGlhbERhdGEgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBbdXNlcnNSZXNwb25zZSwgcm9vbXNSZXNwb25zZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3VzZXJzYCksXG4gICAgICAgICAgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L3Jvb21zL215YClcbiAgICAgICAgXSk7XG4gICAgICAgIFxuICAgICAgICBzZXRVc2Vycyh1c2Vyc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBzZXRSb29tcyhyb29tc1Jlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gU2V0IGluaXRpYWwgb25saW5lIHN0YXR1c1xuICAgICAgICBjb25zdCBpbml0aWFsT25saW5lU3RhdHVzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPiA9IHt9O1xuICAgICAgICB1c2Vyc1Jlc3BvbnNlLmRhdGEuZm9yRWFjaCgodXNlcjogVXNlcikgPT4ge1xuICAgICAgICAgIGluaXRpYWxPbmxpbmVTdGF0dXNbdXNlci5faWQhXSA9IHVzZXIuaXNPbmxpbmUgfHwgZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzZXRPbmxpbmVVc2Vycyhpbml0aWFsT25saW5lU3RhdHVzKTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBpbml0aWFsIGRhdGE6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoSW5pdGlhbERhdGEoKTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgLy8gQ3VhbmRvIHNlIGluaWNpYSBlbCBzb2NrZXQgeSBzZSBjb25lY3RhLCBzb2xpY2l0YW1vcyBlbCBlc3RhZG8gYWN0dWFsIGRlIG1lbnNhamVzIG5vIGxlw61kb3NcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoc29ja2V0Q29ubmVjdGVkICYmIHNvY2tldFJlZi5jdXJyZW50ICYmIHVzZXIpIHtcbiAgICAgIC8vIFNvbGljaXRhciBtZW5zYWplcyBubyBsZcOtZG9zIGFsIHNlcnZpZG9yXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdnZXRfdW5yZWFkX21lc3NhZ2VzJyk7XG4gICAgICBcbiAgICAgIC8vIEVzY3VjaGFyIGxhIHJlc3B1ZXN0YSBjb24gZWwgcmVjdWVudG8gZGUgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICAgICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VucmVhZF9tZXNzYWdlc19jb3VudCcsICh1bnJlYWRDb3VudHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4pID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIHVucmVhZCBjb3VudHM6JywgdW5yZWFkQ291bnRzKTtcbiAgICAgICAgc2V0VW5yZWFkTWVzc2FnZXModW5yZWFkQ291bnRzKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8ub2ZmKCd1bnJlYWRfbWVzc2FnZXNfY291bnQnKTtcbiAgICAgIH07XG4gICAgfVxuICB9LCBbc29ja2V0Q29ubmVjdGVkLCB1c2VyXSk7XG5cbiAgLy8gQXNlZ3VyYXJzZSBkZSBxdWUgbG9zIG1lbnNhamVzIHNlIG1hcnF1ZW4gY29tbyBsZcOtZG9zIGN1YW5kbyBzZSBhYnJlIHVuIGNoYXRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWN0aXZlQ2hhdCAmJiBzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgLy8gQ3JlYXIgdW5hIGNsYXZlIHBhcmEgZWwgY2hhdCBhY3R1YWxcbiAgICAgIGNvbnN0IGNoYXRLZXkgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgXG4gICAgICAvLyBSZXNldGVhciBlbCBjb250YWRvciBkZSBtZW5zYWplcyBubyBsZcOtZG9zIHBhcmEgZXN0ZSBjaGF0XG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjaGF0S2V5XTogMFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBOb3RpZmljYXIgYWwgc2Vydmlkb3IgcXVlIGxvcyBtZW5zYWplcyBzZSBoYW4gbGXDrWRvXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdtYXJrX21lc3NhZ2VzX3JlYWQnLCB7XG4gICAgICAgIGNoYXRJZDogYWN0aXZlQ2hhdC5pZCxcbiAgICAgICAgY2hhdFR5cGU6IGFjdGl2ZUNoYXQudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgLy8gRnVuY2nDs24gcGFyYSBtYW5lamFyIGVsIGNhbWJpbyBkZSBjaGF0IGFjdGl2b1xuICBjb25zdCBoYW5kbGVBY3RpdmVDaGF0Q2hhbmdlID0gKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB7XG4gICAgLy8gTGltcGlhciBsYXMgbm90aWZpY2FjaW9uZXMgbm8gbGXDrWRhcyBjdWFuZG8gc2UgYWN0aXZhIHVuIGNoYXRcbiAgICBpZiAoY2hhdCkge1xuICAgICAgY29uc3QgY2hhdEtleSA9IGAke2NoYXQudHlwZX0tJHtjaGF0LmlkfWA7XG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjaGF0S2V5XTogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgICBcbiAgICBzZXRBY3RpdmVDaGF0KGNoYXQpO1xuICB9O1xuXG4gIC8vIEVmZWN0byBwYXJhIGFjdHVhbGl6YXIgbG9zIG1lbnNhamVzIGN1YW5kbyBjYW1iaWEgZWwgY2hhdCBhY3Rpdm9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIWlzQXV0aGVudGljYXRlZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlc2V0ZWFyIGVsIGVzdGFkbyBhbCBjYW1iaWFyIGRlIGNoYXRcbiAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgc2V0SXNMb2FkaW5nTWVzc2FnZXModHJ1ZSk7XG4gICAgXG4gICAgLy8gUmVpbmljaWFyIGVzdGFkb3MgZGUgbWVuc2FqZXMgbm8gbGXDrWRvcyB5IGFyY2hpdm9zIGVuIGNhcmdhXG4gICAgaWYgKGFjdGl2ZUNoYXQpIHtcbiAgICAgIC8vIExpbXBpYXIgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IGNoYXRLZXkgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICBpZiAocHJldltjaGF0S2V5XSkge1xuICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5wcmV2IH07XG4gICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2NoYXRLZXldO1xuICAgICAgICAgIHJldHVybiBuZXdTdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJldjtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBBc2VndXJhcm5vcyBkZSBxdWUgbGEgc2VjY2nDs24gXCJBcmNoaXZvcyBlbiBwcm9jZXNvXCIgZGVzYXBhcmV6Y2EgYWwgY2FtYmlhciBkZSBjaGF0XG4gICAgICAvLyBpbmNsdXNvIGN1YW5kbyB5YSBoYWLDrWEgdGVybWluYWRvIGxhIGNhcmdhIGNvbiAxMDAlXG4gICAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgaWYgKGNoYXRJZCBpbiB1cGxvYWRpbmdGaWxlc0J5Q2hhdCkge1xuICAgICAgICBjb25zdCBoYXNDb21wbGV0ZWRVcGxvYWRzID0gT2JqZWN0LnZhbHVlcyh1cGxvYWRpbmdGaWxlc0J5Q2hhdFtjaGF0SWRdKVxuICAgICAgICAgIC5zb21lKHN0YXR1cyA9PiBzdGF0dXMucHJvZ3Jlc3MgPT09IDEwMCk7XG4gICAgICAgICAgXG4gICAgICAgIGlmIChoYXNDb21wbGV0ZWRVcGxvYWRzKSB7XG4gICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXQocHJldiA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHsuLi5wcmV2fTtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdO1xuICAgICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29saWNpdGFyIG1lbnNhamVzIGFsIHNlcnZpZG9yXG4gICAgY29uc3QgZmV0Y2hNZXNzYWdlcyA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBlbmRwb2ludCA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiB1c2VyIHJvb20gZm9yIGRpcmVjdCBtZXNzYWdlc1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHVzZXJJZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL3Jvb20vJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiByb29tXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChlbmRwb2ludCk7XG4gICAgICAgIHNldE1lc3NhZ2VzKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFyY2FyIGxvcyBtZW5zYWplcyBjb21vIGxlw61kb3MgZW4gZWwgc2Vydmlkb3JcbiAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdtYXJrX21lc3NhZ2VzX3JlYWQnLCB7XG4gICAgICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlLFxuICAgICAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoTWVzc2FnZXMoKTtcbiAgICBcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgLy8gQ2xlYW4gdXAgLSBsZWF2ZSByb29tc1xuICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3Jvb20nKSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdsZWF2ZV9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW2FjdGl2ZUNoYXQsIHVzZXIsIGlzQXV0aGVudGljYXRlZCwgQVBJX1VSTF0pO1xuICBcbiAgLy8gRWZlY3RvIHBhcmEgbGltcGlhciBhcmNoaXZvcyBjb21wbGV0YWRvcyBhdXRvbcOhdGljYW1lbnRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gUmV2aXNhIGNhZGEgMiBzZWd1bmRvcyBzaSBoYXkgYXJjaGl2b3MgcXVlIGVzdMOhbiBhbCAxMDAlIHF1ZSBkZWJhbiBlbGltaW5hcnNlXG4gICAgY29uc3QgY2xlYW51cEludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXQocHJldiA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gey4uLnByZXZ9O1xuICAgICAgICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgLy8gUmV2aXNhciB0b2RvcyBsb3MgY2hhdHNcbiAgICAgICAgT2JqZWN0LmtleXMobmV3U3RhdGUpLmZvckVhY2goY2hhdElkID0+IHtcbiAgICAgICAgICAvLyBSZXZpc2FyIHRvZG9zIGxvcyBhcmNoaXZvcyBlbiBlc2UgY2hhdFxuICAgICAgICAgIE9iamVjdC5rZXlzKG5ld1N0YXRlW2NoYXRJZF0pLmZvckVhY2goZmlsZUlkID0+IHtcbiAgICAgICAgICAgIC8vIFNpIHVuIGFyY2hpdm8gZXN0w6EgYWwgMTAwJSwgZWxpbWluYXJsb1xuICAgICAgICAgICAgaWYgKG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXS5wcm9ncmVzcyA9PT0gMTAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdW2ZpbGVJZF07XG4gICAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpIGVsIGNoYXQgeWEgbm8gdGllbmUgYXJjaGl2b3MsIGVsaW1pbmFyIGVsIGNoYXRcbiAgICAgICAgICBpZiAoT2JqZWN0LmtleXMobmV3U3RhdGVbY2hhdElkXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBkZWxldGUgbmV3U3RhdGVbY2hhdElkXTtcbiAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlcyA/IG5ld1N0YXRlIDogcHJldjtcbiAgICAgIH0pO1xuICAgIH0sIDIwMDApO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGNsZWFudXBJbnRlcnZhbCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBzZW5kTWVzc2FnZSA9IGFzeW5jIChjb250ZW50OiBzdHJpbmcsIHNlbGVjdGVkRmlsZTogRmlsZSB8IG51bGwpID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50IHx8ICFhY3RpdmVDaGF0KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXIgdGVtcElkcyBwYXJhIGxvcyBhcmNoaXZvcyB5IGNvbnZlcnRpcmxvcyBhIEZpbGVBdHRhY2htZW50XG4gICAgICBjb25zdCBhdHRhY2htZW50c1dpdGhJZHM6IEZpbGVBdHRhY2htZW50W10gPSBbXTtcbiAgICAgIFxuICAgICAgaWYgKHNlbGVjdGVkRmlsZSkge1xuICAgICAgICBjb25zdCB0ZW1wSWQgPSBgdGVtcC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWA7XG4gICAgICAgIFxuICAgICAgICAvLyBEZXRlcm1pbmFyIHRpcG8gZGUgYXJjaGl2byBkZSBmb3JtYSBzZWd1cmFcbiAgICAgICAgbGV0IGZpbGVUeXBlID0gRmlsZVR5cGUuRE9DVU1FTlQ7XG4gICAgICAgIGNvbnN0IGZpbGVUeXBlU3RyaW5nID0gc2VsZWN0ZWRGaWxlLnR5cGUgfHwgJyc7IC8vIFVzYXIgc3RyaW5nIHZhY8OtbyBzaSB0eXBlIGVzIHVuZGVmaW5lZFxuICAgICAgICBpZiAoZmlsZVR5cGVTdHJpbmcuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLklNQUdFO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVUeXBlU3RyaW5nLnN0YXJ0c1dpdGgoJ3ZpZGVvLycpKSB7XG4gICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5WSURFTztcbiAgICAgICAgfSBlbHNlIGlmIChmaWxlVHlwZVN0cmluZy5zdGFydHNXaXRoKCdhdWRpby8nKSkge1xuICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuQVVESU87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5ET0NVTUVOVDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQ3JlYXIgb2JqZXRvIEZpbGVBdHRhY2htZW50IHBhcmEgZWwgYXJjaGl2b1xuICAgICAgICBjb25zdCBhdHRhY2htZW50OiBGaWxlQXR0YWNobWVudCA9IHtcbiAgICAgICAgICB0ZW1wSWQsXG4gICAgICAgICAgZmlsZW5hbWU6IHNlbGVjdGVkRmlsZS5uYW1lIHx8ICdhcmNoaXZvJyxcbiAgICAgICAgICBjb250ZW50VHlwZTogc2VsZWN0ZWRGaWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgZmlsZVR5cGUsXG4gICAgICAgICAgc2l6ZTogc2VsZWN0ZWRGaWxlLnNpemUgfHwgMFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLy8gSW5pY2lhciBpbmRpY2Fkb3IgZGUgY2FyZ2EgaW5tZWRpYXRhbWVudGUgcGFyYSB0b2RvcyBsb3MgYXJjaGl2b3NcbiAgICAgICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdD8udHlwZX0tJHthY3RpdmVDaGF0Py5pZH1gO1xuICAgICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQhLCB0ZW1wSWQsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTaSBlcyB1biBhcmNoaXZvIGdyYW5kZSwgbG8gcHJvY2VzYW1vcyBwYXJhIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgIGlmIChzZWxlY3RlZEZpbGUuc2l6ZSA+IDUgKiAxMDI0ICogMTAyNCkgeyAvLyBNw6FzIGRlIDVNQlxuICAgICAgICAgIGF0dGFjaG1lbnQuaXNMYXJnZUZpbGUgPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIExlZXIgY29tbyBiYXNlNjQgcGFyYSBwcmVwcm9jZXNhbWllbnRvXG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChzZWxlY3RlZEZpbGUpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBiYXNlNjRkYXRhID0gcmVhZGVyLnJlc3VsdD8udG9TdHJpbmcoKSB8fCAnJztcbiAgICAgICAgICAgICAgLy8gUXVpdGFyIGVsIHByZWZpam8gKGVqLiBcImRhdGE6aW1hZ2UvanBlZztiYXNlNjQsXCIpXG4gICAgICAgICAgICAgIGNvbnN0IGJhc2U2NENsZWFuID0gYmFzZTY0ZGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICBhdHRhY2htZW50LmRhdGEgPSBiYXNlNjRDbGVhbjtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBBZ3JlZ2FyIGEgbGEgbGlzdGEgZGUgYWRqdW50b3NcbiAgICAgICAgICBhdHRhY2htZW50c1dpdGhJZHMucHVzaChhdHRhY2htZW50KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBJbmljaWFyIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgICAgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIoYXR0YWNobWVudCkudGhlbihmaWxlSWQgPT4ge1xuICAgICAgICAgICAgaWYgKGZpbGVJZCkge1xuICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVsIGF0dGFjaG1lbnQgY29uIGVsIGZpbGVJZFxuICAgICAgICAgICAgICBhdHRhY2htZW50LmZpbGVJZCA9IGZpbGVJZDtcbiAgICAgICAgICAgICAgYXR0YWNobWVudC5pc0xhcmdlRmlsZSA9IHRydWU7XG4gICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IHVuZGVmaW5lZDsgLy8gRWxpbWluYXIgbG9zIGRhdG9zIGJpbmFyaW9zXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIHByb2dyZXNvIGEgMTAwJVxuICAgICAgICAgICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQsIHRlbXBJZCwgeyBwcm9ncmVzczogMTAwLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1YmllbmRvIGFyY2hpdm86JywgZXJyb3IpO1xuICAgICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCB0ZW1wSWQsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBzdWJpciBlbCBhcmNoaXZvJyB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJhIGFyY2hpdm9zIHBlcXVlw7FvcyAoPDVNQiksIGxlZXJsb3MgY29tbyBiYXNlNjQgeSBlbnZpYXIgY29uIGVsIG1lbnNhamVcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKHNlbGVjdGVkRmlsZSk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAvLyBRdWl0YXIgZWwgcHJlZmlqbyAoZWouIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIilcbiAgICAgICAgICAgICAgY29uc3QgYmFzZTY0Q2xlYW4gPSBiYXNlNjRkYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IGJhc2U2NENsZWFuO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFncmVnYXIgYSBsYSBsaXN0YSBkZSBhZGp1bnRvc1xuICAgICAgICAgIGF0dGFjaG1lbnRzV2l0aElkcy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIE1hcmNhciBjb21vIGNvbXBsZXRhZG8gdGFtYmnDqW4gcGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3NcbiAgICAgICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQsIHRlbXBJZCwgeyBwcm9ncmVzczogMTAwLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFByZXBhcmFyIGRhdG9zIGRlbCBtZW5zYWplXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzV2l0aElkcyxcbiAgICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgICB9O1xuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnRW52aWFuZG8gbWVuc2FqZTonLCBtZXNzYWdlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIEVudmlhciBlbCBtZW5zYWplIGEgdHJhdsOpcyBkZWwgc29ja2V0XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdzZW5kX21lc3NhZ2UnLCBtZXNzYWdlRGF0YSwgKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ1Jlc3B1ZXN0YSBhbCBlbnZpYXIgbWVuc2FqZTonLCByZXNwb25zZSk7XG4gICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVudmlhciBtZW5zYWplOicsIHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExpbXBpYXIgZm9ybXVsYXJpbyBkZXNwdcOpcyBkZSBlbnZpYXJcbiAgICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICBmaWxlSW5wdXRSZWYuY3VycmVudC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHByb2Nlc2FyIG1lbnNhamU6JywgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGNyZWF0ZVJvb20gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbiA9ICcnLCBpc1ByaXZhdGUgPSBmYWxzZSwgbWVtYmVyczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXNgLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBpc1ByaXZhdGUsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTm8gbmVlZCB0byBtYW51YWxseSBhZGQgdG8gcm9vbXMgYXJyYXksIHRoZSBzb2NrZXQgZXZlbnQgd2lsbCBoYW5kbGUgaXRcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHVwZGF0ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IHsgbmFtZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGltYWdlPzogc3RyaW5nOyBpc1ByaXZhdGU/OiBib29sZWFuIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wdXQoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9YCwgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbG9jYWwgc3RhdGUgdG8gaW1tZWRpYXRlbHkgcmVmbGVjdCBjaGFuZ2VzXG4gICAgICBzZXRSb29tcyhwcmV2Um9vbXMgPT4gXG4gICAgICAgIHByZXZSb29tcy5tYXAocm9vbSA9PiBcbiAgICAgICAgICByb29tLl9pZCA9PT0gcm9vbUlkID8geyAuLi5yb29tLCAuLi5kYXRhIH0gOiByb29tXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGpvaW5Sb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIGFkZGluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1qb2luaW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igam9pbmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGxlYXZlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiByZW1vdmluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1sZWF2aW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsZWF2aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgc2V0VHlwaW5nID0gKGlzVHlwaW5nOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHR5cGluZ0RhdGEgPSB7XG4gICAgICBpc1R5cGluZyxcbiAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgIH07XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgndHlwaW5nJywgdHlwaW5nRGF0YSk7XG4gIH07XG4gIFxuICBjb25zdCBjbGVhckNoYXRIaXN0b3J5ID0gYXN5bmMgKHJlY2lwaWVudElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7cmVjaXBpZW50SWR9YCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQ2hhdCBoaXN0b3J5IGNsZWFyZWQgc3VjY2Vzc2Z1bGx5JyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBjaGF0IGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2xlYXIgY2hhdCBoaXN0b3J5JyB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEltcGxlbWVudGFjacOzbiBkZSByZXRyeUZpbGVVcGxvYWRcbiAgY29uc3QgcmV0cnlGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCkgcmV0dXJuO1xuICAgIFxuICAgIC8vIFJlc2V0IHByb2dyZXNzXG4gICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdD8udHlwZX0tJHthY3RpdmVDaGF0Py5pZH1gO1xuICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGZpbGUudGVtcElkISwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICBcbiAgICAvLyBQcmVwYXJlIGZvciByZS11cGxvYWRcbiAgICBpZiAoZmlsZS5kYXRhKSB7XG4gICAgICAvLyBFcyB1biBhcmNoaXZvIHlhIGNvbnZlcnRpZG8gYSBiYXNlNjRcbiAgICAgIHVwbG9hZExhcmdlRmlsZVRvU2VydmVyKGZpbGUpO1xuICAgIH0gZWxzZSBpZiAoZmlsZS5maWxlSWQpIHtcbiAgICAgIC8vIFJlbW92ZXIgZWwgZXJyb3IgcGVybyBtYW50ZW5lciBlbCBwcm9ncmVzbyBjb21vIGNvbXBsZXRhZG9cbiAgICAgIC8vIHlhIHF1ZSBlbCBhcmNoaXZvIHlhIGVzdMOhIHN1Ymlkb1xuICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgZmlsZS50ZW1wSWQhLCB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRnVuY2nDs24gYXV4aWxpYXIgcGFyYSBzdWJpciB1biBhcmNoaXZvIGdyYW5kZSBkaXJlY3RhbWVudGUgYWwgc2Vydmlkb3JcbiAgY29uc3QgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIgPSBhc3luYyAoYXR0YWNobWVudDogRmlsZUF0dGFjaG1lbnQpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+ID0+IHtcbiAgICBpZiAoIWF0dGFjaG1lbnQudGVtcElkKSB7XG4gICAgICBhdHRhY2htZW50LnRlbXBJZCA9IGB0ZW1wLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YDtcbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIENvbnZlcnRpciBkYXRvcyBiYXNlNjQgYSBCbG9iIHBhcmEgc3ViaXJcbiAgICAgIGNvbnN0IGJhc2U2NERhdGEgPSBhdHRhY2htZW50LmRhdGEgfHwgJyc7XG4gICAgICBjb25zdCBieXRlQ2hhcmFjdGVycyA9IGF0b2IoYmFzZTY0RGF0YSk7XG4gICAgICBjb25zdCBieXRlQXJyYXlzID0gW107XG4gICAgICBcbiAgICAgIGZvciAobGV0IG9mZnNldCA9IDA7IG9mZnNldCA8IGJ5dGVDaGFyYWN0ZXJzLmxlbmd0aDsgb2Zmc2V0ICs9IDUxMikge1xuICAgICAgICBjb25zdCBzbGljZSA9IGJ5dGVDaGFyYWN0ZXJzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgNTEyKTtcbiAgICAgICAgY29uc3QgYnl0ZU51bWJlcnMgPSBuZXcgQXJyYXkoc2xpY2UubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGljZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGJ5dGVOdW1iZXJzW2ldID0gc2xpY2UuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG4gICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgYXR0YWNobWVudC5maWxlbmFtZSwgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgXG4gICAgICAvLyBDcmVhciBGb3JtRGF0YSBwYXJhIGxhIHN1YmlkYVxuICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgIGZvcm1EYXRhLmFwcGVuZCgnZmlsZScsIGZpbGUpO1xuICAgICAgXG4gICAgICAvLyBJbmljaWFyIGxhIGNhcmdhIHkgYWN0dWFsaXphciBlbCBlc3RhZG9cbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQ/LnR5cGV9LSR7YWN0aXZlQ2hhdD8uaWR9YDtcbiAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgIFxuICAgICAgLy8gUmVhbGl6YXIgbGEgc3ViaWRhIGNvbiBzZWd1aW1pZW50byBkZSBwcm9ncmVzb1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L2ZpbGUtc3RvcmFnZS91cGxvYWRgLCBmb3JtRGF0YSwge1xuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9LFxuICAgICAgICBvblVwbG9hZFByb2dyZXNzOiAocHJvZ3Jlc3NFdmVudCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBlcmNlbnRDb21wbGV0ZWQgPSBwcm9ncmVzc0V2ZW50LnRvdGFsIFxuICAgICAgICAgICAgPyBNYXRoLnJvdW5kKChwcm9ncmVzc0V2ZW50LmxvYWRlZCAqIDEwMCkgLyBwcm9ncmVzc0V2ZW50LnRvdGFsKVxuICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2dyZXNvIGRlIHN1YmlkYSBwYXJhICR7YXR0YWNobWVudC50ZW1wSWR9OiAke3BlcmNlbnRDb21wbGV0ZWR9JWApO1xuICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBwcm9ncmVzczogcGVyY2VudENvbXBsZXRlZCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSBlbCBhcmNoaXZvIGhhIHRlcm1pbmFkbyBkZSBjYXJnYXJzZSAoMTAwJSksIGxvIGVsaW1pbmFtb3MgZGUgbGEgbGlzdGEgZGVzcHXDqXMgZGUgdW4gc2VndW5kb1xuICAgICAgICAgIGlmIChwZXJjZW50Q29tcGxldGVkID09PSAxMDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWJpZGEgY29tcGxldGFkYSBwYXJhICR7YXR0YWNobWVudC50ZW1wSWR9LCBlbGltaW5hbmRvIGVuIDEgc2VndW5kb2ApO1xuICAgICAgICAgICAgLy8gRXNwZXJhciB1biBzZWd1bmRvIHBhcmEgcXVlIGVsIHVzdWFyaW8gdmVhIHF1ZSBzZSBjb21wbGV0w7MgeSBsdWVnbyBlbGltaW5hclxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgbnVsbCk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmZpbGVJZCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5maWxlSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBzdWJpciBhcmNoaXZvOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQ/LnR5cGV9LSR7YWN0aXZlQ2hhdD8uaWR9YDtcbiAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBcbiAgICAgICAgcHJvZ3Jlc3M6IDAsIFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2bydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRXN0YSBmdW5jacOzbiBzZSBlbmNhcmdhIGRlIG1hcmNhciB1biBtZW5zYWplIGNvbW8gbGXDrWRvXG4gIGNvbnN0IGhhbmRsZU1hcmtBc1JlYWQgPSAobWVzc2FnZUlkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnbWFya19tZXNzYWdlX3JlYWQnLCB7IG1lc3NhZ2VJZCB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWxpemFyIGVsIGVzdGFkbyBkZSBtZW5zYWplcyBsb2NhbG1lbnRlXG4gICAgc2V0TWVzc2FnZXMocHJldiA9PiBcbiAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgbXNnLl9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIGlzUmVhZDogdHJ1ZSB9IDogbXNnXG4gICAgICApXG4gICAgKTtcbiAgfTtcbiAgXG4gIC8vIEVzdGEgZnVuY2nDs24gY2FyZ2EgbcOhcyBtZW5zYWplcyBwYXJhIGxhIHBhZ2luYWNpw7NuXG4gIGNvbnN0IGZldGNoTW9yZU1lc3NhZ2VzID0gYXN5bmMgKHBhZ2U6IG51bWJlcikgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhdXNlciB8fCAhaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGxldCBlbmRwb2ludCA9ICcnO1xuICAgICAgXG4gICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfT9wYWdlPSR7cGFnZX1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9yb29tLyR7YWN0aXZlQ2hhdC5pZH0/cGFnZT0ke3BhZ2V9YDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoZW5kcG9pbnQpO1xuICAgICAgXG4gICAgICAvLyBBw7FhZGlyIGxvcyBtZW5zYWplcyBhbnRlcmlvcmVzIGFsIGluaWNpbyBkZWwgYXJyYXkgZGUgbWVuc2FqZXNcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnJlc3BvbnNlLmRhdGEsIC4uLnByZXZdKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubGVuZ3RoO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBjYXJnYXIgbcOhcyBtZW5zYWplczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBkZWxldGVNZXNzYWdlID0gYXN5bmMgKG1lc3NhZ2VJZDogc3RyaW5nLCBkZWxldGVGb3JFdmVyeW9uZTogYm9vbGVhbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmRlbGV0ZShgJHtBUElfVVJMfS9jaGF0cy9tZXNzYWdlLyR7bWVzc2FnZUlkfWAsIHtcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgZGVsZXRlRm9yRXZlcnlvbmUsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgaWYgKHJlc3BvbnNlLmRhdGEuc3VjY2Vzcykge1xuICAgICAgICAvLyBFbGltaW5hciBlbCBtZW5zYWplIGRlbCBlc3RhZG8gbG9jYWxcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBwcmV2LmZpbHRlcihtc2cgPT4gbXNnLl9pZCAhPT0gbWVzc2FnZUlkKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBlbGltaW5hciBtZW5zYWplOicsIGVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG4gIFxuICByZXR1cm4gKFxuICAgIDxDaGF0Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17e1xuICAgICAgYWN0aXZlQ2hhdCxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgcm9vbXMsXG4gICAgICBvbmxpbmVVc2VycyxcbiAgICAgIHVzZXJzLFxuICAgICAgdHlwaW5nVXNlcnMsXG4gICAgICBpc0xvYWRpbmcsXG4gICAgICBpc0xvYWRpbmdNZXNzYWdlcyxcbiAgICAgIHVucmVhZE1lc3NhZ2VzLFxuICAgICAgdXBsb2FkaW5nRmlsZXMsXG4gICAgICBzZXRBY3RpdmVDaGF0OiBoYW5kbGVBY3RpdmVDaGF0Q2hhbmdlLFxuICAgICAgc2VuZE1lc3NhZ2UsXG4gICAgICBtYXJrQXNSZWFkOiBoYW5kbGVNYXJrQXNSZWFkLFxuICAgICAgc3RhcnRUeXBpbmc6ICgpID0+IHNldFR5cGluZyh0cnVlKSxcbiAgICAgIHN0b3BUeXBpbmc6ICgpID0+IHNldFR5cGluZyhmYWxzZSksXG4gICAgICBsb2FkTW9yZU1lc3NhZ2VzOiBmZXRjaE1vcmVNZXNzYWdlcyxcbiAgICAgIHJldHJ5RmlsZVVwbG9hZCxcbiAgICAgIGNhbmNlbEZpbGVVcGxvYWQsXG4gICAgICBkZWxldGVNZXNzYWdlLFxuICAgIH19PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvQ2hhdENvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZU1lbW8iLCJ1c2VDYWxsYmFjayIsImlvIiwiYXhpb3MiLCJ1c2VBdXRoIiwiRmlsZVR5cGUiLCJDaGF0Q29udGV4dCIsImFjdGl2ZUNoYXQiLCJtZXNzYWdlcyIsInJvb21zIiwib25saW5lVXNlcnMiLCJ1c2VycyIsInR5cGluZ1VzZXJzIiwiaXNMb2FkaW5nIiwiaXNMb2FkaW5nTWVzc2FnZXMiLCJ1bnJlYWRNZXNzYWdlcyIsInVwbG9hZGluZ0ZpbGVzIiwic2V0QWN0aXZlQ2hhdCIsInNlbmRNZXNzYWdlIiwibWFya0FzUmVhZCIsInN0YXJ0VHlwaW5nIiwic3RvcFR5cGluZyIsImxvYWRNb3JlTWVzc2FnZXMiLCJyZXRyeUZpbGVVcGxvYWQiLCJjYW5jZWxGaWxlVXBsb2FkIiwiZGVsZXRlTWVzc2FnZSIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nTWVzc2FnZXMiLCJzb2NrZXRDb25uZWN0ZWQiLCJzZXRTb2NrZXRDb25uZWN0ZWQiLCJzZXRVbnJlYWRNZXNzYWdlcyIsInVwbG9hZGluZ0ZpbGVzQnlDaGF0Iiwic2V0VXBsb2FkaW5nRmlsZXNCeUNoYXQiLCJzZWxlY3RlZEZpbGUiLCJzZXRTZWxlY3RlZEZpbGUiLCJjaGF0SWQiLCJ0eXBlIiwiaWQiLCJ1cGRhdGVVcGxvYWRpbmdGaWxlcyIsImZpbGVJZCIsImRhdGEiLCJjb25zb2xlIiwibG9nIiwicHJldiIsIm5ld1N0YXRlIiwiXyIsInJlc3RGaWxlcyIsInByb2dyZXNzIiwiZmlsZSIsInRlbXBJZCIsInNvY2tldFJlZiIsImN1cnJlbnRBY3RpdmVDaGF0UmVmIiwiZmlsZUlucHV0UmVmIiwiY3VycmVudCIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImRpc2Nvbm5lY3QiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhdXRoIiwid2l0aENyZWRlbnRpYWxzIiwidGltZW91dCIsIm9uIiwibWVzc2FnZSIsImNoYXRLZXkiLCJyb29tIiwic2VuZGVyIiwiX2lkIiwicmVjaXBpZW50IiwidXNlcklkIiwiaXNPbmxpbmUiLCJzZW5kZXJJZCIsInJvb21JZCIsImlzVHlwaW5nIiwidXNlck5hbWUiLCJtZXNzYWdlSWQiLCJtYXAiLCJtc2ciLCJpc1JlYWQiLCJleGlzdHMiLCJzb21lIiwiciIsInJlbW92ZWQiLCJmaWx0ZXIiLCJmZXRjaEluaXRpYWxEYXRhIiwidXNlcnNSZXNwb25zZSIsInJvb21zUmVzcG9uc2UiLCJQcm9taXNlIiwiYWxsIiwiZ2V0IiwiaW5pdGlhbE9ubGluZVN0YXR1cyIsImZvckVhY2giLCJlcnJvciIsImVtaXQiLCJ1bnJlYWRDb3VudHMiLCJvZmYiLCJjaGF0VHlwZSIsImhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UiLCJjaGF0IiwiaGFzQ29tcGxldGVkVXBsb2FkcyIsIk9iamVjdCIsInZhbHVlcyIsInN0YXR1cyIsImZldGNoTWVzc2FnZXMiLCJlbmRwb2ludCIsInJlc3BvbnNlIiwibGVuZ3RoIiwiY2xlYW51cEludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJoYXNDaGFuZ2VzIiwia2V5cyIsImNsZWFySW50ZXJ2YWwiLCJjb250ZW50IiwiYXR0YWNobWVudHNXaXRoSWRzIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsImZpbGVUeXBlIiwiZmlsZVR5cGVTdHJpbmciLCJzdGFydHNXaXRoIiwiYXR0YWNobWVudCIsImZpbGVuYW1lIiwibmFtZSIsImNvbnRlbnRUeXBlIiwic2l6ZSIsInVuZGVmaW5lZCIsImlzTGFyZ2VGaWxlIiwicmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJyZXNvbHZlIiwib25sb2FkIiwiYmFzZTY0ZGF0YSIsInJlc3VsdCIsImJhc2U2NENsZWFuIiwic3BsaXQiLCJwdXNoIiwidXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIiLCJ0aGVuIiwiY2F0Y2giLCJtZXNzYWdlRGF0YSIsImF0dGFjaG1lbnRzIiwicmVjaXBpZW50SWQiLCJzdWNjZXNzIiwidmFsdWUiLCJjcmVhdGVSb29tIiwiZGVzY3JpcHRpb24iLCJpc1ByaXZhdGUiLCJtZW1iZXJzIiwicG9zdCIsInVwZGF0ZVJvb20iLCJ1cGRhdGVEYXRhIiwicHV0IiwicHJldlJvb21zIiwiam9pblJvb20iLCJ0YXJnZXRVc2VySWQiLCJsZWF2ZVJvb20iLCJkZWxldGUiLCJzZXRUeXBpbmciLCJ0eXBpbmdEYXRhIiwiY2xlYXJDaGF0SGlzdG9yeSIsImJhc2U2NERhdGEiLCJieXRlQ2hhcmFjdGVycyIsImF0b2IiLCJieXRlQXJyYXlzIiwib2Zmc2V0Iiwic2xpY2UiLCJieXRlTnVtYmVycyIsIkFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJieXRlQXJyYXkiLCJVaW50OEFycmF5IiwiYmxvYiIsIkJsb2IiLCJGaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsImhlYWRlcnMiLCJvblVwbG9hZFByb2dyZXNzIiwicHJvZ3Jlc3NFdmVudCIsInBlcmNlbnRDb21wbGV0ZWQiLCJ0b3RhbCIsInJvdW5kIiwibG9hZGVkIiwic2V0VGltZW91dCIsImhhbmRsZU1hcmtBc1JlYWQiLCJmZXRjaE1vcmVNZXNzYWdlcyIsInBhZ2UiLCJkZWxldGVGb3JFdmVyeW9uZSIsInBhcmFtcyIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});