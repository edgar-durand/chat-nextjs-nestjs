"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>0,\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{},\n    deleteMessage: async ()=>false\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFilesByChat, setUploadingFilesByChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const uploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!activeChat) return {};\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        return uploadingFilesByChat[chatId] || {};\n    }, [\n        activeChat,\n        uploadingFilesByChat\n    ]);\n    const updateUploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chatId, fileId, data)=>{\n        console.log(\"Actualizando estado de archivo \".concat(fileId, \" en chat \").concat(chatId, \":\"), data);\n        setUploadingFilesByChat((prev)=>{\n            const newState = {\n                ...prev\n            };\n            // Si no existe el chat, lo creamos\n            if (!newState[chatId]) {\n                newState[chatId] = {};\n            }\n            // Si data es null, eliminamos el archivo\n            if (data === null) {\n                if (newState[chatId][fileId]) {\n                    const { [fileId]: _, ...restFiles } = newState[chatId];\n                    newState[chatId] = restFiles;\n                    console.log(\"Eliminado archivo \".concat(fileId, \" de chat \").concat(chatId));\n                }\n            } else {\n                // Actualizamos o agregamos el archivo\n                newState[chatId][fileId] = data;\n                console.log(\"Actualizado archivo \".concat(fileId, \" en chat \").concat(chatId, \" con progreso \").concat(data.progress, \"%\"));\n            }\n            return newState;\n        });\n    }, []);\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId || !activeChat) return;\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, null);\n    };\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envÃ­o de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room-\".concat(message.room);\n            } else {\n                chatKey = message.sender._id === user.id ? \"private-\".concat(message.recipient) : \"private-\".concat(message.sender._id);\n            }\n            console.log(\"Mensaje recibido:\", message, \"Chat activo:\", activeChat);\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                console.log(\"Agregando mensaje al chat activo:\", message);\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        // Escuchar eventos de eliminaciÃ³n de mensajes\n        socketRef.current.on(\"message_deleted\", (param)=>{\n            let { messageId, deleteForEveryone } = param;\n            console.log(\"Mensaje eliminado recibido:\", messageId, deleteForEveryone);\n            if (deleteForEveryone) {\n                // Si fue eliminado para todos, actualizar la UI\n                setMessages((prev)=>prev.filter((msg)=>msg._id !== messageId));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leÃ­dos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leÃ­dos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leÃ­dos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leÃ­dos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n            // Resetear el contador de mensajes no leÃ­dos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leÃ­do\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // FunciÃ³n para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leÃ­das cuando se activa un chat\n        if (chat) {\n            const chatKey = \"\".concat(chat.type, \"-\").concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Efecto para actualizar los mensajes cuando cambia el chat activo\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated) return;\n        // Resetear el estado al cambiar de chat\n        setMessages([]);\n        setIsLoadingMessages(true);\n        // Reiniciar estados de mensajes no leÃ­dos y archivos en carga\n        if (activeChat) {\n            // Limpiar mensajes no leÃ­dos\n            setUnreadMessages((prev)=>{\n                const chatKey = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n                if (prev[chatKey]) {\n                    const newState = {\n                        ...prev\n                    };\n                    delete newState[chatKey];\n                    return newState;\n                }\n                return prev;\n            });\n            // Asegurarnos de que la secciÃ³n \"Archivos en proceso\" desaparezca al cambiar de chat\n            // incluso cuando ya habÃ­a terminado la carga con 100%\n            const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n            if (chatId in uploadingFilesByChat) {\n                const hasCompletedUploads = Object.values(uploadingFilesByChat[chatId]).some((status)=>status.progress === 100);\n                if (hasCompletedUploads) {\n                    setUploadingFilesByChat((prev)=>{\n                        const newState = {\n                            ...prev\n                        };\n                        delete newState[chatId];\n                        return newState;\n                    });\n                }\n            }\n        }\n        // Solicitar mensajes al servidor\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leÃ­dos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    // Efecto para limpiar archivos completados automÃ¡ticamente\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Revisa cada 2 segundos si hay archivos que estÃ¡n al 100% que deban eliminarse\n        const cleanupInterval = setInterval(()=>{\n            setUploadingFilesByChat((prev)=>{\n                const newState = {\n                    ...prev\n                };\n                let hasChanges = false;\n                // Revisar todos los chats\n                Object.keys(newState).forEach((chatId)=>{\n                    // Revisar todos los archivos en ese chat\n                    Object.keys(newState[chatId]).forEach((fileId)=>{\n                        // Si un archivo estÃ¡ al 100%, eliminarlo\n                        if (newState[chatId][fileId].progress === 100) {\n                            delete newState[chatId][fileId];\n                            hasChanges = true;\n                        }\n                    });\n                    // Si el chat ya no tiene archivos, eliminar el chat\n                    if (Object.keys(newState[chatId]).length === 0) {\n                        delete newState[chatId];\n                        hasChanges = true;\n                    }\n                });\n                return hasChanges ? newState : prev;\n            });\n        }, 2000);\n        return ()=>clearInterval(cleanupInterval);\n    }, []);\n    const sendMessage = async (content, selectedFile)=>{\n        if (!socketRef.current || !activeChat) return;\n        try {\n            // Generar tempIds para los archivos y convertirlos a FileAttachment\n            const attachmentsWithIds = [];\n            if (selectedFile) {\n                const tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n                // Determinar tipo de archivo de forma segura\n                let fileType = \"document\";\n                const fileTypeString = selectedFile.type || \"\"; // Usar string vacÃ­o si type es undefined\n                if (fileTypeString.startsWith(\"image/\")) {\n                    fileType = \"image\";\n                } else if (fileTypeString.startsWith(\"video/\")) {\n                    fileType = \"video\";\n                } else if (fileTypeString.startsWith(\"audio/\")) {\n                    fileType = \"audio\";\n                } else {\n                    fileType = \"document\";\n                }\n                // Crear objeto FileAttachment para el archivo\n                const attachment = {\n                    tempId,\n                    filename: selectedFile.name || \"archivo\",\n                    contentType: selectedFile.type || \"application/octet-stream\",\n                    fileType,\n                    size: selectedFile.size || 0\n                };\n                // Iniciar indicador de carga inmediatamente para todos los archivos\n                const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n                updateUploadingFiles(chatId, tempId, {\n                    progress: 0,\n                    error: undefined\n                });\n                // Si es un archivo grande, lo procesamos para subida en segundo plano\n                if (selectedFile.size > 5 * 1024 * 1024) {\n                    attachment.isLargeFile = true;\n                    // Leer como base64 para preprocesamiento\n                    const reader = new FileReader();\n                    reader.readAsDataURL(selectedFile);\n                    await new Promise((resolve)=>{\n                        reader.onload = ()=>{\n                            var _reader_result;\n                            const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                            // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                            const base64Clean = base64data.split(\",\")[1];\n                            attachment.data = base64Clean;\n                            resolve();\n                        };\n                    });\n                    // Agregar a la lista de adjuntos\n                    attachmentsWithIds.push(attachment);\n                    // Iniciar subida en segundo plano\n                    uploadLargeFileToServer(attachment).then((fileId)=>{\n                        if (fileId) {\n                            // Actualizar el attachment con el fileId\n                            attachment.fileId = fileId;\n                            attachment.isLargeFile = true;\n                            attachment.data = undefined; // Eliminar los datos binarios\n                            // Actualizar progreso a 100%\n                            updateUploadingFiles(chatId, tempId, {\n                                progress: 100,\n                                error: undefined\n                            });\n                        }\n                    }).catch((error)=>{\n                        console.error(\"Error subiendo archivo:\", error);\n                        updateUploadingFiles(chatId, tempId, {\n                            progress: 0,\n                            error: error.message || \"Error al subir el archivo\"\n                        });\n                    });\n                } else {\n                    // Para archivos pequeÃ±os (<5MB), leerlos como base64 y enviar con el mensaje\n                    const reader = new FileReader();\n                    reader.readAsDataURL(selectedFile);\n                    await new Promise((resolve)=>{\n                        reader.onload = ()=>{\n                            var _reader_result;\n                            const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                            // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                            const base64Clean = base64data.split(\",\")[1];\n                            attachment.data = base64Clean;\n                            resolve();\n                        };\n                    });\n                    // Agregar a la lista de adjuntos\n                    attachmentsWithIds.push(attachment);\n                    // Marcar como completado tambiÃ©n para archivos pequeÃ±os\n                    updateUploadingFiles(chatId, tempId, {\n                        progress: 100,\n                        error: undefined\n                    });\n                }\n            }\n            // Preparar datos del mensaje\n            const messageData = {\n                content,\n                attachments: attachmentsWithIds,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            console.log(\"Enviando mensaje:\", messageData);\n            // Enviar el mensaje a travÃ©s del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                console.log(\"Respuesta al enviar mensaje:\", response);\n                if (!response.success) {\n                    console.error(\"Error al enviar mensaje:\", response.error);\n                }\n            });\n            // Limpiar formulario despuÃ©s de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar mensaje:\", error);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // ImplementaciÃ³n de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, {\n            progress: 0,\n            error: undefined\n        });\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya estÃ¡ subido\n            updateUploadingFiles(chatId, file.tempId, {\n                progress: 100,\n                error: undefined\n            });\n        }\n    };\n    // FunciÃ³n auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: undefined\n            });\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    console.log(\"Progreso de subida para \".concat(attachment.tempId, \": \").concat(percentCompleted, \"%\"));\n                    updateUploadingFiles(chatId, attachment.tempId, {\n                        progress: percentCompleted,\n                        error: undefined\n                    });\n                    // Si el archivo ha terminado de cargarse (100%), lo eliminamos de la lista despuÃ©s de un segundo\n                    if (percentCompleted === 100) {\n                        console.log(\"Subida completada para \".concat(attachment.tempId, \", eliminando en 1 segundo\"));\n                        // Esperar un segundo para que el usuario vea que se completÃ³ y luego eliminar\n                        setTimeout(()=>{\n                            updateUploadingFiles(chatId, attachment.tempId, null);\n                        }, 1000);\n                    }\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: error.message || \"Error al subir el archivo\"\n            });\n            return null;\n        }\n    };\n    // Esta funciÃ³n se encarga de marcar un mensaje como leÃ­do\n    const handleMarkAsRead = (messageId)=>{\n        if (!socketRef.current) return;\n        socketRef.current.emit(\"mark_message_read\", {\n            messageId\n        });\n        // Actualizar el estado de mensajes localmente\n        setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                    ...msg,\n                    isRead: true\n                } : msg));\n    };\n    // Esta funciÃ³n carga mÃ¡s mensajes para la paginaciÃ³n\n    const fetchMoreMessages = async (page)=>{\n        if (!activeChat || !user || !isAuthenticated) return;\n        try {\n            let endpoint = \"\";\n            if (activeChat.type === \"private\") {\n                endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id, \"?page=\").concat(page);\n            } else {\n                endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id, \"?page=\").concat(page);\n            }\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n            // AÃ±adir los mensajes anteriores al inicio del array de mensajes\n            setMessages((prev)=>[\n                    ...response.data,\n                    ...prev\n                ]);\n            return response.data.length;\n        } catch (error) {\n            console.error(\"Error al cargar m\\xe1s mensajes:\", error);\n            return 0;\n        }\n    };\n    const deleteMessage = async (messageId, deleteForEveryone)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/message/\").concat(messageId), {\n                params: {\n                    deleteForEveryone\n                }\n            });\n            if (response.data.success) {\n                // Eliminar el mensaje del estado local\n                setMessages((prev)=>prev.filter((msg)=>msg._id !== messageId));\n                return true;\n            }\n            return false;\n        } catch (error) {\n            console.error(\"Error al eliminar mensaje:\", error);\n            return false;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            markAsRead: handleMarkAsRead,\n            startTyping: ()=>setTyping(true),\n            stopTyping: ()=>setTyping(false),\n            loadMoreMessages: fetchMoreMessages,\n            retryFileUpload,\n            cancelFileUpload,\n            deleteMessage\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 883,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"WkNbpqBjcVKNxVZQELMlCtrIcQo=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLENBQUM4RyxPQUFPLEVBQUU7Z0JBQ3pCLHVDQUF1QztnQkFDdkNqSSxZQUFZc0IsQ0FBQUEsT0FBUUEsS0FBSzJDLE1BQU0sQ0FBQ04sQ0FBQUEsTUFBT0EsSUFBSVYsR0FBRyxLQUFLUTtnQkFDbkQsT0FBTztZQUNUO1lBQ0EsT0FBTztRQUNULEVBQUUsT0FBT2tCLE9BQU87WUFDZHZELFFBQVF1RCxLQUFLLENBQUMsOEJBQThCQTtZQUM1QyxPQUFPO1FBQ1Q7SUFDRjtJQUVBLHFCQUNFLDhEQUFDcEcsWUFBWTBNLFFBQVE7UUFBQy9DLE9BQU87WUFDM0IxSjtZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQyxlQUFlOEY7WUFDZjdGO1lBQ0FDLFlBQVl5TDtZQUNaeEwsYUFBYSxJQUFNMkosVUFBVTtZQUM3QjFKLFlBQVksSUFBTTBKLFVBQVU7WUFDNUJ6SixrQkFBa0J1TDtZQUNsQnRMO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBQ0dHOzs7Ozs7QUFHUCxFQUFFO0lBanlCV0Q7O1FBQ3VCdkIsaURBQU9BOzs7S0FEOUJ1QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvQ2hhdENvbnRleHQudHN4PzBiNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlTWVtbywgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4vQXV0aENvbnRleHQnO1xuXG5pbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIF9pZD86IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhdmF0YXI6IHN0cmluZztcbiAgaXNPbmxpbmU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZW51bSBGaWxlVHlwZSB7XG4gIElNQUdFID0gJ2ltYWdlJyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBET0NVTUVOVCA9ICdkb2N1bWVudCcsXG4gIEFVRElPID0gJ2F1ZGlvJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVBdHRhY2htZW50IHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgZmlsZVR5cGU6IEZpbGVUeXBlO1xuICBkYXRhPzogc3RyaW5nOyAvLyBCYXNlNjQgZW5jb2RlZCBkYXRhIHBhcmEgYXJjaGl2b3MgcGVxdWXDsW9zXG4gIHNpemU/OiBudW1iZXI7XG4gIGZpbGVJZD86IHN0cmluZzsgLy8gSUQgcGFyYSBhcmNoaXZvcyBncmFuZGVzIGFsbWFjZW5hZG9zIHBvciBzZXBhcmFkb1xuICBpc0xhcmdlRmlsZT86IGJvb2xlYW47IC8vIEluZGljYSBzaSBlbCBhcmNoaXZvIGVzdMOhIGFsbWFjZW5hZG8gcG9yIHNlcGFyYWRvXG4gIGlzQ2h1bms/OiBib29sZWFuO1xuICBvcmlnaW5hbEZpbGVuYW1lPzogc3RyaW5nO1xuICBjaHVua0luZGV4PzogbnVtYmVyO1xuICB0b3RhbENodW5rcz86IG51bWJlcjtcbiAgdGVtcElkPzogc3RyaW5nOyAvLyBJRCB0ZW1wb3JhbCBwYXJhIHNlZ3VpbWllbnRvIGRlIGNhcmdhXG59XG5cbmludGVyZmFjZSBNZXNzYWdlIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGNvbnRlbnQ/OiBzdHJpbmc7XG4gIGF0dGFjaG1lbnRzPzogRmlsZUF0dGFjaG1lbnRbXTtcbiAgc2VuZGVyOiBVc2VyO1xuICByZWNpcGllbnQ/OiBzdHJpbmc7XG4gIHJvb20/OiBzdHJpbmc7XG4gIGlzUmVhZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSb29tIHtcbiAgX2lkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGltYWdlPzogc3RyaW5nO1xuICBjcmVhdG9yOiBVc2VyO1xuICBtZW1iZXJzOiBVc2VyW107XG4gIGlzUHJpdmF0ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIHJlbW92ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ2hhdENvbnRleHRUeXBlIHtcbiAgYWN0aXZlQ2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHJvb21zOiBSb29tW107XG4gIG9ubGluZVVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcbiAgdXNlcnM6IFVzZXJbXTtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmc+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBib29sZWFuO1xuICB1bnJlYWRNZXNzYWdlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgdXBsb2FkaW5nRmlsZXM6IFJlY29yZDxzdHJpbmcsIHsgcHJvZ3Jlc3M6IG51bWJlciwgZXJyb3I/OiBzdHJpbmcgfT47XG4gIHNldEFjdGl2ZUNoYXQ6IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcsIHNlbGVjdGVkRmlsZTogRmlsZSB8IG51bGwpID0+IFByb21pc2U8dm9pZD47XG4gIG1hcmtBc1JlYWQ6IChtZXNzYWdlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc3RhcnRUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIHN0b3BUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIGxvYWRNb3JlTWVzc2FnZXM6IChwYWdlOiBudW1iZXIpID0+IFByb21pc2U8bnVtYmVyPjtcbiAgcmV0cnlGaWxlVXBsb2FkOiAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHZvaWQ7XG4gIGNhbmNlbEZpbGVVcGxvYWQ6IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4gdm9pZDtcbiAgZGVsZXRlTWVzc2FnZTogKG1lc3NhZ2VJZDogc3RyaW5nLCBkZWxldGVGb3JFdmVyeW9uZTogYm9vbGVhbikgPT4gUHJvbWlzZTxib29sZWFuPjtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZT4oe1xuICBhY3RpdmVDaGF0OiBudWxsLFxuICBtZXNzYWdlczogW10sXG4gIHJvb21zOiBbXSxcbiAgb25saW5lVXNlcnM6IHt9LFxuICB1c2VyczogW10sXG4gIHR5cGluZ1VzZXJzOiB7fSxcbiAgaXNMb2FkaW5nOiB0cnVlLFxuICBpc0xvYWRpbmdNZXNzYWdlczogZmFsc2UsXG4gIHVucmVhZE1lc3NhZ2VzOiB7fSxcbiAgdXBsb2FkaW5nRmlsZXM6IHt9LFxuICBzZXRBY3RpdmVDaGF0OiAoKSA9PiB7fSxcbiAgc2VuZE1lc3NhZ2U6IGFzeW5jICgpID0+IHt9LFxuICBtYXJrQXNSZWFkOiAoKSA9PiB7fSxcbiAgc3RhcnRUeXBpbmc6ICgpID0+IHt9LFxuICBzdG9wVHlwaW5nOiAoKSA9PiB7fSxcbiAgbG9hZE1vcmVNZXNzYWdlczogYXN5bmMgKCkgPT4gMCxcbiAgcmV0cnlGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbiAgY2FuY2VsRmlsZVVwbG9hZDogKCkgPT4ge30sXG4gIGRlbGV0ZU1lc3NhZ2U6IGFzeW5jICgpID0+IGZhbHNlLFxufSk7XG5cbmV4cG9ydCBjb25zdCB1c2VDaGF0ID0gKCkgPT4gdXNlQ29udGV4dChDaGF0Q29udGV4dCk7XG5cbmV4cG9ydCBjb25zdCBDaGF0UHJvdmlkZXI6IFJlYWN0LkZDPHsgY2hpbGRyZW46IFJlYWN0LlJlYWN0Tm9kZSB9PiA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgY29uc3QgeyB1c2VyLCBpc0F1dGhlbnRpY2F0ZWQgfSA9IHVzZUF1dGgoKTtcbiAgY29uc3QgW2FjdGl2ZUNoYXQsIHNldEFjdGl2ZUNoYXRdID0gdXNlU3RhdGU8eyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbWVzc2FnZXMsIHNldE1lc3NhZ2VzXSA9IHVzZVN0YXRlPE1lc3NhZ2VbXT4oW10pO1xuICBjb25zdCBbcm9vbXMsIHNldFJvb21zXSA9IHVzZVN0YXRlPFJvb21bXT4oW10pO1xuICBjb25zdCBbdXNlcnMsIHNldFVzZXJzXSA9IHVzZVN0YXRlPFVzZXJbXT4oW10pO1xuICBjb25zdCBbb25saW5lVXNlcnMsIHNldE9ubGluZVVzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+Pih7fSk7XG4gIGNvbnN0IFt0eXBpbmdVc2Vycywgc2V0VHlwaW5nVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZz4+KHt9KTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpO1xuICBjb25zdCBbaXNMb2FkaW5nTWVzc2FnZXMsIHNldElzTG9hZGluZ01lc3NhZ2VzXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3NvY2tldENvbm5lY3RlZCwgc2V0U29ja2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3VucmVhZE1lc3NhZ2VzLCBzZXRVbnJlYWRNZXNzYWdlc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+Pih7fSk7XG4gIGNvbnN0IFt1cGxvYWRpbmdGaWxlc0J5Q2hhdCwgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXRdID0gdXNlU3RhdGU8e1xuICAgIFtjaGF0SWQ6IHN0cmluZ106IHtcbiAgICAgIFtmaWxlSWQ6IHN0cmluZ106IHtcbiAgICAgICAgcHJvZ3Jlc3M6IG51bWJlcjtcbiAgICAgICAgZXJyb3I/OiBzdHJpbmc7XG4gICAgICB9XG4gICAgfVxuICB9Pih7fSk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIFxuICBjb25zdCB1cGxvYWRpbmdGaWxlcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCkgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgcmV0dXJuIHVwbG9hZGluZ0ZpbGVzQnlDaGF0W2NoYXRJZF0gfHwge307XG4gIH0sIFthY3RpdmVDaGF0LCB1cGxvYWRpbmdGaWxlc0J5Q2hhdF0pO1xuXG4gIGNvbnN0IHVwZGF0ZVVwbG9hZGluZ0ZpbGVzID0gdXNlQ2FsbGJhY2soKFxuICAgIGNoYXRJZDogc3RyaW5nLFxuICAgIGZpbGVJZDogc3RyaW5nLFxuICAgIGRhdGE6IHsgcHJvZ3Jlc3M6IG51bWJlcjsgZXJyb3I/OiBzdHJpbmcgfSB8IG51bGxcbiAgKSA9PiB7XG4gICAgY29uc29sZS5sb2coYEFjdHVhbGl6YW5kbyBlc3RhZG8gZGUgYXJjaGl2byAke2ZpbGVJZH0gZW4gY2hhdCAke2NoYXRJZH06YCwgZGF0YSk7XG4gICAgXG4gICAgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXQocHJldiA9PiB7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4ucHJldiB9O1xuICAgICAgXG4gICAgICAvLyBTaSBubyBleGlzdGUgZWwgY2hhdCwgbG8gY3JlYW1vc1xuICAgICAgaWYgKCFuZXdTdGF0ZVtjaGF0SWRdKSB7XG4gICAgICAgIG5ld1N0YXRlW2NoYXRJZF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2kgZGF0YSBlcyBudWxsLCBlbGltaW5hbW9zIGVsIGFyY2hpdm9cbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXdTdGF0ZVtjaGF0SWRdW2ZpbGVJZF0pIHtcbiAgICAgICAgICBjb25zdCB7IFtmaWxlSWRdOiBfLCAuLi5yZXN0RmlsZXMgfSA9IG5ld1N0YXRlW2NoYXRJZF07XG4gICAgICAgICAgbmV3U3RhdGVbY2hhdElkXSA9IHJlc3RGaWxlcztcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRWxpbWluYWRvIGFyY2hpdm8gJHtmaWxlSWR9IGRlIGNoYXQgJHtjaGF0SWR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEFjdHVhbGl6YW1vcyBvIGFncmVnYW1vcyBlbCBhcmNoaXZvXG4gICAgICAgIG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXSA9IGRhdGE7XG4gICAgICAgIGNvbnNvbGUubG9nKGBBY3R1YWxpemFkbyBhcmNoaXZvICR7ZmlsZUlkfSBlbiBjaGF0ICR7Y2hhdElkfSBjb24gcHJvZ3Jlc28gJHtkYXRhLnByb2dyZXNzfSVgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH0pO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgY2FuY2VsRmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIGlmICghZmlsZS50ZW1wSWQgfHwgIWFjdGl2ZUNoYXQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgZmlsZS50ZW1wSWQsIG51bGwpO1xuICB9O1xuXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY3VycmVudEFjdGl2ZUNoYXRSZWYgPSB1c2VSZWYoYWN0aXZlQ2hhdCk7XG4gIGNvbnN0IGZpbGVJbnB1dFJlZiA9IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsKTtcbiAgXG4gIC8vIEtlZXAgdGhlIHJlZiBpbiBzeW5jIHdpdGggdGhlIHN0YXRlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudCA9IGFjdGl2ZUNoYXQ7XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICBjb25zdCBBUElfVVJMID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX1VSTCB8fCAnaHR0cDovL2xvY2FsaG9zdDozMDAxJztcbiAgXG4gIC8vIEluaXRpYWxpemUgc29ja2V0IGNvbm5lY3Rpb24gd2hlbiBhdXRoZW50aWNhdGVkXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc0F1dGhlbnRpY2F0ZWQgfHwgIXVzZXIpIHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rva2VuJyk7XG4gICAgXG4gICAgaWYgKCF0b2tlbikgcmV0dXJuO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50ID0gaW8oQVBJX1VSTCwge1xuICAgICAgYXV0aDogeyB0b2tlbiB9LFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiB0cnVlLFxuICAgICAgLy8gQXVtZW50YXIgZWwgdGllbXBvIGRlIGVzcGVyYSBwYXJhIHBlcm1pdGlyIGVudsOtbyBkZSBhcmNoaXZvcyBncmFuZGVzXG4gICAgICB0aW1lb3V0OiA2MDAwMCAvLyBhdW1lbnRhciBlbCB0aWVtcG8gZGUgZXNwZXJhIGEgNjAgc2VndW5kb3NcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTb2NrZXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfbWVzc2FnZScsIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIFxuICAgICAgLy8gSWRlbnRpZmljYXIgbGEgY2xhdmUgZGUgY2hhdCBwYXJhIHNlZ3VpbWllbnRvIGRlIG5vdGlmaWNhY2lvbmVzXG4gICAgICBsZXQgY2hhdEtleSA9ICcnO1xuICAgICAgaWYgKG1lc3NhZ2Uucm9vbSkge1xuICAgICAgICBjaGF0S2V5ID0gYHJvb20tJHttZXNzYWdlLnJvb219YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYXRLZXkgPSBtZXNzYWdlLnNlbmRlci5faWQgPT09IHVzZXIuaWQgPyBgcHJpdmF0ZS0ke21lc3NhZ2UucmVjaXBpZW50fWAgOiBgcHJpdmF0ZS0ke21lc3NhZ2Uuc2VuZGVyLl9pZH1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zb2xlLmxvZygnTWVuc2FqZSByZWNpYmlkbzonLCBtZXNzYWdlLCAnQ2hhdCBhY3Rpdm86JywgYWN0aXZlQ2hhdCk7XG4gICAgICBcbiAgICAgIC8vIFNvbG8gYWdyZWdhciBlbCBtZW5zYWplIHNpIGVzIHJlbGV2YW50ZSBwYXJhIGVsIGNoYXQgYWN0aXZvXG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgXG4gICAgICAgICAgKChtZXNzYWdlLnNlbmRlci5faWQgPT09IGFjdGl2ZUNoYXQuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IHVzZXIuaWQpIHx8IFxuICAgICAgICAgICAobWVzc2FnZS5zZW5kZXIuX2lkID09PSB1c2VyLmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSBhY3RpdmVDaGF0LmlkKSkpIHx8XG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgbWVzc2FnZS5yb29tID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBZ3JlZ2FuZG8gbWVuc2FqZSBhbCBjaGF0IGFjdGl2bzonLCBtZXNzYWdlKTtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZV0pO1xuICAgICAgfSBcbiAgICAgIC8vIFNpIGVsIG1lbnNhamUgbm8gZXMgcGFyYSBlbCBjaGF0IGFjdGl2byB5IG5vIGZ1ZSBlbnZpYWRvIHBvciBlbCB1c3VhcmlvIGFjdHVhbCwgaW5jcmVtZW50YXIgY29udGFkb3JcbiAgICAgIGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyLl9pZCAhPT0gdXNlci5pZCAmJiBjaGF0S2V5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZXcgbWVzc2FnZSBub3RpZmljYXRpb246JywgY2hhdEtleSwgbWVzc2FnZSk7XG4gICAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIFtjaGF0S2V5XTogKHByZXZbY2hhdEtleV0gfHwgMCkgKyAxXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcl9zdGF0dXNfY2hhbmdlJywgKHsgdXNlcklkLCBpc09ubGluZSB9KSA9PiB7XG4gICAgICBzZXRPbmxpbmVVc2VycyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBpc09ubGluZSB9KSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3R5cGluZ19pbmRpY2F0b3InLCAoZGF0YTogeyB1c2VySWQ6IHN0cmluZywgdXNlck5hbWU6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4sIHJvb21JZD86IHN0cmluZywgc2VuZGVySWQ/OiBzdHJpbmcgfSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgZGF0YS5zZW5kZXJJZCA9PT0gYWN0aXZlQ2hhdC5pZCkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBkYXRhLnJvb21JZCA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICAvLyBBbG1hY2VuYXIgbm9tYnJlIGVuIGx1Z2FyIGRlIHNvbG8gbGEgYmFuZGVyYSBib29sZWFuYVxuICAgICAgICBzZXRUeXBpbmdVc2VycyhwcmV2ID0+ICh7IFxuICAgICAgICAgIC4uLnByZXYsIFxuICAgICAgICAgIFtkYXRhLnVzZXJJZF06IGRhdGEuaXNUeXBpbmcgPyBkYXRhLnVzZXJOYW1lIDogZmFsc2UgXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbWVzc2FnZV9yZWFkJywgKHsgbWVzc2FnZUlkIH0pID0+IHtcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgbmV3IHJvb20gY3JlYXRpb25zXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19yb29tJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgcm9vbSByZWNlaXZlZDonLCByb29tKTtcbiAgICAgIHNldFJvb21zKHByZXYgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm9vbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LnNvbWUociA9PiByLl9pZCA9PT0gcm9vbS5faWQpO1xuICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcHJldjtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCByb29tXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSByb29tIHVwZGF0ZXMgKG1lbWJlcnMgYWRkZWQvcmVtb3ZlZClcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigncm9vbV91cGRhdGVkJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdSb29tIHVwZGF0ZWQ6Jywgcm9vbSk7XG4gICAgICBpZiAocm9vbS5yZW1vdmVkKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vbSB3YXMgcmVtb3ZlZCBmb3IgdGhpcyB1c2VyLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYuZmlsdGVyKHIgPT4gci5faWQgIT09IHJvb20uX2lkKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBhY3RpdmUgY2hhdCBpcyB0aGlzIHJvb20sIGNsZWFyIGl0XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGFjdGl2ZUNoYXQuaWQgPT09IHJvb20uX2lkKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ2hhdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5tYXAociA9PiByLl9pZCA9PT0gcm9vbS5faWQgPyByb29tIDogcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIC8vIEVzY3VjaGFyIGV2ZW50b3MgZGUgZWxpbWluYWNpw7NuIGRlIG1lbnNhamVzXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ21lc3NhZ2VfZGVsZXRlZCcsICh7IG1lc3NhZ2VJZCwgZGVsZXRlRm9yRXZlcnlvbmUgfSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ01lbnNhamUgZWxpbWluYWRvIHJlY2liaWRvOicsIG1lc3NhZ2VJZCwgZGVsZXRlRm9yRXZlcnlvbmUpO1xuICAgICAgaWYgKGRlbGV0ZUZvckV2ZXJ5b25lKSB7XG4gICAgICAgIC8vIFNpIGZ1ZSBlbGltaW5hZG8gcGFyYSB0b2RvcywgYWN0dWFsaXphciBsYSBVSVxuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKG1zZyA9PiBtc2cuX2lkICE9PSBtZXNzYWdlSWQpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH07XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIHVzZXIsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIExvYWQgaW5pdGlhbCBkYXRhOiB1c2VycyBhbmQgcm9vbXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmV0Y2hJbml0aWFsRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IFt1c2Vyc1Jlc3BvbnNlLCByb29tc1Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vdXNlcnNgKSxcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vcm9vbXMvbXlgKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIHNldFVzZXJzKHVzZXJzUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHNldFJvb21zKHJvb21zUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbmxpbmUgc3RhdHVzXG4gICAgICAgIGNvbnN0IGluaXRpYWxPbmxpbmVTdGF0dXM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gICAgICAgIHVzZXJzUmVzcG9uc2UuZGF0YS5mb3JFYWNoKCh1c2VyOiBVc2VyKSA9PiB7XG4gICAgICAgICAgaW5pdGlhbE9ubGluZVN0YXR1c1t1c2VyLl9pZCFdID0gdXNlci5pc09ubGluZSB8fCBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE9ubGluZVVzZXJzKGluaXRpYWxPbmxpbmVTdGF0dXMpO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGluaXRpYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hJbml0aWFsRGF0YSgpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBDdWFuZG8gc2UgaW5pY2lhIGVsIHNvY2tldCB5IHNlIGNvbmVjdGEsIHNvbGljaXRhbW9zIGVsIGVzdGFkbyBhY3R1YWwgZGUgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzb2NrZXRDb25uZWN0ZWQgJiYgc29ja2V0UmVmLmN1cnJlbnQgJiYgdXNlcikge1xuICAgICAgLy8gU29saWNpdGFyIG1lbnNhamVzIG5vIGxlw61kb3MgYWwgc2Vydmlkb3JcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2dldF91bnJlYWRfbWVzc2FnZXMnKTtcbiAgICAgIFxuICAgICAgLy8gRXNjdWNoYXIgbGEgcmVzcHVlc3RhIGNvbiBlbCByZWN1ZW50byBkZSBtZW5zYWplcyBubyBsZcOtZG9zXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndW5yZWFkX21lc3NhZ2VzX2NvdW50JywgKHVucmVhZENvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgdW5yZWFkIGNvdW50czonLCB1bnJlYWRDb3VudHMpO1xuICAgICAgICBzZXRVbnJlYWRNZXNzYWdlcyh1bnJlYWRDb3VudHMpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5vZmYoJ3VucmVhZF9tZXNzYWdlc19jb3VudCcpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtzb2NrZXRDb25uZWN0ZWQsIHVzZXJdKTtcblxuICAvLyBBc2VndXJhcnNlIGRlIHF1ZSBsb3MgbWVuc2FqZXMgc2UgbWFycXVlbiBjb21vIGxlw61kb3MgY3VhbmRvIHNlIGFicmUgdW4gY2hhdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmVDaGF0ICYmIHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDcmVhciB1bmEgY2xhdmUgcGFyYSBlbCBjaGF0IGFjdHVhbFxuICAgICAgY29uc3QgY2hhdEtleSA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0ZWFyIGVsIGNvbnRhZG9yIGRlIG1lbnNhamVzIG5vIGxlw61kb3MgcGFyYSBlc3RlIGNoYXRcbiAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2NoYXRLZXldOiAwXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmaWNhciBhbCBzZXJ2aWRvciBxdWUgbG9zIG1lbnNhamVzIHNlIGhhbiBsZcOtZG9cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ21hcmtfbWVzc2FnZXNfcmVhZCcsIHtcbiAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkLFxuICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICAvLyBGdW5jacOzbiBwYXJhIG1hbmVqYXIgZWwgY2FtYmlvIGRlIGNoYXQgYWN0aXZvXG4gIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UgPSAoY2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGwpID0+IHtcbiAgICAvLyBMaW1waWFyIGxhcyBub3RpZmljYWNpb25lcyBubyBsZcOtZGFzIGN1YW5kbyBzZSBhY3RpdmEgdW4gY2hhdFxuICAgIGlmIChjaGF0KSB7XG4gICAgICBjb25zdCBjaGF0S2V5ID0gYCR7Y2hhdC50eXBlfS0ke2NoYXQuaWR9YDtcbiAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2NoYXRLZXldOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIHNldEFjdGl2ZUNoYXQoY2hhdCk7XG4gIH07XG5cbiAgLy8gRWZlY3RvIHBhcmEgYWN0dWFsaXphciBsb3MgbWVuc2FqZXMgY3VhbmRvIGNhbWJpYSBlbCBjaGF0IGFjdGl2b1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVzZXRlYXIgZWwgZXN0YWRvIGFsIGNhbWJpYXIgZGUgY2hhdFxuICAgIHNldE1lc3NhZ2VzKFtdKTtcbiAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyh0cnVlKTtcbiAgICBcbiAgICAvLyBSZWluaWNpYXIgZXN0YWRvcyBkZSBtZW5zYWplcyBubyBsZcOtZG9zIHkgYXJjaGl2b3MgZW4gY2FyZ2FcbiAgICBpZiAoYWN0aXZlQ2hhdCkge1xuICAgICAgLy8gTGltcGlhciBtZW5zYWplcyBubyBsZcOtZG9zXG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgY2hhdEtleSA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgIGlmIChwcmV2W2NoYXRLZXldKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnByZXYgfTtcbiAgICAgICAgICBkZWxldGUgbmV3U3RhdGVbY2hhdEtleV07XG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFzZWd1cmFybm9zIGRlIHF1ZSBsYSBzZWNjacOzbiBcIkFyY2hpdm9zIGVuIHByb2Nlc29cIiBkZXNhcGFyZXpjYSBhbCBjYW1iaWFyIGRlIGNoYXRcbiAgICAgIC8vIGluY2x1c28gY3VhbmRvIHlhIGhhYsOtYSB0ZXJtaW5hZG8gbGEgY2FyZ2EgY29uIDEwMCVcbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICBpZiAoY2hhdElkIGluIHVwbG9hZGluZ0ZpbGVzQnlDaGF0KSB7XG4gICAgICAgIGNvbnN0IGhhc0NvbXBsZXRlZFVwbG9hZHMgPSBPYmplY3QudmFsdWVzKHVwbG9hZGluZ0ZpbGVzQnlDaGF0W2NoYXRJZF0pXG4gICAgICAgICAgLnNvbWUoc3RhdHVzID0+IHN0YXR1cy5wcm9ncmVzcyA9PT0gMTAwKTtcbiAgICAgICAgICBcbiAgICAgICAgaWYgKGhhc0NvbXBsZXRlZFVwbG9hZHMpIHtcbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gey4uLnByZXZ9O1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2NoYXRJZF07XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2xpY2l0YXIgbWVuc2FqZXMgYWwgc2Vydmlkb3JcbiAgICBjb25zdCBmZXRjaE1lc3NhZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGVuZHBvaW50ID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKb2luIHVzZXIgcm9vbSBmb3IgZGlyZWN0IG1lc3NhZ2VzXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgdXNlcklkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvcm9vbS8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKb2luIHJvb21cbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGVuZHBvaW50KTtcbiAgICAgICAgc2V0TWVzc2FnZXMocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJjYXIgbG9zIG1lbnNhamVzIGNvbW8gbGXDrWRvcyBlbiBlbCBzZXJ2aWRvclxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ21hcmtfbWVzc2FnZXNfcmVhZCcsIHtcbiAgICAgICAgICAgIGNoYXRUeXBlOiBhY3RpdmVDaGF0LnR5cGUsXG4gICAgICAgICAgICBjaGF0SWQ6IGFjdGl2ZUNoYXQuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWVzc2FnZXM6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nTWVzc2FnZXMoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hNZXNzYWdlcygpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCAtIGxlYXZlIHJvb21zXG4gICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncm9vbScpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2xlYXZlX3Jvb20nLCB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYWN0aXZlQ2hhdCwgdXNlciwgaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBFZmVjdG8gcGFyYSBsaW1waWFyIGFyY2hpdm9zIGNvbXBsZXRhZG9zIGF1dG9tw6F0aWNhbWVudGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBSZXZpc2EgY2FkYSAyIHNlZ3VuZG9zIHNpIGhheSBhcmNoaXZvcyBxdWUgZXN0w6FuIGFsIDEwMCUgcXVlIGRlYmFuIGVsaW1pbmFyc2VcbiAgICBjb25zdCBjbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7Li4ucHJldn07XG4gICAgICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZpc2FyIHRvZG9zIGxvcyBjaGF0c1xuICAgICAgICBPYmplY3Qua2V5cyhuZXdTdGF0ZSkuZm9yRWFjaChjaGF0SWQgPT4ge1xuICAgICAgICAgIC8vIFJldmlzYXIgdG9kb3MgbG9zIGFyY2hpdm9zIGVuIGVzZSBjaGF0XG4gICAgICAgICAgT2JqZWN0LmtleXMobmV3U3RhdGVbY2hhdElkXSkuZm9yRWFjaChmaWxlSWQgPT4ge1xuICAgICAgICAgICAgLy8gU2kgdW4gYXJjaGl2byBlc3TDoSBhbCAxMDAlLCBlbGltaW5hcmxvXG4gICAgICAgICAgICBpZiAobmV3U3RhdGVbY2hhdElkXVtmaWxlSWRdLnByb2dyZXNzID09PSAxMDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXTtcbiAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2kgZWwgY2hhdCB5YSBubyB0aWVuZSBhcmNoaXZvcywgZWxpbWluYXIgZWwgY2hhdFxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZVtjaGF0SWRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdO1xuICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VzID8gbmV3U3RhdGUgOiBwcmV2O1xuICAgICAgfSk7XG4gICAgfSwgMjAwMCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoY2xlYW51cEludGVydmFsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgc2VsZWN0ZWRGaWxlOiBGaWxlIHwgbnVsbCkgPT4ge1xuICAgIGlmICghc29ja2V0UmVmLmN1cnJlbnQgfHwgIWFjdGl2ZUNoYXQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gR2VuZXJhciB0ZW1wSWRzIHBhcmEgbG9zIGFyY2hpdm9zIHkgY29udmVydGlybG9zIGEgRmlsZUF0dGFjaG1lbnRcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzV2l0aElkczogRmlsZUF0dGFjaG1lbnRbXSA9IFtdO1xuICAgICAgXG4gICAgICBpZiAoc2VsZWN0ZWRGaWxlKSB7XG4gICAgICAgIGNvbnN0IHRlbXBJZCA9IGB0ZW1wLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YDtcbiAgICAgICAgXG4gICAgICAgIC8vIERldGVybWluYXIgdGlwbyBkZSBhcmNoaXZvIGRlIGZvcm1hIHNlZ3VyYVxuICAgICAgICBsZXQgZmlsZVR5cGUgPSBGaWxlVHlwZS5ET0NVTUVOVDtcbiAgICAgICAgY29uc3QgZmlsZVR5cGVTdHJpbmcgPSBzZWxlY3RlZEZpbGUudHlwZSB8fCAnJzsgLy8gVXNhciBzdHJpbmcgdmFjw61vIHNpIHR5cGUgZXMgdW5kZWZpbmVkXG4gICAgICAgIGlmIChmaWxlVHlwZVN0cmluZy5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuSU1BR0U7XG4gICAgICAgIH0gZWxzZSBpZiAoZmlsZVR5cGVTdHJpbmcuc3RhcnRzV2l0aCgndmlkZW8vJykpIHtcbiAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLlZJREVPO1xuICAgICAgICB9IGVsc2UgaWYgKGZpbGVUeXBlU3RyaW5nLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5BVURJTztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLkRPQ1VNRU5UO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBDcmVhciBvYmpldG8gRmlsZUF0dGFjaG1lbnQgcGFyYSBlbCBhcmNoaXZvXG4gICAgICAgIGNvbnN0IGF0dGFjaG1lbnQ6IEZpbGVBdHRhY2htZW50ID0ge1xuICAgICAgICAgIHRlbXBJZCxcbiAgICAgICAgICBmaWxlbmFtZTogc2VsZWN0ZWRGaWxlLm5hbWUgfHwgJ2FyY2hpdm8nLFxuICAgICAgICAgIGNvbnRlbnRUeXBlOiBzZWxlY3RlZEZpbGUudHlwZSB8fCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyxcbiAgICAgICAgICBmaWxlVHlwZSxcbiAgICAgICAgICBzaXplOiBzZWxlY3RlZEZpbGUuc2l6ZSB8fCAwXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvLyBJbmljaWFyIGluZGljYWRvciBkZSBjYXJnYSBpbm1lZGlhdGFtZW50ZSBwYXJhIHRvZG9zIGxvcyBhcmNoaXZvc1xuICAgICAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0Py50eXBlfS0ke2FjdGl2ZUNoYXQ/LmlkfWA7XG4gICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIHRlbXBJZCwgeyBwcm9ncmVzczogMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNpIGVzIHVuIGFyY2hpdm8gZ3JhbmRlLCBsbyBwcm9jZXNhbW9zIHBhcmEgc3ViaWRhIGVuIHNlZ3VuZG8gcGxhbm9cbiAgICAgICAgaWYgKHNlbGVjdGVkRmlsZS5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSB7IC8vIE3DoXMgZGUgNU1CXG4gICAgICAgICAgYXR0YWNobWVudC5pc0xhcmdlRmlsZSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTGVlciBjb21vIGJhc2U2NCBwYXJhIHByZXByb2Nlc2FtaWVudG9cbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKHNlbGVjdGVkRmlsZSk7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAvLyBRdWl0YXIgZWwgcHJlZmlqbyAoZWouIFwiZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCxcIilcbiAgICAgICAgICAgICAgY29uc3QgYmFzZTY0Q2xlYW4gPSBiYXNlNjRkYXRhLnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IGJhc2U2NENsZWFuO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFncmVnYXIgYSBsYSBsaXN0YSBkZSBhZGp1bnRvc1xuICAgICAgICAgIGF0dGFjaG1lbnRzV2l0aElkcy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEluaWNpYXIgc3ViaWRhIGVuIHNlZ3VuZG8gcGxhbm9cbiAgICAgICAgICB1cGxvYWRMYXJnZUZpbGVUb1NlcnZlcihhdHRhY2htZW50KS50aGVuKGZpbGVJZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmlsZUlkKSB7XG4gICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgZWwgYXR0YWNobWVudCBjb24gZWwgZmlsZUlkXG4gICAgICAgICAgICAgIGF0dGFjaG1lbnQuZmlsZUlkID0gZmlsZUlkO1xuICAgICAgICAgICAgICBhdHRhY2htZW50LmlzTGFyZ2VGaWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gdW5kZWZpbmVkOyAvLyBFbGltaW5hciBsb3MgZGF0b3MgYmluYXJpb3NcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc28gYSAxMDAlXG4gICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgdGVtcElkLCB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3ViaWVuZG8gYXJjaGl2bzonLCBlcnJvcik7XG4gICAgICAgICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQsIHRlbXBJZCwgeyBwcm9ncmVzczogMCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIGFsIHN1YmlyIGVsIGFyY2hpdm8nIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcmEgYXJjaGl2b3MgcGVxdWXDsW9zICg8NU1CKSwgbGVlcmxvcyBjb21vIGJhc2U2NCB5IGVudmlhciBjb24gZWwgbWVuc2FqZVxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoc2VsZWN0ZWRGaWxlKTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgYmFzZTY0ZGF0YSA9IHJlYWRlci5yZXN1bHQ/LnRvU3RyaW5nKCkgfHwgJyc7XG4gICAgICAgICAgICAgIC8vIFF1aXRhciBlbCBwcmVmaWpvIChlai4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKVxuICAgICAgICAgICAgICBjb25zdCBiYXNlNjRDbGVhbiA9IGJhc2U2NGRhdGEuc3BsaXQoJywnKVsxXTtcbiAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gYmFzZTY0Q2xlYW47XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gQWdyZWdhciBhIGxhIGxpc3RhIGRlIGFkanVudG9zXG4gICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTWFyY2FyIGNvbW8gY29tcGxldGFkbyB0YW1iacOpbiBwYXJhIGFyY2hpdm9zIHBlcXVlw7Fvc1xuICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgdGVtcElkLCB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUHJlcGFyYXIgZGF0b3MgZGVsIG1lbnNhamVcbiAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICBjb250ZW50LFxuICAgICAgICBhdHRhY2htZW50czogYXR0YWNobWVudHNXaXRoSWRzLFxuICAgICAgICAuLi4oYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgPyB7IHJlY2lwaWVudElkOiBhY3RpdmVDaGF0LmlkIH0gOiB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KSxcbiAgICAgIH07XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdFbnZpYW5kbyBtZW5zYWplOicsIG1lc3NhZ2VEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gRW52aWFyIGVsIG1lbnNhamUgYSB0cmF2w6lzIGRlbCBzb2NrZXRcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ3NlbmRfbWVzc2FnZScsIG1lc3NhZ2VEYXRhLCAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVzcHVlc3RhIGFsIGVudmlhciBtZW5zYWplOicsIHJlc3BvbnNlKTtcbiAgICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgZW52aWFyIG1lbnNhamU6JywgcmVzcG9uc2UuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTGltcGlhciBmb3JtdWxhcmlvIGRlc3B1w6lzIGRlIGVudmlhclxuICAgICAgaWYgKGZpbGVJbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgIGZpbGVJbnB1dFJlZi5jdXJyZW50LnZhbHVlID0gJyc7XG4gICAgICB9XG4gICAgICBzZXRTZWxlY3RlZEZpbGUobnVsbCk7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgcHJvY2VzYXIgbWVuc2FqZTonLCBlcnJvcik7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgY3JlYXRlUm9vbSA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uID0gJycsIGlzUHJpdmF0ZSA9IGZhbHNlLCBtZW1iZXJzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tc2AsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGlzUHJpdmF0ZSxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBObyBuZWVkIHRvIG1hbnVhbGx5IGFkZCB0byByb29tcyBhcnJheSwgdGhlIHNvY2tldCBldmVudCB3aWxsIGhhbmRsZSBpdFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgdXBkYXRlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXBkYXRlRGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZzsgaW1hZ2U/OiBzdHJpbmc7IGlzUHJpdmF0ZT86IGJvb2xlYW4gfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnB1dChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH1gLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsb2NhbCBzdGF0ZSB0byBpbW1lZGlhdGVseSByZWZsZWN0IGNoYW5nZXNcbiAgICAgIHNldFJvb21zKHByZXZSb29tcyA9PiBcbiAgICAgICAgcHJldlJvb21zLm1hcChyb29tID0+IFxuICAgICAgICAgIHJvb20uX2lkID09PSByb29tSWQgPyB7IC4uLnJvb20sIC4uLmRhdGEgfSA6IHJvb21cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgam9pblJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlciAmJiAhdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHVzZXJJZCBpcyBwcm92aWRlZCwgdXNlIGl0IChmb3IgYWRtaW4gYWRkaW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWpvaW5pbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBqb2luaW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgbGVhdmVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIHJlbW92aW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWxlYXZpbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt0YXJnZXRVc2VySWR9YCk7XG4gICAgICAvLyBSb29tIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgYnkgc29ja2V0IGV2ZW50XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBzZXRUeXBpbmcgPSAoaXNUeXBpbmc6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIXNvY2tldFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdHlwaW5nRGF0YSA9IHtcbiAgICAgIGlzVHlwaW5nLFxuICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgfTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCd0eXBpbmcnLCB0eXBpbmdEYXRhKTtcbiAgfTtcbiAgXG4gIGNvbnN0IGNsZWFyQ2hhdEhpc3RvcnkgPSBhc3luYyAocmVjaXBpZW50SWQ6IHN0cmluZykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmRlbGV0ZShgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHtyZWNpcGllbnRJZH1gKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIG1lc3NhZ2U6ICdDaGF0IGhpc3RvcnkgY2xlYXJlZCBzdWNjZXNzZnVsbHknIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNsZWFyaW5nIGNoYXQgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgbWVzc2FnZTogJ0ZhaWxlZCB0byBjbGVhciBjaGF0IGhpc3RvcnknIH07XG4gICAgfVxuICB9O1xuICBcbiAgLy8gSW1wbGVtZW50YWNpw7NuIGRlIHJldHJ5RmlsZVVwbG9hZFxuICBjb25zdCByZXRyeUZpbGVVcGxvYWQgPSAoZmlsZTogRmlsZUF0dGFjaG1lbnQpID0+IHtcbiAgICBpZiAoIWZpbGUudGVtcElkKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVzZXQgcHJvZ3Jlc3NcbiAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0Py50eXBlfS0ke2FjdGl2ZUNoYXQ/LmlkfWA7XG4gICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgZmlsZS50ZW1wSWQhLCB7IHByb2dyZXNzOiAwLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgIFxuICAgIC8vIFByZXBhcmUgZm9yIHJlLXVwbG9hZFxuICAgIGlmIChmaWxlLmRhdGEpIHtcbiAgICAgIC8vIEVzIHVuIGFyY2hpdm8geWEgY29udmVydGlkbyBhIGJhc2U2NFxuICAgICAgdXBsb2FkTGFyZ2VGaWxlVG9TZXJ2ZXIoZmlsZSk7XG4gICAgfSBlbHNlIGlmIChmaWxlLmZpbGVJZCkge1xuICAgICAgLy8gUmVtb3ZlciBlbCBlcnJvciBwZXJvIG1hbnRlbmVyIGVsIHByb2dyZXNvIGNvbW8gY29tcGxldGFkb1xuICAgICAgLy8geWEgcXVlIGVsIGFyY2hpdm8geWEgZXN0w6Egc3ViaWRvXG4gICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQhLCBmaWxlLnRlbXBJZCEsIHsgcHJvZ3Jlc3M6IDEwMCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBGdW5jacOzbiBhdXhpbGlhciBwYXJhIHN1YmlyIHVuIGFyY2hpdm8gZ3JhbmRlIGRpcmVjdGFtZW50ZSBhbCBzZXJ2aWRvclxuICBjb25zdCB1cGxvYWRMYXJnZUZpbGVUb1NlcnZlciA9IGFzeW5jIChhdHRhY2htZW50OiBGaWxlQXR0YWNobWVudCk6IFByb21pc2U8c3RyaW5nIHwgbnVsbD4gPT4ge1xuICAgIGlmICghYXR0YWNobWVudC50ZW1wSWQpIHtcbiAgICAgIGF0dGFjaG1lbnQudGVtcElkID0gYHRlbXAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gO1xuICAgIH1cbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gQ29udmVydGlyIGRhdG9zIGJhc2U2NCBhIEJsb2IgcGFyYSBzdWJpclxuICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGF0dGFjaG1lbnQuZGF0YSB8fCAnJztcbiAgICAgIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihiYXNlNjREYXRhKTtcbiAgICAgIGNvbnN0IGJ5dGVBcnJheXMgPSBbXTtcbiAgICAgIFxuICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgYnl0ZUNoYXJhY3RlcnMubGVuZ3RoOyBvZmZzZXQgKz0gNTEyKSB7XG4gICAgICAgIGNvbnN0IHNsaWNlID0gYnl0ZUNoYXJhY3RlcnMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyA1MTIpO1xuICAgICAgICBjb25zdCBieXRlTnVtYmVycyA9IG5ldyBBcnJheShzbGljZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYnl0ZU51bWJlcnNbaV0gPSBzbGljZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ5dGVOdW1iZXJzKTtcbiAgICAgICAgYnl0ZUFycmF5cy5wdXNoKGJ5dGVBcnJheSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IGJsb2IgPSBuZXcgQmxvYihieXRlQXJyYXlzLCB7IHR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUgfSk7XG4gICAgICBjb25zdCBmaWxlID0gbmV3IEZpbGUoW2Jsb2JdLCBhdHRhY2htZW50LmZpbGVuYW1lLCB7IHR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUgfSk7XG4gICAgICBcbiAgICAgIC8vIENyZWFyIEZvcm1EYXRhIHBhcmEgbGEgc3ViaWRhXG4gICAgICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgZmlsZSk7XG4gICAgICBcbiAgICAgIC8vIEluaWNpYXIgbGEgY2FyZ2EgeSBhY3R1YWxpemFyIGVsIGVzdGFkb1xuICAgICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdD8udHlwZX0tJHthY3RpdmVDaGF0Py5pZH1gO1xuICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgYXR0YWNobWVudC50ZW1wSWQhLCB7IHByb2dyZXNzOiAwLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgXG4gICAgICAvLyBSZWFsaXphciBsYSBzdWJpZGEgY29uIHNlZ3VpbWllbnRvIGRlIHByb2dyZXNvXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vZmlsZS1zdG9yYWdlL3VwbG9hZGAsIGZvcm1EYXRhLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgIH0sXG4gICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICAgICAgY29uc3QgcGVyY2VudENvbXBsZXRlZCA9IHByb2dyZXNzRXZlbnQudG90YWwgXG4gICAgICAgICAgICA/IE1hdGgucm91bmQoKHByb2dyZXNzRXZlbnQubG9hZGVkICogMTAwKSAvIHByb2dyZXNzRXZlbnQudG90YWwpXG4gICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICBcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvZ3Jlc28gZGUgc3ViaWRhIHBhcmEgJHthdHRhY2htZW50LnRlbXBJZH06ICR7cGVyY2VudENvbXBsZXRlZH0lYCk7XG4gICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgYXR0YWNobWVudC50ZW1wSWQhLCB7IHByb2dyZXNzOiBwZXJjZW50Q29tcGxldGVkLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIFNpIGVsIGFyY2hpdm8gaGEgdGVybWluYWRvIGRlIGNhcmdhcnNlICgxMDAlKSwgbG8gZWxpbWluYW1vcyBkZSBsYSBsaXN0YSBkZXNwdcOpcyBkZSB1biBzZWd1bmRvXG4gICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZWQgPT09IDEwMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFN1YmlkYSBjb21wbGV0YWRhIHBhcmEgJHthdHRhY2htZW50LnRlbXBJZH0sIGVsaW1pbmFuZG8gZW4gMSBzZWd1bmRvYCk7XG4gICAgICAgICAgICAvLyBFc3BlcmFyIHVuIHNlZ3VuZG8gcGFyYSBxdWUgZWwgdXN1YXJpbyB2ZWEgcXVlIHNlIGNvbXBsZXTDsyB5IGx1ZWdvIGVsaW1pbmFyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgYXR0YWNobWVudC50ZW1wSWQhLCBudWxsKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhICYmIHJlc3BvbnNlLmRhdGEuZmlsZUlkKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmZpbGVJZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHN1YmlyIGFyY2hpdm86JywgZXJyb3IpO1xuICAgICAgY29uc3QgY2hhdElkID0gYCR7YWN0aXZlQ2hhdD8udHlwZX0tJHthY3RpdmVDaGF0Py5pZH1gO1xuICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkISwgYXR0YWNobWVudC50ZW1wSWQhLCB7IFxuICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBzdWJpciBlbCBhcmNoaXZvJ1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBFc3RhIGZ1bmNpw7NuIHNlIGVuY2FyZ2EgZGUgbWFyY2FyIHVuIG1lbnNhamUgY29tbyBsZcOtZG9cbiAgY29uc3QgaGFuZGxlTWFya0FzUmVhZCA9IChtZXNzYWdlSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghc29ja2V0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdtYXJrX21lc3NhZ2VfcmVhZCcsIHsgbWVzc2FnZUlkIH0pO1xuICAgIFxuICAgIC8vIEFjdHVhbGl6YXIgZWwgZXN0YWRvIGRlIG1lbnNhamVzIGxvY2FsbWVudGVcbiAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFxuICAgICAgcHJldi5tYXAobXNnID0+IFxuICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgIClcbiAgICApO1xuICB9O1xuICBcbiAgLy8gRXN0YSBmdW5jacOzbiBjYXJnYSBtw6FzIG1lbnNhamVzIHBhcmEgbGEgcGFnaW5hY2nDs25cbiAgY29uc3QgZmV0Y2hNb3JlTWVzc2FnZXMgPSBhc3luYyAocGFnZTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICF1c2VyIHx8ICFpc0F1dGhlbnRpY2F0ZWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbGV0IGVuZHBvaW50ID0gJyc7XG4gICAgICBcbiAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9P3BhZ2U9JHtwYWdlfWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL3Jvb20vJHthY3RpdmVDaGF0LmlkfT9wYWdlPSR7cGFnZX1gO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChlbmRwb2ludCk7XG4gICAgICBcbiAgICAgIC8vIEHDsWFkaXIgbG9zIG1lbnNhamVzIGFudGVyaW9yZXMgYWwgaW5pY2lvIGRlbCBhcnJheSBkZSBtZW5zYWplc1xuICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucmVzcG9uc2UuZGF0YSwgLi4ucHJldl0pO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5sZW5ndGg7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGNhcmdhciBtw6FzIG1lbnNhamVzOicsIGVycm9yKTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGRlbGV0ZU1lc3NhZ2UgPSBhc3luYyAobWVzc2FnZUlkOiBzdHJpbmcsIGRlbGV0ZUZvckV2ZXJ5b25lOiBib29sZWFuKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L2NoYXRzL21lc3NhZ2UvJHttZXNzYWdlSWR9YCwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBkZWxldGVGb3JFdmVyeW9uZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgIC8vIEVsaW1pbmFyIGVsIG1lbnNhamUgZGVsIGVzdGFkbyBsb2NhbFxuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IHByZXYuZmlsdGVyKG1zZyA9PiBtc2cuX2lkICE9PSBtZXNzYWdlSWQpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIGVsaW1pbmFyIG1lbnNhamU6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBhY3RpdmVDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICByb29tcyxcbiAgICAgIG9ubGluZVVzZXJzLFxuICAgICAgdXNlcnMsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZ01lc3NhZ2VzLFxuICAgICAgdW5yZWFkTWVzc2FnZXMsXG4gICAgICB1cGxvYWRpbmdGaWxlcyxcbiAgICAgIHNldEFjdGl2ZUNoYXQ6IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UsXG4gICAgICBzZW5kTWVzc2FnZSxcbiAgICAgIG1hcmtBc1JlYWQ6IGhhbmRsZU1hcmtBc1JlYWQsXG4gICAgICBzdGFydFR5cGluZzogKCkgPT4gc2V0VHlwaW5nKHRydWUpLFxuICAgICAgc3RvcFR5cGluZzogKCkgPT4gc2V0VHlwaW5nKGZhbHNlKSxcbiAgICAgIGxvYWRNb3JlTWVzc2FnZXM6IGZldGNoTW9yZU1lc3NhZ2VzLFxuICAgICAgcmV0cnlGaWxlVXBsb2FkLFxuICAgICAgY2FuY2VsRmlsZVVwbG9hZCxcbiAgICAgIGRlbGV0ZU1lc3NhZ2UsXG4gICAgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiaW8iLCJheGlvcyIsInVzZUF1dGgiLCJGaWxlVHlwZSIsIkNoYXRDb250ZXh0IiwiYWN0aXZlQ2hhdCIsIm1lc3NhZ2VzIiwicm9vbXMiLCJvbmxpbmVVc2VycyIsInVzZXJzIiwidHlwaW5nVXNlcnMiLCJpc0xvYWRpbmciLCJpc0xvYWRpbmdNZXNzYWdlcyIsInVucmVhZE1lc3NhZ2VzIiwidXBsb2FkaW5nRmlsZXMiLCJzZXRBY3RpdmVDaGF0Iiwic2VuZE1lc3NhZ2UiLCJtYXJrQXNSZWFkIiwic3RhcnRUeXBpbmciLCJzdG9wVHlwaW5nIiwibG9hZE1vcmVNZXNzYWdlcyIsInJldHJ5RmlsZVVwbG9hZCIsImNhbmNlbEZpbGVVcGxvYWQiLCJkZWxldGVNZXNzYWdlIiwidXNlQ2hhdCIsIkNoYXRQcm92aWRlciIsImNoaWxkcmVuIiwidXNlciIsImlzQXV0aGVudGljYXRlZCIsInNldE1lc3NhZ2VzIiwic2V0Um9vbXMiLCJzZXRVc2VycyIsInNldE9ubGluZVVzZXJzIiwic2V0VHlwaW5nVXNlcnMiLCJzZXRJc0xvYWRpbmciLCJzZXRJc0xvYWRpbmdNZXNzYWdlcyIsInNvY2tldENvbm5lY3RlZCIsInNldFNvY2tldENvbm5lY3RlZCIsInNldFVucmVhZE1lc3NhZ2VzIiwidXBsb2FkaW5nRmlsZXNCeUNoYXQiLCJzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdCIsInNlbGVjdGVkRmlsZSIsInNldFNlbGVjdGVkRmlsZSIsImNoYXRJZCIsInR5cGUiLCJpZCIsInVwZGF0ZVVwbG9hZGluZ0ZpbGVzIiwiZmlsZUlkIiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJwcmV2IiwibmV3U3RhdGUiLCJfIiwicmVzdEZpbGVzIiwicHJvZ3Jlc3MiLCJmaWxlIiwidGVtcElkIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJmaWxlSW5wdXRSZWYiLCJjdXJyZW50IiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ0aW1lb3V0Iiwib24iLCJtZXNzYWdlIiwiY2hhdEtleSIsInJvb20iLCJzZW5kZXIiLCJfaWQiLCJyZWNpcGllbnQiLCJ1c2VySWQiLCJpc09ubGluZSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJ1c2VyTmFtZSIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImRlbGV0ZUZvckV2ZXJ5b25lIiwiZmV0Y2hJbml0aWFsRGF0YSIsInVzZXJzUmVzcG9uc2UiLCJyb29tc1Jlc3BvbnNlIiwiUHJvbWlzZSIsImFsbCIsImdldCIsImluaXRpYWxPbmxpbmVTdGF0dXMiLCJmb3JFYWNoIiwiZXJyb3IiLCJlbWl0IiwidW5yZWFkQ291bnRzIiwib2ZmIiwiY2hhdFR5cGUiLCJoYW5kbGVBY3RpdmVDaGF0Q2hhbmdlIiwiY2hhdCIsImhhc0NvbXBsZXRlZFVwbG9hZHMiLCJPYmplY3QiLCJ2YWx1ZXMiLCJzdGF0dXMiLCJmZXRjaE1lc3NhZ2VzIiwiZW5kcG9pbnQiLCJyZXNwb25zZSIsImxlbmd0aCIsImNsZWFudXBJbnRlcnZhbCIsInNldEludGVydmFsIiwiaGFzQ2hhbmdlcyIsImtleXMiLCJjbGVhckludGVydmFsIiwiY29udGVudCIsImF0dGFjaG1lbnRzV2l0aElkcyIsIk1hdGgiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHJpbmciLCJmaWxlVHlwZSIsImZpbGVUeXBlU3RyaW5nIiwic3RhcnRzV2l0aCIsImF0dGFjaG1lbnQiLCJmaWxlbmFtZSIsIm5hbWUiLCJjb250ZW50VHlwZSIsInNpemUiLCJ1bmRlZmluZWQiLCJpc0xhcmdlRmlsZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJyZWFkQXNEYXRhVVJMIiwicmVzb2x2ZSIsIm9ubG9hZCIsImJhc2U2NGRhdGEiLCJyZXN1bHQiLCJiYXNlNjRDbGVhbiIsInNwbGl0IiwicHVzaCIsInVwbG9hZExhcmdlRmlsZVRvU2VydmVyIiwidGhlbiIsImNhdGNoIiwibWVzc2FnZURhdGEiLCJhdHRhY2htZW50cyIsInJlY2lwaWVudElkIiwic3VjY2VzcyIsInZhbHVlIiwiY3JlYXRlUm9vbSIsImRlc2NyaXB0aW9uIiwiaXNQcml2YXRlIiwibWVtYmVycyIsInBvc3QiLCJ1cGRhdGVSb29tIiwidXBkYXRlRGF0YSIsInB1dCIsInByZXZSb29tcyIsImpvaW5Sb29tIiwidGFyZ2V0VXNlcklkIiwibGVhdmVSb29tIiwiZGVsZXRlIiwic2V0VHlwaW5nIiwidHlwaW5nRGF0YSIsImNsZWFyQ2hhdEhpc3RvcnkiLCJiYXNlNjREYXRhIiwiYnl0ZUNoYXJhY3RlcnMiLCJhdG9iIiwiYnl0ZUFycmF5cyIsIm9mZnNldCIsInNsaWNlIiwiYnl0ZU51bWJlcnMiLCJBcnJheSIsImkiLCJjaGFyQ29kZUF0IiwiYnl0ZUFycmF5IiwiVWludDhBcnJheSIsImJsb2IiLCJCbG9iIiwiRmlsZSIsImZvcm1EYXRhIiwiRm9ybURhdGEiLCJhcHBlbmQiLCJoZWFkZXJzIiwib25VcGxvYWRQcm9ncmVzcyIsInByb2dyZXNzRXZlbnQiLCJwZXJjZW50Q29tcGxldGVkIiwidG90YWwiLCJyb3VuZCIsImxvYWRlZCIsInNldFRpbWVvdXQiLCJoYW5kbGVNYXJrQXNSZWFkIiwiZmV0Y2hNb3JlTWVzc2FnZXMiLCJwYWdlIiwicGFyYW1zIiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});