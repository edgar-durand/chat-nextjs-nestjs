"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    createRoom: async ()=>({\n            _id: \"\",\n            name: \"\",\n            creator: {\n                id: \"\",\n                _id: \"\",\n                name: \"\",\n                email: \"\",\n                avatar: \"\"\n            },\n            members: [],\n            isPrivate: false,\n            createdAt: \"\"\n        }),\n    updateRoom: async ()=>({\n            _id: \"\",\n            name: \"\",\n            creator: {\n                id: \"\",\n                _id: \"\",\n                name: \"\",\n                email: \"\",\n                avatar: \"\"\n            },\n            members: [],\n            isPrivate: false,\n            createdAt: \"\"\n        }),\n    joinRoom: async ()=>{},\n    leaveRoom: async ()=>{},\n    setTyping: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Only add the message if it's relevant to the active chat\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Load messages when activeChat changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated || !socketConnected) {\n            setMessages([]);\n            return;\n        }\n        const fetchMessages = async ()=>{\n            try {\n                setIsLoading(true);\n                let response;\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id));\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id));\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                setMessages(response.data);\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchMessages();\n        // Clear typing indicator when changing chats\n        setTypingUsers({});\n        return ()=>{\n            // Leave previous chat room\n            if (activeChat.type === \"private\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    userId: activeChat.id\n                });\n            } else {\n                var _socketRef_current1;\n                (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        isAuthenticated,\n        API_URL,\n        socketConnected\n    ]);\n    const sendMessage = async (content)=>{\n        if (!activeChat || !user || !socketRef.current) return;\n        try {\n            const messageData = {\n                content,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            socketRef.current.emit(\"send_message\", messageData);\n        } catch (error) {\n            console.error(\"Error sending message:\", error);\n            throw error;\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            setActiveChat,\n            sendMessage,\n            createRoom,\n            updateRoom,\n            joinRoom,\n            leaveRoom,\n            setTyping\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 388,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"+6U8vaGQK085u+xjm+cgIhfHtF4=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUNoRCxFQUFFLE9BQU9aLE9BQU87WUFDZC9CLFFBQVErQixLQUFLLENBQUMsdUJBQXVCQTtZQUNyQyxNQUFNQTtRQUNSO0lBQ0Y7SUFFQSxNQUFNM0QsWUFBWSxDQUFDeUM7UUFDakIsSUFBSSxDQUFDL0QsY0FBYyxDQUFDb0MsVUFBVUUsT0FBTyxFQUFFO1FBRXZDLE1BQU15RCxhQUFhO1lBQ2pCaEM7WUFDQSxHQUFJL0QsV0FBV3FELElBQUksS0FBSyxZQUFZO2dCQUFFa0MsYUFBYXZGLFdBQVdhLEVBQUU7WUFBQyxJQUFJO2dCQUFFaUQsUUFBUTlELFdBQVdhLEVBQUU7WUFBQyxDQUFDO1FBQ2hHO1FBRUF1QixVQUFVRSxPQUFPLENBQUM4QyxJQUFJLENBQUMsVUFBVVc7SUFDbkM7SUFFQSxxQkFDRSw4REFBQ2hHLFlBQVlpRyxRQUFRO1FBQUNDLE9BQU87WUFDM0JqRztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBQztZQUNBVTtZQUNBQztZQUNBQztZQUNBQztRQUNGO2tCQUNHRzs7Ozs7O0FBR1AsRUFBRTtJQWhVV0Q7O1FBQ3VCMUIsaURBQU9BOzs7S0FEOUIwQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29udGV4dHMvQ2hhdENvbnRleHQudHN4PzBiNTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgX2lkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGF2YXRhcjogc3RyaW5nO1xuICBpc09ubGluZT86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBNZXNzYWdlIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGNvbnRlbnQ6IHN0cmluZztcbiAgc2VuZGVyOiBVc2VyO1xuICByZWNpcGllbnQ/OiBzdHJpbmc7XG4gIHJvb20/OiBzdHJpbmc7XG4gIGlzUmVhZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSb29tIHtcbiAgX2lkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGltYWdlPzogc3RyaW5nO1xuICBjcmVhdG9yOiBVc2VyO1xuICBtZW1iZXJzOiBVc2VyW107XG4gIGlzUHJpdmF0ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIHJlbW92ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ2hhdENvbnRleHRUeXBlIHtcbiAgYWN0aXZlQ2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHJvb21zOiBSb29tW107XG4gIG9ubGluZVVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcbiAgdXNlcnM6IFVzZXJbXTtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIHNldEFjdGl2ZUNoYXQ6IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGNyZWF0ZVJvb206IChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uPzogc3RyaW5nLCBpc1ByaXZhdGU/OiBib29sZWFuLCBtZW1iZXJzPzogc3RyaW5nW10pID0+IFByb21pc2U8Um9vbT47XG4gIHVwZGF0ZVJvb206IChyb29tSWQ6IHN0cmluZywgZGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZzsgaW1hZ2U/OiBzdHJpbmc7IGlzUHJpdmF0ZT86IGJvb2xlYW4gfSkgPT4gUHJvbWlzZTxSb29tPjtcbiAgam9pblJvb206IChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBsZWF2ZVJvb206IChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBzZXRUeXBpbmc6IChpc1R5cGluZzogYm9vbGVhbikgPT4gdm9pZDtcbn1cblxuY29uc3QgQ2hhdENvbnRleHQgPSBjcmVhdGVDb250ZXh0PENoYXRDb250ZXh0VHlwZT4oe1xuICBhY3RpdmVDaGF0OiBudWxsLFxuICBtZXNzYWdlczogW10sXG4gIHJvb21zOiBbXSxcbiAgb25saW5lVXNlcnM6IHt9LFxuICB1c2VyczogW10sXG4gIHR5cGluZ1VzZXJzOiB7fSxcbiAgaXNMb2FkaW5nOiB0cnVlLFxuICBzZXRBY3RpdmVDaGF0OiAoKSA9PiB7fSxcbiAgc2VuZE1lc3NhZ2U6IGFzeW5jICgpID0+IHt9LFxuICBjcmVhdGVSb29tOiBhc3luYyAoKSA9PiAoeyBcbiAgICBfaWQ6ICcnLCBcbiAgICBuYW1lOiAnJywgXG4gICAgY3JlYXRvcjogeyBpZDogJycsIF9pZDogJycsIG5hbWU6ICcnLCBlbWFpbDogJycsIGF2YXRhcjogJycgfSwgXG4gICAgbWVtYmVyczogW10sIFxuICAgIGlzUHJpdmF0ZTogZmFsc2UsIFxuICAgIGNyZWF0ZWRBdDogJycgXG4gIH0pLFxuICB1cGRhdGVSb29tOiBhc3luYyAoKSA9PiAoeyBcbiAgICBfaWQ6ICcnLCBcbiAgICBuYW1lOiAnJywgXG4gICAgY3JlYXRvcjogeyBpZDogJycsIF9pZDogJycsIG5hbWU6ICcnLCBlbWFpbDogJycsIGF2YXRhcjogJycgfSwgXG4gICAgbWVtYmVyczogW10sIFxuICAgIGlzUHJpdmF0ZTogZmFsc2UsIFxuICAgIGNyZWF0ZWRBdDogJycgXG4gIH0pLFxuICBqb2luUm9vbTogYXN5bmMgKCkgPT4ge30sXG4gIGxlYXZlUm9vbTogYXN5bmMgKCkgPT4ge30sXG4gIHNldFR5cGluZzogKCkgPT4ge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IENoYXRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IHVzZXIsIGlzQXV0aGVudGljYXRlZCB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbYWN0aXZlQ2hhdCwgc2V0QWN0aXZlQ2hhdF0gPSB1c2VTdGF0ZTx7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtyb29tcywgc2V0Um9vbXNdID0gdXNlU3RhdGU8Um9vbVtdPihbXSk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8VXNlcltdPihbXSk7XG4gIGNvbnN0IFtvbmxpbmVVc2Vycywgc2V0T25saW5lVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcbiAgY29uc3QgW3R5cGluZ1VzZXJzLCBzZXRUeXBpbmdVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtzb2NrZXRDb25uZWN0ZWQsIHNldFNvY2tldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIFxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRBY3RpdmVDaGF0UmVmID0gdXNlUmVmKGFjdGl2ZUNoYXQpO1xuICBcbiAgLy8gS2VlcCB0aGUgcmVmIGluIHN5bmMgd2l0aCB0aGUgc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50ID0gYWN0aXZlQ2hhdDtcbiAgfSwgW2FjdGl2ZUNoYXRdKTtcbiAgXG4gIGNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBzb2NrZXQgY29ubmVjdGlvbiB3aGVuIGF1dGhlbnRpY2F0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCB8fCAhdXNlcikge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICBcbiAgICBpZiAoIXRva2VuKSByZXR1cm47XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQgPSBpbyhBUElfVVJMLCB7XG4gICAgICBhdXRoOiB7IHRva2VuIH0sXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU29ja2V0IGV2ZW50IGxpc3RlbmVyc1xuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZCh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X21lc3NhZ2UnLCAobWVzc2FnZTogTWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICAvLyBPbmx5IGFkZCB0aGUgbWVzc2FnZSBpZiBpdCdzIHJlbGV2YW50IHRvIHRoZSBhY3RpdmUgY2hhdFxuICAgICAgaWYgKFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3ByaXZhdGUnICYmIFxuICAgICAgICAgICgobWVzc2FnZS5zZW5kZXIuX2lkID09PSBhY3RpdmVDaGF0LmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSB1c2VyLmlkKSB8fCBcbiAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gdXNlci5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gYWN0aXZlQ2hhdC5pZCkpKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIG1lc3NhZ2Uucm9vbSA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5wcmV2LCBtZXNzYWdlXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VzZXJfc3RhdHVzX2NoYW5nZScsICh7IHVzZXJJZCwgaXNPbmxpbmUgfSkgPT4ge1xuICAgICAgc2V0T25saW5lVXNlcnMocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogaXNPbmxpbmUgfSkpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd0eXBpbmdfaW5kaWNhdG9yJywgKGRhdGE6IHsgdXNlcklkOiBzdHJpbmcsIHVzZXJOYW1lOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuLCByb29tSWQ/OiBzdHJpbmcsIHNlbmRlcklkPzogc3RyaW5nIH0pID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3ByaXZhdGUnICYmIGRhdGEuc2VuZGVySWQgPT09IGFjdGl2ZUNoYXQuaWQpIHx8XG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgZGF0YS5yb29tSWQgPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgc2V0VHlwaW5nVXNlcnMocHJldiA9PiAoeyAuLi5wcmV2LCBbZGF0YS51c2VySWRdOiBkYXRhLmlzVHlwaW5nIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbWVzc2FnZV9yZWFkJywgKHsgbWVzc2FnZUlkIH0pID0+IHtcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgbmV3IHJvb20gY3JlYXRpb25zXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19yb29tJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgcm9vbSByZWNlaXZlZDonLCByb29tKTtcbiAgICAgIHNldFJvb21zKHByZXYgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm9vbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LnNvbWUociA9PiByLl9pZCA9PT0gcm9vbS5faWQpO1xuICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcHJldjtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCByb29tXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSByb29tIHVwZGF0ZXMgKG1lbWJlcnMgYWRkZWQvcmVtb3ZlZClcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigncm9vbV91cGRhdGVkJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdSb29tIHVwZGF0ZWQ6Jywgcm9vbSk7XG4gICAgICBpZiAocm9vbS5yZW1vdmVkKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vbSB3YXMgcmVtb3ZlZCBmb3IgdGhpcyB1c2VyLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYuZmlsdGVyKHIgPT4gci5faWQgIT09IHJvb20uX2lkKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBhY3RpdmUgY2hhdCBpcyB0aGlzIHJvb20sIGNsZWFyIGl0XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGFjdGl2ZUNoYXQuaWQgPT09IHJvb20uX2lkKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ2hhdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5tYXAociA9PiByLl9pZCA9PT0gcm9vbS5faWQgPyByb29tIDogcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgdXNlciwgQVBJX1VSTF0pO1xuICBcbiAgLy8gTG9hZCBpbml0aWFsIGRhdGE6IHVzZXJzIGFuZCByb29tc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmZXRjaEluaXRpYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgW3VzZXJzUmVzcG9uc2UsIHJvb21zUmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS91c2Vyc2ApLFxuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS9yb29tcy9teWApXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgc2V0VXNlcnModXNlcnNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgc2V0Um9vbXMocm9vbXNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBpbml0aWFsIG9ubGluZSBzdGF0dXNcbiAgICAgICAgY29uc3QgaW5pdGlhbE9ubGluZVN0YXR1czogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbiAgICAgICAgdXNlcnNSZXNwb25zZS5kYXRhLmZvckVhY2goKHVzZXI6IFVzZXIpID0+IHtcbiAgICAgICAgICBpbml0aWFsT25saW5lU3RhdHVzW3VzZXIuX2lkIV0gPSB1c2VyLmlzT25saW5lIHx8IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0T25saW5lVXNlcnMoaW5pdGlhbE9ubGluZVN0YXR1cyk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgaW5pdGlhbCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaEluaXRpYWxEYXRhKCk7XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIExvYWQgbWVzc2FnZXMgd2hlbiBhY3RpdmVDaGF0IGNoYW5nZXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIWlzQXV0aGVudGljYXRlZCB8fCAhc29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIGNvbnN0IGZldGNoTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBzZXRJc0xvYWRpbmcodHJ1ZSk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiB1c2VyIHJvb20gZm9yIGRpcmVjdCBtZXNzYWdlc1xuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHVzZXJJZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS9jaGF0cy9yb29tLyR7YWN0aXZlQ2hhdC5pZH1gKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKb2luIHJvb21cbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNldE1lc3NhZ2VzKHJlc3BvbnNlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWVzc2FnZXM6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZldGNoTWVzc2FnZXMoKTtcbiAgICBcbiAgICAvLyBDbGVhciB0eXBpbmcgaW5kaWNhdG9yIHdoZW4gY2hhbmdpbmcgY2hhdHNcbiAgICBzZXRUeXBpbmdVc2Vycyh7fSk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIExlYXZlIHByZXZpb3VzIGNoYXQgcm9vbVxuICAgICAgaWYgKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnKSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdsZWF2ZV9yb29tJywgeyB1c2VySWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbGVhdmVfcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthY3RpdmVDaGF0LCBpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkwsIHNvY2tldENvbm5lY3RlZF0pO1xuICBcbiAgY29uc3Qgc2VuZE1lc3NhZ2UgPSBhc3luYyAoY29udGVudDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICF1c2VyIHx8ICFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgICB9O1xuICAgICAgXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdzZW5kX21lc3NhZ2UnLCBtZXNzYWdlRGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNlbmRpbmcgbWVzc2FnZTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBjcmVhdGVSb29tID0gYXN5bmMgKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb24gPSAnJywgaXNQcml2YXRlID0gZmFsc2UsIG1lbWJlcnM6IHN0cmluZ1tdID0gW10pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L3Jvb21zYCwge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgaXNQcml2YXRlLFxuICAgICAgICBtZW1iZXJzLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE5vIG5lZWQgdG8gbWFudWFsbHkgYWRkIHRvIHJvb21zIGFycmF5LCB0aGUgc29ja2V0IGV2ZW50IHdpbGwgaGFuZGxlIGl0XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCB1cGRhdGVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1cGRhdGVEYXRhOiB7IG5hbWU/OiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyBpbWFnZT86IHN0cmluZzsgaXNQcml2YXRlPzogYm9vbGVhbiB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucHV0KGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfWAsIHVwZGF0ZURhdGEpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIHJvb20gaW4gdGhlIGxvY2FsIHN0YXRlIHRvIGltbWVkaWF0ZWx5IHJlZmxlY3QgY2hhbmdlc1xuICAgICAgc2V0Um9vbXMocHJldlJvb21zID0+IFxuICAgICAgICBwcmV2Um9vbXMubWFwKHJvb20gPT4gXG4gICAgICAgICAgcm9vbS5faWQgPT09IHJvb21JZCA/IHsgLi4ucm9vbSwgLi4uZGF0YSB9IDogcm9vbVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBqb2luUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiBhZGRpbmcgb3RoZXJzKVxuICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBjdXJyZW50IHVzZXIncyBJRCAoZm9yIHNlbGYtam9pbmluZylcbiAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCB1c2VyIS5pZDtcbiAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt0YXJnZXRVc2VySWR9YCk7XG4gICAgICAvLyBSb29tIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgYnkgc29ja2V0IGV2ZW50XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGpvaW5pbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBsZWF2ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlciAmJiAhdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHVzZXJJZCBpcyBwcm92aWRlZCwgdXNlIGl0IChmb3IgYWRtaW4gcmVtb3Zpbmcgb3RoZXJzKVxuICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBjdXJyZW50IHVzZXIncyBJRCAoZm9yIHNlbGYtbGVhdmluZylcbiAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCB1c2VyIS5pZDtcbiAgICAgIGF3YWl0IGF4aW9zLmRlbGV0ZShgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbGVhdmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHNldFR5cGluZyA9IChpc1R5cGluZzogYm9vbGVhbikgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhc29ja2V0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0eXBpbmdEYXRhID0ge1xuICAgICAgaXNUeXBpbmcsXG4gICAgICAuLi4oYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgPyB7IHJlY2lwaWVudElkOiBhY3RpdmVDaGF0LmlkIH0gOiB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KSxcbiAgICB9O1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ3R5cGluZycsIHR5cGluZ0RhdGEpO1xuICB9O1xuICBcbiAgcmV0dXJuIChcbiAgICA8Q2hhdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tcbiAgICAgIGFjdGl2ZUNoYXQsXG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHJvb21zLFxuICAgICAgb25saW5lVXNlcnMsXG4gICAgICB1c2VycyxcbiAgICAgIHR5cGluZ1VzZXJzLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgc2V0QWN0aXZlQ2hhdCxcbiAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgY3JlYXRlUm9vbSxcbiAgICAgIHVwZGF0ZVJvb20sXG4gICAgICBqb2luUm9vbSxcbiAgICAgIGxlYXZlUm9vbSxcbiAgICAgIHNldFR5cGluZyxcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NoYXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbyIsImF4aW9zIiwidXNlQXV0aCIsIkNoYXRDb250ZXh0IiwiYWN0aXZlQ2hhdCIsIm1lc3NhZ2VzIiwicm9vbXMiLCJvbmxpbmVVc2VycyIsInVzZXJzIiwidHlwaW5nVXNlcnMiLCJpc0xvYWRpbmciLCJzZXRBY3RpdmVDaGF0Iiwic2VuZE1lc3NhZ2UiLCJjcmVhdGVSb29tIiwiX2lkIiwibmFtZSIsImNyZWF0b3IiLCJpZCIsImVtYWlsIiwiYXZhdGFyIiwibWVtYmVycyIsImlzUHJpdmF0ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZVJvb20iLCJqb2luUm9vbSIsImxlYXZlUm9vbSIsInNldFR5cGluZyIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic29ja2V0Q29ubmVjdGVkIiwic2V0U29ja2V0Q29ubmVjdGVkIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJjdXJyZW50IiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJvbiIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwidHlwZSIsInNlbmRlciIsInJlY2lwaWVudCIsInJvb20iLCJwcmV2IiwidXNlcklkIiwiaXNPbmxpbmUiLCJkYXRhIiwic2VuZGVySWQiLCJyb29tSWQiLCJpc1R5cGluZyIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImZldGNoSW5pdGlhbERhdGEiLCJ1c2Vyc1Jlc3BvbnNlIiwicm9vbXNSZXNwb25zZSIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJpbml0aWFsT25saW5lU3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiZmV0Y2hNZXNzYWdlcyIsInJlc3BvbnNlIiwiZW1pdCIsImNvbnRlbnQiLCJtZXNzYWdlRGF0YSIsInJlY2lwaWVudElkIiwiZGVzY3JpcHRpb24iLCJwb3N0IiwidXBkYXRlRGF0YSIsInB1dCIsInByZXZSb29tcyIsInRhcmdldFVzZXJJZCIsImRlbGV0ZSIsInR5cGluZ0RhdGEiLCJQcm92aWRlciIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});