"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>{},\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFiles, setUploadingFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envío de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room_\".concat(message.room);\n            } else if (message.sender._id !== user.id) {\n                chatKey = \"user_\".concat(message.sender._id);\n            } else if (message.recipient) {\n                chatKey = \"user_\".concat(message.recipient);\n            }\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leídos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leídos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leídos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leídos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = activeChat.type === \"private\" ? \"user_\".concat(activeChat.id) : \"room_\".concat(activeChat.id);\n            // Resetear el contador de mensajes no leídos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leído\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // Función para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leídas cuando se activa un chat\n        if (chat) {\n            const chatKey = chat.type === \"private\" ? \"user_\".concat(chat.id) : \"room_\".concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Cargar mensajes cuando se selecciona un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !user || !isAuthenticated) {\n            setMessages([]);\n            setIsLoadingMessages(false);\n            return;\n        }\n        setIsLoadingMessages(true);\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leídos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    const sendMessage = async function(content) {\n        let attachments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        if (!activeChat || !isAuthenticated || !socketRef.current) {\n            return;\n        }\n        // Inicializar estado de carga para cada archivo\n        const newUploadingFiles = {\n            ...uploadingFiles\n        };\n        // Para archivos grandes, especialmente videos, los enviamos usando el nuevo endpoint optimizado\n        let processedAttachments = [];\n        // Asignar IDs temporales para seguimiento\n        const attachmentsWithIds = attachments.map((attachment)=>({\n                ...attachment,\n                tempId: \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9))\n            }));\n        // Establecer el estado inicial de carga para cada archivo\n        attachmentsWithIds.forEach((attachment)=>{\n            newUploadingFiles[attachment.tempId] = {\n                progress: 0\n            };\n        });\n        setUploadingFiles(newUploadingFiles);\n        try {\n            for (const attachment of attachmentsWithIds){\n                // Actualizar progreso\n                setUploadingFiles((prev)=>({\n                        ...prev,\n                        [attachment.tempId]: {\n                            progress: 10,\n                            error: undefined\n                        }\n                    }));\n                // Si es un video o archivo grande, lo enviamos usando el nuevo endpoint optimizado\n                if (attachment.fileType === \"video\" || attachment.size && attachment.size > 5 * 1024 * 1024) {\n                    console.log(\"Subiendo archivo grande (\".concat(attachment.fileType, \"): \").concat(attachment.filename, \", tama\\xf1o: \").concat(attachment.size, \" bytes\"));\n                    // Crear un objeto FormData para enviar el archivo\n                    const formData = new FormData();\n                    // Si tenemos datos en base64, convertirlos a Blob\n                    if (attachment.data && attachment.data.startsWith(\"data:\")) {\n                        // Extraer los datos base64 (quitar el prefijo \"data:MIME;base64,\")\n                        const base64Data = attachment.data.split(\",\")[1];\n                        const binaryString = window.atob(base64Data);\n                        const bytes = new Uint8Array(binaryString.length);\n                        for(let i = 0; i < binaryString.length; i++){\n                            bytes[i] = binaryString.charCodeAt(i);\n                        }\n                        const blob = new Blob([\n                            bytes\n                        ], {\n                            type: attachment.contentType\n                        });\n                        formData.append(\"file\", blob, attachment.filename);\n                    } else if (attachment.data) {\n                        // Si tenemos datos binarios directos\n                        const byteCharacters = atob(attachment.data);\n                        const byteArrays = [];\n                        for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                            const slice = byteCharacters.slice(offset, offset + 512);\n                            const byteNumbers = new Array(slice.length);\n                            for(let i = 0; i < slice.length; i++){\n                                byteNumbers[i] = slice.charCodeAt(i);\n                            }\n                            const byteArray = new Uint8Array(byteNumbers);\n                            byteArrays.push(byteArray);\n                        }\n                        const blob = new Blob(byteArrays, {\n                            type: attachment.contentType\n                        });\n                        formData.append(\"file\", blob, attachment.filename);\n                    }\n                    // Añadir metadatos del archivo\n                    formData.append(\"contentType\", attachment.contentType);\n                    // Actualizar progreso\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: 30,\n                                error: undefined\n                            }\n                        }));\n                    try {\n                        // Usar el nuevo endpoint para subir el archivo directamente\n                        const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                            headers: {\n                                \"Content-Type\": \"multipart/form-data\"\n                            },\n                            onUploadProgress: (progressEvent)=>{\n                                const percentCompleted = Math.round(progressEvent.loaded * 70 / (progressEvent.total || 100));\n                                // Actualizar el progreso (30% base + hasta 70% más durante la carga)\n                                setUploadingFiles((prev)=>({\n                                        ...prev,\n                                        [attachment.tempId]: {\n                                            progress: 30 + percentCompleted,\n                                            error: undefined\n                                        }\n                                    }));\n                            }\n                        });\n                        console.log(\"Respuesta de carga:\", response.data);\n                        if (response.data && response.data.fileId) {\n                            // Archivo subido correctamente\n                            processedAttachments.push({\n                                ...attachment,\n                                fileId: response.data.fileId,\n                                isLargeFile: true,\n                                // Eliminar los datos binarios para evitar enviarlos de nuevo\n                                data: undefined\n                            });\n                            // Actualizar progreso a 100%\n                            setUploadingFiles((prev)=>({\n                                    ...prev,\n                                    [attachment.tempId]: {\n                                        progress: 100,\n                                        error: undefined\n                                    }\n                                }));\n                        } else {\n                            throw new Error(\"No se pudo obtener el ID del archivo\");\n                        }\n                    } catch (uploadError) {\n                        console.error(\"Error al subir archivo grande:\", uploadError);\n                        // Actualizar estado con el error\n                        setUploadingFiles((prev)=>({\n                                ...prev,\n                                [attachment.tempId]: {\n                                    progress: 0,\n                                    error: uploadError.message || \"Error al subir el archivo\"\n                                }\n                            }));\n                        continue;\n                    }\n                } else {\n                    // Para archivos pequeños, los enviamos con el mensaje\n                    processedAttachments.push(attachment);\n                    // Actualizar progreso\n                    setUploadingFiles((prev)=>({\n                            ...prev,\n                            [attachment.tempId]: {\n                                progress: 80,\n                                error: undefined\n                            }\n                        }));\n                }\n            }\n            const messageData = {\n                content,\n                attachments: processedAttachments,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            // Enviar el mensaje a través del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                if (response.success) {\n                    // Éxito - quitar archivos del estado de carga\n                    const finalProgress = {\n                        ...uploadingFiles\n                    };\n                    attachmentsWithIds.forEach((attachment)=>{\n                        delete finalProgress[attachment.tempId];\n                    });\n                    setUploadingFiles(finalProgress);\n                } else {\n                    // Error - actualizar estado con el error\n                    const errorProgress = {\n                        ...uploadingFiles\n                    };\n                    attachmentsWithIds.forEach((attachment)=>{\n                        errorProgress[attachment.tempId] = {\n                            progress: 0,\n                            error: response.error || \"Error al enviar el mensaje\"\n                        };\n                    });\n                    setUploadingFiles(errorProgress);\n                }\n            });\n            // Limpiar formulario después de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar archivos:\", error);\n            // Actualizar estado con el error\n            const errorProgress = {\n                ...uploadingFiles\n            };\n            attachmentsWithIds.forEach((attachment)=>{\n                errorProgress[attachment.tempId] = {\n                    progress: 0,\n                    error: error.message || \"Error al procesar archivos\"\n                };\n            });\n            setUploadingFiles(errorProgress);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    const retryFileUpload = (file)=>{\n    // Implementar la lógica para reintentar la subida de archivos\n    };\n    const cancelFileUpload = (file)=>{\n    // Implementar la lógica para cancelar la subida de archivos\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            users,\n            onlineUsers,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            createRoom,\n            updateRoom,\n            joinRoom,\n            leaveRoom,\n            setTyping,\n            clearChatHistory,\n            retryFileUpload,\n            cancelFileUpload\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 692,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"ygKBXQHUDveXc83kNn6UfJuKVi4=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U0FBUztnQkFBTXJHLFNBQVM7WUFBb0M7UUFDdkUsRUFBRSxPQUFPaUMsT0FBTztZQUNkbkMsUUFBUW1DLEtBQUssQ0FBQyxnQ0FBZ0NBO1lBQzlDLE9BQU87Z0JBQUVvRSxTQUFTO2dCQUFPckcsU0FBUztZQUErQjtRQUNuRTtJQUNGO0lBRUEsTUFBTXRDLGtCQUFrQixDQUFDK0o7SUFDdkIsOERBQThEO0lBQ2hFO0lBRUEsTUFBTTlKLG1CQUFtQixDQUFDOEo7SUFDeEIsNERBQTREO0lBQzlEO0lBRUEscUJBQ0UsOERBQUNoTCxZQUFZaUwsUUFBUTtRQUFDbEIsT0FBTztZQUMzQjlKO1lBQ0FDO1lBQ0FDO1lBQ0FFO1lBQ0FEO1lBQ0FFO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDLGVBQWVtRjtZQUNmbEY7WUFDQW9KO1lBQ0FLO1lBQ0FJO1lBQ0FFO1lBQ0FFO1lBQ0FFO1lBQ0E5SjtZQUNBQztRQUNGO2tCQUNHRzs7Ozs7O0FBR1AsRUFBRTtJQXJtQldEOztRQUN1QnRCLGlEQUFPQTs7O0tBRDlCc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbnRleHRzL0NoYXRDb250ZXh0LnRzeD8wYjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbywgU29ja2V0IH0gZnJvbSAnc29ja2V0LmlvLWNsaWVudCc7XG5pbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xuaW1wb3J0IHsgdXNlQXV0aCB9IGZyb20gJy4vQXV0aENvbnRleHQnO1xuXG5pbnRlcmZhY2UgVXNlciB7XG4gIGlkOiBzdHJpbmc7XG4gIF9pZD86IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBlbWFpbDogc3RyaW5nO1xuICBhdmF0YXI6IHN0cmluZztcbiAgaXNPbmxpbmU/OiBib29sZWFuO1xufVxuXG5leHBvcnQgZW51bSBGaWxlVHlwZSB7XG4gIElNQUdFID0gJ2ltYWdlJyxcbiAgVklERU8gPSAndmlkZW8nLFxuICBET0NVTUVOVCA9ICdkb2N1bWVudCcsXG4gIEFVRElPID0gJ2F1ZGlvJ1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVBdHRhY2htZW50IHtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgY29udGVudFR5cGU6IHN0cmluZztcbiAgZmlsZVR5cGU6IEZpbGVUeXBlO1xuICBkYXRhPzogc3RyaW5nOyAvLyBCYXNlNjQgZW5jb2RlZCBkYXRhIHBhcmEgYXJjaGl2b3MgcGVxdWXDsW9zXG4gIHNpemU/OiBudW1iZXI7XG4gIGZpbGVJZD86IHN0cmluZzsgLy8gSUQgcGFyYSBhcmNoaXZvcyBncmFuZGVzIGFsbWFjZW5hZG9zIHBvciBzZXBhcmFkb1xuICBpc0xhcmdlRmlsZT86IGJvb2xlYW47IC8vIEluZGljYSBzaSBlbCBhcmNoaXZvIGVzdMOhIGFsbWFjZW5hZG8gcG9yIHNlcGFyYWRvXG4gIGlzQ2h1bms/OiBib29sZWFuO1xuICBvcmlnaW5hbEZpbGVuYW1lPzogc3RyaW5nO1xuICBjaHVua0luZGV4PzogbnVtYmVyO1xuICB0b3RhbENodW5rcz86IG51bWJlcjtcbiAgdGVtcElkPzogc3RyaW5nOyAvLyBJRCB0ZW1wb3JhbCBwYXJhIHNlZ3VpbWllbnRvIGRlIGNhcmdhXG59XG5cbmludGVyZmFjZSBNZXNzYWdlIHtcbiAgX2lkOiBzdHJpbmc7XG4gIGNvbnRlbnQ/OiBzdHJpbmc7XG4gIGF0dGFjaG1lbnRzPzogRmlsZUF0dGFjaG1lbnRbXTtcbiAgc2VuZGVyOiBVc2VyO1xuICByZWNpcGllbnQ/OiBzdHJpbmc7XG4gIHJvb20/OiBzdHJpbmc7XG4gIGlzUmVhZDogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBSb29tIHtcbiAgX2lkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGltYWdlPzogc3RyaW5nO1xuICBjcmVhdG9yOiBVc2VyO1xuICBtZW1iZXJzOiBVc2VyW107XG4gIGlzUHJpdmF0ZTogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG4gIHJlbW92ZWQ/OiBib29sZWFuO1xufVxuXG5pbnRlcmZhY2UgQ2hhdENvbnRleHRUeXBlIHtcbiAgYWN0aXZlQ2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGw7XG4gIG1lc3NhZ2VzOiBNZXNzYWdlW107XG4gIHJvb21zOiBSb29tW107XG4gIG9ubGluZVVzZXJzOiBSZWNvcmQ8c3RyaW5nLCBib29sZWFuPjtcbiAgdXNlcnM6IFVzZXJbXTtcbiAgdHlwaW5nVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmc+O1xuICBpc0xvYWRpbmc6IGJvb2xlYW47XG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBib29sZWFuO1xuICB1bnJlYWRNZXNzYWdlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgdXBsb2FkaW5nRmlsZXM6IFJlY29yZDxzdHJpbmcsIHsgcHJvZ3Jlc3M6IG51bWJlciwgZXJyb3I/OiBzdHJpbmcgfT47XG4gIHNldEFjdGl2ZUNoYXQ6IChjaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbCkgPT4gdm9pZDtcbiAgc2VuZE1lc3NhZ2U6IChjb250ZW50OiBzdHJpbmcsIGF0dGFjaG1lbnRzPzogRmlsZVtdKSA9PiBQcm9taXNlPHZvaWQ+O1xuICBtYXJrQXNSZWFkOiAobWVzc2FnZUlkczogc3RyaW5nW10pID0+IHZvaWQ7XG4gIHN0YXJ0VHlwaW5nOiAoKSA9PiB2b2lkO1xuICBzdG9wVHlwaW5nOiAoKSA9PiB2b2lkO1xuICBsb2FkTW9yZU1lc3NhZ2VzOiAoKSA9PiBQcm9taXNlPHZvaWQ+O1xuICByZXRyeUZpbGVVcGxvYWQ6IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4gdm9pZDtcbiAgY2FuY2VsRmlsZVVwbG9hZDogKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB2b2lkO1xufVxuXG5jb25zdCBDaGF0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2hhdENvbnRleHRUeXBlPih7XG4gIGFjdGl2ZUNoYXQ6IG51bGwsXG4gIG1lc3NhZ2VzOiBbXSxcbiAgcm9vbXM6IFtdLFxuICBvbmxpbmVVc2Vyczoge30sXG4gIHVzZXJzOiBbXSxcbiAgdHlwaW5nVXNlcnM6IHt9LFxuICBpc0xvYWRpbmc6IHRydWUsXG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBmYWxzZSxcbiAgdW5yZWFkTWVzc2FnZXM6IHt9LFxuICB1cGxvYWRpbmdGaWxlczoge30sXG4gIHNldEFjdGl2ZUNoYXQ6ICgpID0+IHt9LFxuICBzZW5kTWVzc2FnZTogYXN5bmMgKCkgPT4ge30sXG4gIG1hcmtBc1JlYWQ6ICgpID0+IHt9LFxuICBzdGFydFR5cGluZzogKCkgPT4ge30sXG4gIHN0b3BUeXBpbmc6ICgpID0+IHt9LFxuICBsb2FkTW9yZU1lc3NhZ2VzOiBhc3luYyAoKSA9PiB7fSxcbiAgcmV0cnlGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbiAgY2FuY2VsRmlsZVVwbG9hZDogKCkgPT4ge30sXG59KTtcblxuZXhwb3J0IGNvbnN0IHVzZUNoYXQgPSAoKSA9PiB1c2VDb250ZXh0KENoYXRDb250ZXh0KTtcblxuZXhwb3J0IGNvbnN0IENoYXRQcm92aWRlcjogUmVhY3QuRkM8eyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCB7IHVzZXIsIGlzQXV0aGVudGljYXRlZCB9ID0gdXNlQXV0aCgpO1xuICBjb25zdCBbYWN0aXZlQ2hhdCwgc2V0QWN0aXZlQ2hhdF0gPSB1c2VTdGF0ZTx7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGU8TWVzc2FnZVtdPihbXSk7XG4gIGNvbnN0IFtyb29tcywgc2V0Um9vbXNdID0gdXNlU3RhdGU8Um9vbVtdPihbXSk7XG4gIGNvbnN0IFt1c2Vycywgc2V0VXNlcnNdID0gdXNlU3RhdGU8VXNlcltdPihbXSk7XG4gIGNvbnN0IFtvbmxpbmVVc2Vycywgc2V0T25saW5lVXNlcnNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgYm9vbGVhbj4+KHt9KTtcbiAgY29uc3QgW3R5cGluZ1VzZXJzLCBzZXRUeXBpbmdVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuIHwgc3RyaW5nPj4oe30pO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtpc0xvYWRpbmdNZXNzYWdlcywgc2V0SXNMb2FkaW5nTWVzc2FnZXNdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbc29ja2V0Q29ubmVjdGVkLCBzZXRTb2NrZXRDb25uZWN0ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbdW5yZWFkTWVzc2FnZXMsIHNldFVucmVhZE1lc3NhZ2VzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIG51bWJlcj4+KHt9KTtcbiAgY29uc3QgW3VwbG9hZGluZ0ZpbGVzLCBzZXRVcGxvYWRpbmdGaWxlc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCB7IHByb2dyZXNzOiBudW1iZXIsIGVycm9yPzogc3RyaW5nIH0+Pih7fSk7XG4gIGNvbnN0IFtzZWxlY3RlZEZpbGUsIHNldFNlbGVjdGVkRmlsZV0gPSB1c2VTdGF0ZTxGaWxlIHwgbnVsbD4obnVsbCk7XG4gIFxuICBjb25zdCBzb2NrZXRSZWYgPSB1c2VSZWY8U29ja2V0IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IGN1cnJlbnRBY3RpdmVDaGF0UmVmID0gdXNlUmVmKGFjdGl2ZUNoYXQpO1xuICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XG4gIFxuICAvLyBLZWVwIHRoZSByZWYgaW4gc3luYyB3aXRoIHRoZSBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQgPSBhY3RpdmVDaGF0O1xuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gIFxuICAvLyBJbml0aWFsaXplIHNvY2tldCBjb25uZWN0aW9uIHdoZW4gYXV0aGVudGljYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkIHx8ICF1c2VyKSB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIFxuICAgIGlmICghdG9rZW4pIHJldHVybjtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKEFQSV9VUkwsIHtcbiAgICAgIGF1dGg6IHsgdG9rZW4gfSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgIC8vIEF1bWVudGFyIGVsIHRpZW1wbyBkZSBlc3BlcmEgcGFyYSBwZXJtaXRpciBlbnbDrW8gZGUgYXJjaGl2b3MgZ3JhbmRlc1xuICAgICAgdGltZW91dDogNjAwMDAgLy8gYXVtZW50YXIgZWwgdGllbXBvIGRlIGVzcGVyYSBhIDYwIHNlZ3VuZG9zXG4gICAgfSk7XG4gICAgXG4gICAgLy8gU29ja2V0IGV2ZW50IGxpc3RlbmVyc1xuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZCh0cnVlKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbmV3X21lc3NhZ2UnLCAobWVzc2FnZTogTWVzc2FnZSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICBcbiAgICAgIC8vIElkZW50aWZpY2FyIGxhIGNsYXZlIGRlIGNoYXQgcGFyYSBzZWd1aW1pZW50byBkZSBub3RpZmljYWNpb25lc1xuICAgICAgbGV0IGNoYXRLZXkgPSAnJztcbiAgICAgIGlmIChtZXNzYWdlLnJvb20pIHtcbiAgICAgICAgY2hhdEtleSA9IGByb29tXyR7bWVzc2FnZS5yb29tfWA7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyLl9pZCAhPT0gdXNlci5pZCkge1xuICAgICAgICBjaGF0S2V5ID0gYHVzZXJfJHttZXNzYWdlLnNlbmRlci5faWR9YDtcbiAgICAgIH0gZWxzZSBpZiAobWVzc2FnZS5yZWNpcGllbnQpIHtcbiAgICAgICAgY2hhdEtleSA9IGB1c2VyXyR7bWVzc2FnZS5yZWNpcGllbnR9YDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU29sbyBhZ3JlZ2FyIGVsIG1lbnNhamUgc2kgZXMgcmVsZXZhbnRlIHBhcmEgZWwgY2hhdCBhY3Rpdm9cbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBcbiAgICAgICAgICAoKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gYWN0aXZlQ2hhdC5pZCAmJiBtZXNzYWdlLnJlY2lwaWVudCA9PT0gdXNlci5pZCkgfHwgXG4gICAgICAgICAgIChtZXNzYWdlLnNlbmRlci5faWQgPT09IHVzZXIuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IGFjdGl2ZUNoYXQuaWQpKSkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBtZXNzYWdlLnJvb20gPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZV0pO1xuICAgICAgfSBcbiAgICAgIC8vIFNpIGVsIG1lbnNhamUgbm8gZXMgcGFyYSBlbCBjaGF0IGFjdGl2byB5IG5vIGZ1ZSBlbnZpYWRvIHBvciBlbCB1c3VhcmlvIGFjdHVhbCwgaW5jcmVtZW50YXIgY29udGFkb3JcbiAgICAgIGVsc2UgaWYgKG1lc3NhZ2Uuc2VuZGVyLl9pZCAhPT0gdXNlci5pZCAmJiBjaGF0S2V5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdOZXcgbWVzc2FnZSBub3RpZmljYXRpb246JywgY2hhdEtleSwgbWVzc2FnZSk7XG4gICAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIFtjaGF0S2V5XTogKHByZXZbY2hhdEtleV0gfHwgMCkgKyAxXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndXNlcl9zdGF0dXNfY2hhbmdlJywgKHsgdXNlcklkLCBpc09ubGluZSB9KSA9PiB7XG4gICAgICBzZXRPbmxpbmVVc2VycyhwcmV2ID0+ICh7IC4uLnByZXYsIFt1c2VySWRdOiBpc09ubGluZSB9KSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3R5cGluZ19pbmRpY2F0b3InLCAoZGF0YTogeyB1c2VySWQ6IHN0cmluZywgdXNlck5hbWU6IHN0cmluZywgaXNUeXBpbmc6IGJvb2xlYW4sIHJvb21JZD86IHN0cmluZywgc2VuZGVySWQ/OiBzdHJpbmcgfSkgPT4ge1xuICAgICAgY29uc3QgYWN0aXZlQ2hhdCA9IGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgZGF0YS5zZW5kZXJJZCA9PT0gYWN0aXZlQ2hhdC5pZCkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBkYXRhLnJvb21JZCA9PT0gYWN0aXZlQ2hhdC5pZClcbiAgICAgICkge1xuICAgICAgICAvLyBBbG1hY2VuYXIgbm9tYnJlIGVuIGx1Z2FyIGRlIHNvbG8gbGEgYmFuZGVyYSBib29sZWFuYVxuICAgICAgICBzZXRUeXBpbmdVc2VycyhwcmV2ID0+ICh7IFxuICAgICAgICAgIC4uLnByZXYsIFxuICAgICAgICAgIFtkYXRhLnVzZXJJZF06IGRhdGEuaXNUeXBpbmcgPyBkYXRhLnVzZXJOYW1lIDogZmFsc2UgXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignbWVzc2FnZV9yZWFkJywgKHsgbWVzc2FnZUlkIH0pID0+IHtcbiAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgICBtc2cuX2lkID09PSBtZXNzYWdlSWQgPyB7IC4uLm1zZywgaXNSZWFkOiB0cnVlIH0gOiBtc2dcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgbmV3IHJvb20gY3JlYXRpb25zXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19yb29tJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdOZXcgcm9vbSByZWNlaXZlZDonLCByb29tKTtcbiAgICAgIHNldFJvb21zKHByZXYgPT4ge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm9vbSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdHMgPSBwcmV2LnNvbWUociA9PiByLl9pZCA9PT0gcm9vbS5faWQpO1xuICAgICAgICBpZiAoZXhpc3RzKSByZXR1cm4gcHJldjtcbiAgICAgICAgcmV0dXJuIFsuLi5wcmV2LCByb29tXTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEhhbmRsZSByb29tIHVwZGF0ZXMgKG1lbWJlcnMgYWRkZWQvcmVtb3ZlZClcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigncm9vbV91cGRhdGVkJywgKHJvb206IFJvb20pID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdSb29tIHVwZGF0ZWQ6Jywgcm9vbSk7XG4gICAgICBpZiAocm9vbS5yZW1vdmVkKSB7XG4gICAgICAgIC8vIElmIHRoaXMgcm9vbSB3YXMgcmVtb3ZlZCBmb3IgdGhpcyB1c2VyLCByZW1vdmUgaXQgZnJvbSB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYuZmlsdGVyKHIgPT4gci5faWQgIT09IHJvb20uX2lkKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiBhY3RpdmUgY2hhdCBpcyB0aGlzIHJvb20sIGNsZWFyIGl0XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGFjdGl2ZUNoYXQuaWQgPT09IHJvb20uX2lkKSB7XG4gICAgICAgICAgc2V0QWN0aXZlQ2hhdChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsaXN0XG4gICAgICAgIHNldFJvb21zKHByZXYgPT4gcHJldi5tYXAociA9PiByLl9pZCA9PT0gcm9vbS5faWQgPyByb29tIDogcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCdkaXNjb25uZWN0JywgKCkgPT4ge1xuICAgICAgY29uc29sZS5sb2coJ1NvY2tldCBkaXNjb25uZWN0ZWQnKTtcbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHNldFNvY2tldENvbm5lY3RlZChmYWxzZSk7XG4gICAgfTtcbiAgfSwgW2lzQXV0aGVudGljYXRlZCwgdXNlciwgQVBJX1VSTF0pO1xuICBcbiAgLy8gTG9hZCBpbml0aWFsIGRhdGE6IHVzZXJzIGFuZCByb29tc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmZXRjaEluaXRpYWxEYXRhID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgW3VzZXJzUmVzcG9uc2UsIHJvb21zUmVzcG9uc2VdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS91c2Vyc2ApLFxuICAgICAgICAgIGF4aW9zLmdldChgJHtBUElfVVJMfS9yb29tcy9teWApXG4gICAgICAgIF0pO1xuICAgICAgICBcbiAgICAgICAgc2V0VXNlcnModXNlcnNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgc2V0Um9vbXMocm9vbXNSZXNwb25zZS5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFNldCBpbml0aWFsIG9ubGluZSBzdGF0dXNcbiAgICAgICAgY29uc3QgaW5pdGlhbE9ubGluZVN0YXR1czogUmVjb3JkPHN0cmluZywgYm9vbGVhbj4gPSB7fTtcbiAgICAgICAgdXNlcnNSZXNwb25zZS5kYXRhLmZvckVhY2goKHVzZXI6IFVzZXIpID0+IHtcbiAgICAgICAgICBpbml0aWFsT25saW5lU3RhdHVzW3VzZXIuX2lkIV0gPSB1c2VyLmlzT25saW5lIHx8IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0T25saW5lVXNlcnMoaW5pdGlhbE9ubGluZVN0YXR1cyk7XG4gICAgICAgIFxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgaW5pdGlhbCBkYXRhOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaEluaXRpYWxEYXRhKCk7XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIEN1YW5kbyBzZSBpbmljaWEgZWwgc29ja2V0IHkgc2UgY29uZWN0YSwgc29saWNpdGFtb3MgZWwgZXN0YWRvIGFjdHVhbCBkZSBtZW5zYWplcyBubyBsZcOtZG9zXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHNvY2tldENvbm5lY3RlZCAmJiBzb2NrZXRSZWYuY3VycmVudCAmJiB1c2VyKSB7XG4gICAgICAvLyBTb2xpY2l0YXIgbWVuc2FqZXMgbm8gbGXDrWRvcyBhbCBzZXJ2aWRvclxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnZ2V0X3VucmVhZF9tZXNzYWdlcycpO1xuICAgICAgXG4gICAgICAvLyBFc2N1Y2hhciBsYSByZXNwdWVzdGEgY29uIGVsIHJlY3VlbnRvIGRlIG1lbnNhamVzIG5vIGxlw61kb3NcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1bnJlYWRfbWVzc2FnZXNfY291bnQnLCAodW5yZWFkQ291bnRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCB1bnJlYWQgY291bnRzOicsIHVucmVhZENvdW50cyk7XG4gICAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHVucmVhZENvdW50cyk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/Lm9mZigndW5yZWFkX21lc3NhZ2VzX2NvdW50Jyk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwgW3NvY2tldENvbm5lY3RlZCwgdXNlcl0pO1xuXG4gIC8vIEFzZWd1cmFyc2UgZGUgcXVlIGxvcyBtZW5zYWplcyBzZSBtYXJxdWVuIGNvbW8gbGXDrWRvcyBjdWFuZG8gc2UgYWJyZSB1biBjaGF0XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGFjdGl2ZUNoYXQgJiYgc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgIC8vIENyZWFyIHVuYSBjbGF2ZSBwYXJhIGVsIGNoYXQgYWN0dWFsXG4gICAgICBjb25zdCBjaGF0S2V5ID0gYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgXG4gICAgICAgID8gYHVzZXJfJHthY3RpdmVDaGF0LmlkfWAgXG4gICAgICAgIDogYHJvb21fJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICBcbiAgICAgIC8vIFJlc2V0ZWFyIGVsIGNvbnRhZG9yIGRlIG1lbnNhamVzIG5vIGxlw61kb3MgcGFyYSBlc3RlIGNoYXRcbiAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2NoYXRLZXldOiAwXG4gICAgICB9KSk7XG4gICAgICBcbiAgICAgIC8vIE5vdGlmaWNhciBhbCBzZXJ2aWRvciBxdWUgbG9zIG1lbnNhamVzIHNlIGhhbiBsZcOtZG9cbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ21hcmtfbWVzc2FnZXNfcmVhZCcsIHtcbiAgICAgICAgY2hhdElkOiBhY3RpdmVDaGF0LmlkLFxuICAgICAgICBjaGF0VHlwZTogYWN0aXZlQ2hhdC50eXBlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFthY3RpdmVDaGF0XSk7XG4gIFxuICAvLyBGdW5jacOzbiBwYXJhIG1hbmVqYXIgZWwgY2FtYmlvIGRlIGNoYXQgYWN0aXZvXG4gIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UgPSAoY2hhdDogeyB0eXBlOiAncHJpdmF0ZScgfCAncm9vbScsIGlkOiBzdHJpbmcgfSB8IG51bGwpID0+IHtcbiAgICAvLyBMaW1waWFyIGxhcyBub3RpZmljYWNpb25lcyBubyBsZcOtZGFzIGN1YW5kbyBzZSBhY3RpdmEgdW4gY2hhdFxuICAgIGlmIChjaGF0KSB7XG4gICAgICBjb25zdCBjaGF0S2V5ID0gY2hhdC50eXBlID09PSAncHJpdmF0ZScgPyBgdXNlcl8ke2NoYXQuaWR9YCA6IGByb29tXyR7Y2hhdC5pZH1gO1xuICAgICAgc2V0VW5yZWFkTWVzc2FnZXMocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBbY2hhdEtleV06IDBcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgXG4gICAgc2V0QWN0aXZlQ2hhdChjaGF0KTtcbiAgfTtcblxuICAvLyBDYXJnYXIgbWVuc2FqZXMgY3VhbmRvIHNlIHNlbGVjY2lvbmEgdW4gY2hhdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhdXNlciB8fCAhaXNBdXRoZW50aWNhdGVkKSB7XG4gICAgICBzZXRNZXNzYWdlcyhbXSk7XG4gICAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyhmYWxzZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHNldElzTG9hZGluZ01lc3NhZ2VzKHRydWUpO1xuICAgIFxuICAgIGNvbnN0IGZldGNoTWVzc2FnZXMgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgZW5kcG9pbnQgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEpvaW4gdXNlciByb29tIGZvciBkaXJlY3QgbWVzc2FnZXNcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyB1c2VySWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9yb29tLyR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEpvaW4gcm9vbVxuICAgICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5lbWl0KCdqb2luX3Jvb20nLCB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoZW5kcG9pbnQpO1xuICAgICAgICBzZXRNZXNzYWdlcyhyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgXG4gICAgICAgIC8vIE1hcmNhciBsb3MgbWVuc2FqZXMgY29tbyBsZcOtZG9zIGVuIGVsIHNlcnZpZG9yXG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbWFya19tZXNzYWdlc19yZWFkJywge1xuICAgICAgICAgICAgY2hhdFR5cGU6IGFjdGl2ZUNoYXQudHlwZSxcbiAgICAgICAgICAgIGNoYXRJZDogYWN0aXZlQ2hhdC5pZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBtZXNzYWdlczonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaE1lc3NhZ2VzKCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIC8vIENsZWFuIHVwIC0gbGVhdmUgcm9vbXNcbiAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdyb29tJykge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbGVhdmVfcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFthY3RpdmVDaGF0LCB1c2VyLCBpc0F1dGhlbnRpY2F0ZWQsIEFQSV9VUkxdKTtcbiAgXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgYXR0YWNobWVudHM6IEZpbGVBdHRhY2htZW50W10gPSBbXSkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhaXNBdXRoZW50aWNhdGVkIHx8ICFzb2NrZXRSZWYuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEluaWNpYWxpemFyIGVzdGFkbyBkZSBjYXJnYSBwYXJhIGNhZGEgYXJjaGl2b1xuICAgIGNvbnN0IG5ld1VwbG9hZGluZ0ZpbGVzID0geyAuLi51cGxvYWRpbmdGaWxlcyB9O1xuICAgIFxuICAgIC8vIFBhcmEgYXJjaGl2b3MgZ3JhbmRlcywgZXNwZWNpYWxtZW50ZSB2aWRlb3MsIGxvcyBlbnZpYW1vcyB1c2FuZG8gZWwgbnVldm8gZW5kcG9pbnQgb3B0aW1pemFkb1xuICAgIGxldCBwcm9jZXNzZWRBdHRhY2htZW50czogRmlsZUF0dGFjaG1lbnRbXSA9IFtdO1xuXG4gICAgLy8gQXNpZ25hciBJRHMgdGVtcG9yYWxlcyBwYXJhIHNlZ3VpbWllbnRvXG4gICAgY29uc3QgYXR0YWNobWVudHNXaXRoSWRzID0gYXR0YWNobWVudHMubWFwKGF0dGFjaG1lbnQgPT4gKHtcbiAgICAgIC4uLmF0dGFjaG1lbnQsXG4gICAgICB0ZW1wSWQ6IGB0ZW1wLSR7RGF0ZS5ub3coKX0tJHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgOSl9YFxuICAgIH0pKTtcblxuICAgIC8vIEVzdGFibGVjZXIgZWwgZXN0YWRvIGluaWNpYWwgZGUgY2FyZ2EgcGFyYSBjYWRhIGFyY2hpdm9cbiAgICBhdHRhY2htZW50c1dpdGhJZHMuZm9yRWFjaChhdHRhY2htZW50ID0+IHtcbiAgICAgIG5ld1VwbG9hZGluZ0ZpbGVzW2F0dGFjaG1lbnQudGVtcElkXSA9IHsgcHJvZ3Jlc3M6IDAgfTtcbiAgICB9KTtcbiAgICBzZXRVcGxvYWRpbmdGaWxlcyhuZXdVcGxvYWRpbmdGaWxlcyk7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChjb25zdCBhdHRhY2htZW50IG9mIGF0dGFjaG1lbnRzV2l0aElkcykge1xuICAgICAgICAvLyBBY3R1YWxpemFyIHByb2dyZXNvXG4gICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIFthdHRhY2htZW50LnRlbXBJZF06IHsgcHJvZ3Jlc3M6IDEwLCBlcnJvcjogdW5kZWZpbmVkIH1cbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIFNpIGVzIHVuIHZpZGVvIG8gYXJjaGl2byBncmFuZGUsIGxvIGVudmlhbW9zIHVzYW5kbyBlbCBudWV2byBlbmRwb2ludCBvcHRpbWl6YWRvXG4gICAgICAgIGlmIChhdHRhY2htZW50LmZpbGVUeXBlID09PSBGaWxlVHlwZS5WSURFTyB8fCBcbiAgICAgICAgICAgIChhdHRhY2htZW50LnNpemUgJiYgYXR0YWNobWVudC5zaXplID4gNSAqIDEwMjQgKiAxMDI0KSkge1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWJpZW5kbyBhcmNoaXZvIGdyYW5kZSAoJHthdHRhY2htZW50LmZpbGVUeXBlfSk6ICR7YXR0YWNobWVudC5maWxlbmFtZX0sIHRhbWHDsW86ICR7YXR0YWNobWVudC5zaXplfSBieXRlc2ApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIENyZWFyIHVuIG9iamV0byBGb3JtRGF0YSBwYXJhIGVudmlhciBlbCBhcmNoaXZvXG4gICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSB0ZW5lbW9zIGRhdG9zIGVuIGJhc2U2NCwgY29udmVydGlybG9zIGEgQmxvYlxuICAgICAgICAgIGlmIChhdHRhY2htZW50LmRhdGEgJiYgYXR0YWNobWVudC5kYXRhLnN0YXJ0c1dpdGgoJ2RhdGE6JykpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhZXIgbG9zIGRhdG9zIGJhc2U2NCAocXVpdGFyIGVsIHByZWZpam8gXCJkYXRhOk1JTUU7YmFzZTY0LFwiKVxuICAgICAgICAgICAgY29uc3QgYmFzZTY0RGF0YSA9IGF0dGFjaG1lbnQuZGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgY29uc3QgYmluYXJ5U3RyaW5nID0gd2luZG93LmF0b2IoYmFzZTY0RGF0YSk7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoW2J5dGVzXSwgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgYmxvYiwgYXR0YWNobWVudC5maWxlbmFtZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChhdHRhY2htZW50LmRhdGEpIHtcbiAgICAgICAgICAgIC8vIFNpIHRlbmVtb3MgZGF0b3MgYmluYXJpb3MgZGlyZWN0b3NcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVDaGFyYWN0ZXJzID0gYXRvYihhdHRhY2htZW50LmRhdGEpO1xuICAgICAgICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSA1MTIpIHtcbiAgICAgICAgICAgICAgY29uc3Qgc2xpY2UgPSBieXRlQ2hhcmFjdGVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIDUxMik7XG4gICAgICAgICAgICAgIGNvbnN0IGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KHNsaWNlLmxlbmd0aCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnl0ZU51bWJlcnNbaV0gPSBzbGljZS5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zdCBieXRlQXJyYXkgPSBuZXcgVWludDhBcnJheShieXRlTnVtYmVycyk7XG4gICAgICAgICAgICAgIGJ5dGVBcnJheXMucHVzaChieXRlQXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBibG9iID0gbmV3IEJsb2IoYnl0ZUFycmF5cywgeyB0eXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlIH0pO1xuICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdmaWxlJywgYmxvYiwgYXR0YWNobWVudC5maWxlbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIEHDsWFkaXIgbWV0YWRhdG9zIGRlbCBhcmNoaXZvXG4gICAgICAgICAgZm9ybURhdGEuYXBwZW5kKCdjb250ZW50VHlwZScsIGF0dGFjaG1lbnQuY29udGVudFR5cGUpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc29cbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBwcm9ncmVzczogMzAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVXNhciBlbCBudWV2byBlbmRwb2ludCBwYXJhIHN1YmlyIGVsIGFyY2hpdm8gZGlyZWN0YW1lbnRlXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vZmlsZS1zdG9yYWdlL3VwbG9hZGAsIGZvcm1EYXRhLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IChwcm9ncmVzc0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudENvbXBsZXRlZCA9IE1hdGgucm91bmQoXG4gICAgICAgICAgICAgICAgICAocHJvZ3Jlc3NFdmVudC5sb2FkZWQgKiA3MCkgLyAocHJvZ3Jlc3NFdmVudC50b3RhbCB8fCAxMDApXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVsIHByb2dyZXNvICgzMCUgYmFzZSArIGhhc3RhIDcwJSBtw6FzIGR1cmFudGUgbGEgY2FyZ2EpXG4gICAgICAgICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMocHJldiA9PiAoe1xuICAgICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICAgIFthdHRhY2htZW50LnRlbXBJZF06IHsgcHJvZ3Jlc3M6IDMwICsgcGVyY2VudENvbXBsZXRlZCwgZXJyb3I6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc3B1ZXN0YSBkZSBjYXJnYTonLCByZXNwb25zZS5kYXRhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmRhdGEgJiYgcmVzcG9uc2UuZGF0YS5maWxlSWQpIHtcbiAgICAgICAgICAgICAgLy8gQXJjaGl2byBzdWJpZG8gY29ycmVjdGFtZW50ZVxuICAgICAgICAgICAgICBwcm9jZXNzZWRBdHRhY2htZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAuLi5hdHRhY2htZW50LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzcG9uc2UuZGF0YS5maWxlSWQsXG4gICAgICAgICAgICAgICAgaXNMYXJnZUZpbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgLy8gRWxpbWluYXIgbG9zIGRhdG9zIGJpbmFyaW9zIHBhcmEgZXZpdGFyIGVudmlhcmxvcyBkZSBudWV2b1xuICAgICAgICAgICAgICAgIGRhdGE6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc28gYSAxMDAlXG4gICAgICAgICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgICAgIFthdHRhY2htZW50LnRlbXBJZF06IHsgcHJvZ3Jlc3M6IDEwMCwgZXJyb3I6IHVuZGVmaW5lZCB9XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2UgcHVkbyBvYnRlbmVyIGVsIElEIGRlbCBhcmNoaXZvJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAodXBsb2FkRXJyb3I6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgc3ViaXIgYXJjaGl2byBncmFuZGU6JywgdXBsb2FkRXJyb3IpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBY3R1YWxpemFyIGVzdGFkbyBjb24gZWwgZXJyb3JcbiAgICAgICAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKHByZXYgPT4gKHtcbiAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBcbiAgICAgICAgICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgICAgICAgICAgZXJyb3I6IHVwbG9hZEVycm9yLm1lc3NhZ2UgfHwgJ0Vycm9yIGFsIHN1YmlyIGVsIGFyY2hpdm8nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQ29udGludWFyIGNvbiBlbCBzaWd1aWVudGUgYXJjaGl2b1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcmEgYXJjaGl2b3MgcGVxdWXDsW9zLCBsb3MgZW52aWFtb3MgY29uIGVsIG1lbnNhamVcbiAgICAgICAgICBwcm9jZXNzZWRBdHRhY2htZW50cy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEFjdHVhbGl6YXIgcHJvZ3Jlc29cbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgICAgW2F0dGFjaG1lbnQudGVtcElkXTogeyBwcm9ncmVzczogODAsIGVycm9yOiB1bmRlZmluZWQgfVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgYXR0YWNobWVudHM6IHByb2Nlc3NlZEF0dGFjaG1lbnRzLFxuICAgICAgICAuLi4oYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgPyB7IHJlY2lwaWVudElkOiBhY3RpdmVDaGF0LmlkIH0gOiB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KSxcbiAgICAgIH07XG5cbiAgICAgIC8vIEVudmlhciBlbCBtZW5zYWplIGEgdHJhdsOpcyBkZWwgc29ja2V0XG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdzZW5kX21lc3NhZ2UnLCBtZXNzYWdlRGF0YSwgKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAvLyDDiXhpdG8gLSBxdWl0YXIgYXJjaGl2b3MgZGVsIGVzdGFkbyBkZSBjYXJnYVxuICAgICAgICAgIGNvbnN0IGZpbmFsUHJvZ3Jlc3MgPSB7IC4uLnVwbG9hZGluZ0ZpbGVzIH07XG4gICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLmZvckVhY2goYXR0YWNobWVudCA9PiB7XG4gICAgICAgICAgICBkZWxldGUgZmluYWxQcm9ncmVzc1thdHRhY2htZW50LnRlbXBJZF07XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc2V0VXBsb2FkaW5nRmlsZXMoZmluYWxQcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRXJyb3IgLSBhY3R1YWxpemFyIGVzdGFkbyBjb24gZWwgZXJyb3JcbiAgICAgICAgICBjb25zdCBlcnJvclByb2dyZXNzID0geyAuLi51cGxvYWRpbmdGaWxlcyB9O1xuICAgICAgICAgIGF0dGFjaG1lbnRzV2l0aElkcy5mb3JFYWNoKGF0dGFjaG1lbnQgPT4ge1xuICAgICAgICAgICAgZXJyb3JQcm9ncmVzc1thdHRhY2htZW50LnRlbXBJZF0gPSB7IFxuICAgICAgICAgICAgICBwcm9ncmVzczogMCwgXG4gICAgICAgICAgICAgIGVycm9yOiByZXNwb25zZS5lcnJvciB8fCAnRXJyb3IgYWwgZW52aWFyIGVsIG1lbnNhamUnIFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlcyhlcnJvclByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIExpbXBpYXIgZm9ybXVsYXJpbyBkZXNwdcOpcyBkZSBlbnZpYXJcbiAgICAgIGlmIChmaWxlSW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICBmaWxlSW5wdXRSZWYuY3VycmVudC52YWx1ZSA9ICcnO1xuICAgICAgfVxuICAgICAgc2V0U2VsZWN0ZWRGaWxlKG51bGwpO1xuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFsIHByb2Nlc2FyIGFyY2hpdm9zOicsIGVycm9yKTtcbiAgICAgIC8vIEFjdHVhbGl6YXIgZXN0YWRvIGNvbiBlbCBlcnJvclxuICAgICAgY29uc3QgZXJyb3JQcm9ncmVzcyA9IHsgLi4udXBsb2FkaW5nRmlsZXMgfTtcbiAgICAgIGF0dGFjaG1lbnRzV2l0aElkcy5mb3JFYWNoKGF0dGFjaG1lbnQgPT4ge1xuICAgICAgICBlcnJvclByb2dyZXNzW2F0dGFjaG1lbnQudGVtcElkXSA9IHsgXG4gICAgICAgICAgcHJvZ3Jlc3M6IDAsIFxuICAgICAgICAgIGVycm9yOiBlcnJvci5tZXNzYWdlIHx8ICdFcnJvciBhbCBwcm9jZXNhciBhcmNoaXZvcycgXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHNldFVwbG9hZGluZ0ZpbGVzKGVycm9yUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGNyZWF0ZVJvb20gPSBhc3luYyAobmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbiA9ICcnLCBpc1ByaXZhdGUgPSBmYWxzZSwgbWVtYmVyczogc3RyaW5nW10gPSBbXSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXNgLCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBpc1ByaXZhdGUsXG4gICAgICAgIG1lbWJlcnMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gTm8gbmVlZCB0byBtYW51YWxseSBhZGQgdG8gcm9vbXMgYXJyYXksIHRoZSBzb2NrZXQgZXZlbnQgd2lsbCBoYW5kbGUgaXRcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHVwZGF0ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVwZGF0ZURhdGE6IHsgbmFtZT86IHN0cmluZzsgZGVzY3JpcHRpb24/OiBzdHJpbmc7IGltYWdlPzogc3RyaW5nOyBpc1ByaXZhdGU/OiBib29sZWFuIH0pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wdXQoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9YCwgdXBkYXRlRGF0YSk7XG4gICAgICBcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbG9jYWwgc3RhdGUgdG8gaW1tZWRpYXRlbHkgcmVmbGVjdCBjaGFuZ2VzXG4gICAgICBzZXRSb29tcyhwcmV2Um9vbXMgPT4gXG4gICAgICAgIHByZXZSb29tcy5tYXAocm9vbSA9PiBcbiAgICAgICAgICByb29tLl9pZCA9PT0gcm9vbUlkID8geyAuLi5yb29tLCAuLi5kYXRhIH0gOiByb29tXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGpvaW5Sb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIGFkZGluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1qb2luaW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igam9pbmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IGxlYXZlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiByZW1vdmluZyBvdGhlcnMpXG4gICAgICAvLyBPdGhlcndpc2UgdXNlIGN1cnJlbnQgdXNlcidzIElEIChmb3Igc2VsZi1sZWF2aW5nKVxuICAgICAgY29uc3QgdGFyZ2V0VXNlcklkID0gdXNlcklkIHx8IHVzZXIhLmlkO1xuICAgICAgYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsZWF2aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgc2V0VHlwaW5nID0gKGlzVHlwaW5nOiBib29sZWFuKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFzb2NrZXRSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IHR5cGluZ0RhdGEgPSB7XG4gICAgICBpc1R5cGluZyxcbiAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgIH07XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgndHlwaW5nJywgdHlwaW5nRGF0YSk7XG4gIH07XG4gIFxuICBjb25zdCBjbGVhckNoYXRIaXN0b3J5ID0gYXN5bmMgKHJlY2lwaWVudElkOiBzdHJpbmcpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vY2hhdHMvZGlyZWN0LyR7cmVjaXBpZW50SWR9YCk7XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBtZXNzYWdlOiAnQ2hhdCBoaXN0b3J5IGNsZWFyZWQgc3VjY2Vzc2Z1bGx5JyB9O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjbGVhcmluZyBjaGF0IGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIG1lc3NhZ2U6ICdGYWlsZWQgdG8gY2xlYXIgY2hhdCBoaXN0b3J5JyB9O1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHJldHJ5RmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIC8vIEltcGxlbWVudGFyIGxhIGzDs2dpY2EgcGFyYSByZWludGVudGFyIGxhIHN1YmlkYSBkZSBhcmNoaXZvc1xuICB9O1xuICBcbiAgY29uc3QgY2FuY2VsRmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIC8vIEltcGxlbWVudGFyIGxhIGzDs2dpY2EgcGFyYSBjYW5jZWxhciBsYSBzdWJpZGEgZGUgYXJjaGl2b3NcbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBhY3RpdmVDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICByb29tcyxcbiAgICAgIHVzZXJzLFxuICAgICAgb25saW5lVXNlcnMsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIGlzTG9hZGluZ01lc3NhZ2VzLFxuICAgICAgdW5yZWFkTWVzc2FnZXMsXG4gICAgICB1cGxvYWRpbmdGaWxlcyxcbiAgICAgIHNldEFjdGl2ZUNoYXQ6IGhhbmRsZUFjdGl2ZUNoYXRDaGFuZ2UsXG4gICAgICBzZW5kTWVzc2FnZSxcbiAgICAgIGNyZWF0ZVJvb20sXG4gICAgICB1cGRhdGVSb29tLFxuICAgICAgam9pblJvb20sXG4gICAgICBsZWF2ZVJvb20sXG4gICAgICBzZXRUeXBpbmcsXG4gICAgICBjbGVhckNoYXRIaXN0b3J5LFxuICAgICAgcmV0cnlGaWxlVXBsb2FkLFxuICAgICAgY2FuY2VsRmlsZVVwbG9hZCxcbiAgICB9fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NoYXRDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJpbyIsImF4aW9zIiwidXNlQXV0aCIsIkZpbGVUeXBlIiwiQ2hhdENvbnRleHQiLCJhY3RpdmVDaGF0IiwibWVzc2FnZXMiLCJyb29tcyIsIm9ubGluZVVzZXJzIiwidXNlcnMiLCJ0eXBpbmdVc2VycyIsImlzTG9hZGluZyIsImlzTG9hZGluZ01lc3NhZ2VzIiwidW5yZWFkTWVzc2FnZXMiLCJ1cGxvYWRpbmdGaWxlcyIsInNldEFjdGl2ZUNoYXQiLCJzZW5kTWVzc2FnZSIsIm1hcmtBc1JlYWQiLCJzdGFydFR5cGluZyIsInN0b3BUeXBpbmciLCJsb2FkTW9yZU1lc3NhZ2VzIiwicmV0cnlGaWxlVXBsb2FkIiwiY2FuY2VsRmlsZVVwbG9hZCIsInVzZUNoYXQiLCJDaGF0UHJvdmlkZXIiLCJjaGlsZHJlbiIsInVzZXIiLCJpc0F1dGhlbnRpY2F0ZWQiLCJzZXRNZXNzYWdlcyIsInNldFJvb21zIiwic2V0VXNlcnMiLCJzZXRPbmxpbmVVc2VycyIsInNldFR5cGluZ1VzZXJzIiwic2V0SXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nTWVzc2FnZXMiLCJzb2NrZXRDb25uZWN0ZWQiLCJzZXRTb2NrZXRDb25uZWN0ZWQiLCJzZXRVbnJlYWRNZXNzYWdlcyIsInNldFVwbG9hZGluZ0ZpbGVzIiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwic29ja2V0UmVmIiwiY3VycmVudEFjdGl2ZUNoYXRSZWYiLCJmaWxlSW5wdXRSZWYiLCJjdXJyZW50IiwiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZGlzY29ubmVjdCIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImF1dGgiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ0aW1lb3V0Iiwib24iLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImNoYXRLZXkiLCJyb29tIiwic2VuZGVyIiwiX2lkIiwiaWQiLCJyZWNpcGllbnQiLCJ0eXBlIiwicHJldiIsInVzZXJJZCIsImlzT25saW5lIiwiZGF0YSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJ1c2VyTmFtZSIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImZldGNoSW5pdGlhbERhdGEiLCJ1c2Vyc1Jlc3BvbnNlIiwicm9vbXNSZXNwb25zZSIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJpbml0aWFsT25saW5lU3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiZW1pdCIsInVucmVhZENvdW50cyIsIm9mZiIsImNoYXRJZCIsImNoYXRUeXBlIiwiaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSIsImNoYXQiLCJmZXRjaE1lc3NhZ2VzIiwiZW5kcG9pbnQiLCJyZXNwb25zZSIsImxlbmd0aCIsImNvbnRlbnQiLCJhdHRhY2htZW50cyIsIm5ld1VwbG9hZGluZ0ZpbGVzIiwicHJvY2Vzc2VkQXR0YWNobWVudHMiLCJhdHRhY2htZW50c1dpdGhJZHMiLCJhdHRhY2htZW50IiwidGVtcElkIiwiTWF0aCIsIkRhdGUiLCJub3ciLCJyYW5kb20iLCJ0b1N0cmluZyIsInN1YnN0cmluZyIsInByb2dyZXNzIiwidW5kZWZpbmVkIiwiZmlsZVR5cGUiLCJzaXplIiwiZmlsZW5hbWUiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwic3RhcnRzV2l0aCIsImJhc2U2NERhdGEiLCJzcGxpdCIsImJpbmFyeVN0cmluZyIsIndpbmRvdyIsImF0b2IiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJpIiwiY2hhckNvZGVBdCIsImJsb2IiLCJCbG9iIiwiY29udGVudFR5cGUiLCJhcHBlbmQiLCJieXRlQ2hhcmFjdGVycyIsImJ5dGVBcnJheXMiLCJvZmZzZXQiLCJzbGljZSIsImJ5dGVOdW1iZXJzIiwiQXJyYXkiLCJieXRlQXJyYXkiLCJwdXNoIiwicG9zdCIsImhlYWRlcnMiLCJvblVwbG9hZFByb2dyZXNzIiwicHJvZ3Jlc3NFdmVudCIsInBlcmNlbnRDb21wbGV0ZWQiLCJyb3VuZCIsImxvYWRlZCIsInRvdGFsIiwiZmlsZUlkIiwiaXNMYXJnZUZpbGUiLCJFcnJvciIsInVwbG9hZEVycm9yIiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsInN1Y2Nlc3MiLCJmaW5hbFByb2dyZXNzIiwiZXJyb3JQcm9ncmVzcyIsInZhbHVlIiwiY3JlYXRlUm9vbSIsIm5hbWUiLCJkZXNjcmlwdGlvbiIsImlzUHJpdmF0ZSIsIm1lbWJlcnMiLCJ1cGRhdGVSb29tIiwidXBkYXRlRGF0YSIsInB1dCIsInByZXZSb29tcyIsImpvaW5Sb29tIiwidGFyZ2V0VXNlcklkIiwibGVhdmVSb29tIiwiZGVsZXRlIiwic2V0VHlwaW5nIiwidHlwaW5nRGF0YSIsImNsZWFyQ2hhdEhpc3RvcnkiLCJmaWxlIiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});