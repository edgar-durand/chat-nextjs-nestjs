"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    createRoom: async ()=>({\n            _id: \"\",\n            name: \"\",\n            creator: {\n                id: \"\",\n                _id: \"\",\n                name: \"\",\n                email: \"\",\n                avatar: \"\"\n            },\n            members: [],\n            isPrivate: false,\n            createdAt: \"\"\n        }),\n    updateRoom: async ()=>({\n            _id: \"\",\n            name: \"\",\n            creator: {\n                id: \"\",\n                _id: \"\",\n                name: \"\",\n                email: \"\",\n                avatar: \"\"\n            },\n            members: [],\n            isPrivate: false,\n            createdAt: \"\"\n        }),\n    joinRoom: async ()=>{},\n    leaveRoom: async ()=>{},\n    setTyping: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Only add the message if it's relevant to the active chat\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user._id || message.sender._id === user._id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Load messages when activeChat changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated || !socketConnected) {\n            setMessages([]);\n            return;\n        }\n        const fetchMessages = async ()=>{\n            try {\n                setIsLoading(true);\n                let response;\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id));\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id));\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                setMessages(response.data);\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchMessages();\n        // Clear typing indicator when changing chats\n        setTypingUsers({});\n        return ()=>{\n            // Leave previous chat room\n            if (activeChat.type === \"private\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    userId: activeChat.id\n                });\n            } else {\n                var _socketRef_current1;\n                (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        isAuthenticated,\n        API_URL,\n        socketConnected\n    ]);\n    const sendMessage = async (content)=>{\n        if (!activeChat || !user || !socketRef.current) return;\n        try {\n            const messageData = {\n                content,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            socketRef.current.emit(\"send_message\", messageData);\n        } catch (error) {\n            console.error(\"Error sending message:\", error);\n            throw error;\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            setActiveChat,\n            sendMessage,\n            createRoom,\n            updateRoom,\n            joinRoom,\n            leaveRoom,\n            setTyping\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 388,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"+6U8vaGQK085u+xjm+cgIhfHtF4=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QThDO1FBQ2hELEVBQUUsT0FBT1osT0FBTztZQUNkL0IsUUFBUStCLEtBQUssQ0FBQyx1QkFBdUJBO1lBQ3JDLE1BQU1BO1FBQ1I7SUFDRjtJQUVBLE1BQU0zRCxZQUFZLENBQUN5QztRQUNqQixJQUFJLENBQUMvRCxjQUFjLENBQUNvQyxVQUFVRSxPQUFPLEVBQUU7UUFFdkMsTUFBTXlELGFBQWE7WUFDakJoQztZQUNBLEdBQUkvRCxXQUFXcUQsSUFBSSxLQUFLLFlBQVk7Z0JBQUVrQyxhQUFhdkYsV0FBV2EsRUFBRTtZQUFDLElBQUk7Z0JBQUVpRCxRQUFROUQsV0FBV2EsRUFBRTtZQUFDLENBQUM7UUFDaEc7UUFFQXVCLFVBQVVFLE9BQU8sQ0FBQzhDLElBQUksQ0FBQyxVQUFVVztJQUNuQztJQUVBLHFCQUNFLDhEQUFDaEcsWUFBWWlHLFFBQVE7UUFBQ0MsT0FBTztZQUMzQmpHO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FVO1lBQ0FDO1lBQ0FDO1lBQ0FDO1FBQ0Y7a0JBQ0dHOzs7Ozs7QUFHUCxFQUFFO0lBaFVXRDs7UUFDdUIxQixpREFBT0E7OztLQUQ5QjBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9DaGF0Q29udGV4dC50c3g/MGI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW8sIFNvY2tldCB9IGZyb20gJ3NvY2tldC5pby1jbGllbnQnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICcuL0F1dGhDb250ZXh0JztcblxuaW50ZXJmYWNlIFVzZXIge1xuICBpZDogc3RyaW5nO1xuICBfaWQ/OiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgZW1haWw6IHN0cmluZztcbiAgYXZhdGFyOiBzdHJpbmc7XG4gIGlzT25saW5lPzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBfaWQ6IHN0cmluZztcbiAgY29udGVudDogc3RyaW5nO1xuICBzZW5kZXI6IFVzZXI7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgcm9vbT86IHN0cmluZztcbiAgaXNSZWFkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJvb20ge1xuICBfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNyZWF0b3I6IFVzZXI7XG4gIG1lbWJlcnM6IFVzZXJbXTtcbiAgaXNQcml2YXRlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgcmVtb3ZlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBhY3RpdmVDaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbDtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgcm9vbXM6IFJvb21bXTtcbiAgb25saW5lVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICB1c2VyczogVXNlcltdO1xuICB0eXBpbmdVc2VyczogUmVjb3JkPHN0cmluZywgYm9vbGVhbj47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgc2V0QWN0aXZlQ2hhdDogKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB2b2lkO1xuICBzZW5kTWVzc2FnZTogKGNvbnRlbnQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPjtcbiAgY3JlYXRlUm9vbTogKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb24/OiBzdHJpbmcsIGlzUHJpdmF0ZT86IGJvb2xlYW4sIG1lbWJlcnM/OiBzdHJpbmdbXSkgPT4gUHJvbWlzZTxSb29tPjtcbiAgdXBkYXRlUm9vbTogKHJvb21JZDogc3RyaW5nLCBkYXRhOiB7IG5hbWU/OiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyBpbWFnZT86IHN0cmluZzsgaXNQcml2YXRlPzogYm9vbGVhbiB9KSA9PiBQcm9taXNlPFJvb20+O1xuICBqb2luUm9vbTogKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIGxlYXZlUm9vbTogKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IFByb21pc2U8dm9pZD47XG4gIHNldFR5cGluZzogKGlzVHlwaW5nOiBib29sZWFuKSA9PiB2b2lkO1xufVxuXG5jb25zdCBDaGF0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2hhdENvbnRleHRUeXBlPih7XG4gIGFjdGl2ZUNoYXQ6IG51bGwsXG4gIG1lc3NhZ2VzOiBbXSxcbiAgcm9vbXM6IFtdLFxuICBvbmxpbmVVc2Vyczoge30sXG4gIHVzZXJzOiBbXSxcbiAgdHlwaW5nVXNlcnM6IHt9LFxuICBpc0xvYWRpbmc6IHRydWUsXG4gIHNldEFjdGl2ZUNoYXQ6ICgpID0+IHt9LFxuICBzZW5kTWVzc2FnZTogYXN5bmMgKCkgPT4ge30sXG4gIGNyZWF0ZVJvb206IGFzeW5jICgpID0+ICh7IFxuICAgIF9pZDogJycsIFxuICAgIG5hbWU6ICcnLCBcbiAgICBjcmVhdG9yOiB7IGlkOiAnJywgX2lkOiAnJywgbmFtZTogJycsIGVtYWlsOiAnJywgYXZhdGFyOiAnJyB9LCBcbiAgICBtZW1iZXJzOiBbXSwgXG4gICAgaXNQcml2YXRlOiBmYWxzZSwgXG4gICAgY3JlYXRlZEF0OiAnJyBcbiAgfSksXG4gIHVwZGF0ZVJvb206IGFzeW5jICgpID0+ICh7IFxuICAgIF9pZDogJycsIFxuICAgIG5hbWU6ICcnLCBcbiAgICBjcmVhdG9yOiB7IGlkOiAnJywgX2lkOiAnJywgbmFtZTogJycsIGVtYWlsOiAnJywgYXZhdGFyOiAnJyB9LCBcbiAgICBtZW1iZXJzOiBbXSwgXG4gICAgaXNQcml2YXRlOiBmYWxzZSwgXG4gICAgY3JlYXRlZEF0OiAnJyBcbiAgfSksXG4gIGpvaW5Sb29tOiBhc3luYyAoKSA9PiB7fSxcbiAgbGVhdmVSb29tOiBhc3luYyAoKSA9PiB7fSxcbiAgc2V0VHlwaW5nOiAoKSA9PiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9ICgpID0+IHVzZUNvbnRleHQoQ2hhdENvbnRleHQpO1xuXG5leHBvcnQgY29uc3QgQ2hhdFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgdXNlciwgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFthY3RpdmVDaGF0LCBzZXRBY3RpdmVDaGF0XSA9IHVzZVN0YXRlPHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW3Jvb21zLCBzZXRSb29tc10gPSB1c2VTdGF0ZTxSb29tW10+KFtdKTtcbiAgY29uc3QgW3VzZXJzLCBzZXRVc2Vyc10gPSB1c2VTdGF0ZTxVc2VyW10+KFtdKTtcbiAgY29uc3QgW29ubGluZVVzZXJzLCBzZXRPbmxpbmVVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xuICBjb25zdCBbdHlwaW5nVXNlcnMsIHNldFR5cGluZ1VzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+Pih7fSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW3NvY2tldENvbm5lY3RlZCwgc2V0U29ja2V0Q29ubmVjdGVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgXG4gIGNvbnN0IHNvY2tldFJlZiA9IHVzZVJlZjxTb2NrZXQgfCBudWxsPihudWxsKTtcbiAgY29uc3QgY3VycmVudEFjdGl2ZUNoYXRSZWYgPSB1c2VSZWYoYWN0aXZlQ2hhdCk7XG4gIFxuICAvLyBLZWVwIHRoZSByZWYgaW4gc3luYyB3aXRoIHRoZSBzdGF0ZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGN1cnJlbnRBY3RpdmVDaGF0UmVmLmN1cnJlbnQgPSBhY3RpdmVDaGF0O1xuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSc7XG4gIFxuICAvLyBJbml0aWFsaXplIHNvY2tldCBjb25uZWN0aW9uIHdoZW4gYXV0aGVudGljYXRlZFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghaXNBdXRoZW50aWNhdGVkIHx8ICF1c2VyKSB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0b2tlbicpO1xuICAgIFxuICAgIGlmICghdG9rZW4pIHJldHVybjtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudCA9IGlvKEFQSV9VUkwsIHtcbiAgICAgIGF1dGg6IHsgdG9rZW4gfSxcbiAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICB9KTtcbiAgICBcbiAgICAvLyBTb2NrZXQgZXZlbnQgbGlzdGVuZXJzXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ2Nvbm5lY3QnLCAoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnU29ja2V0IGNvbm5lY3RlZCcpO1xuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKHRydWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfbWVzc2FnZScsIChtZXNzYWdlOiBNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIC8vIE9ubHkgYWRkIHRoZSBtZXNzYWdlIGlmIGl0J3MgcmVsZXZhbnQgdG8gdGhlIGFjdGl2ZSBjaGF0XG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgXG4gICAgICAgICAgKChtZXNzYWdlLnNlbmRlci5faWQgPT09IGFjdGl2ZUNoYXQuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IHVzZXIuX2lkKSB8fCBcbiAgICAgICAgICAgKG1lc3NhZ2Uuc2VuZGVyLl9pZCA9PT0gdXNlci5faWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IGFjdGl2ZUNoYXQuaWQpKSkgfHxcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBtZXNzYWdlLnJvb20gPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgc2V0TWVzc2FnZXMocHJldiA9PiBbLi4ucHJldiwgbWVzc2FnZV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd1c2VyX3N0YXR1c19jaGFuZ2UnLCAoeyB1c2VySWQsIGlzT25saW5lIH0pID0+IHtcbiAgICAgIHNldE9ubGluZVVzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW3VzZXJJZF06IGlzT25saW5lIH0pKTtcbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndHlwaW5nX2luZGljYXRvcicsIChkYXRhOiB7IHVzZXJJZDogc3RyaW5nLCB1c2VyTmFtZTogc3RyaW5nLCBpc1R5cGluZzogYm9vbGVhbiwgcm9vbUlkPzogc3RyaW5nLCBzZW5kZXJJZD86IHN0cmluZyB9KSA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgIGlmIChcbiAgICAgICAgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdwcml2YXRlJyAmJiBkYXRhLnNlbmRlcklkID09PSBhY3RpdmVDaGF0LmlkKSB8fFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3Jvb20nICYmIGRhdGEucm9vbUlkID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIHNldFR5cGluZ1VzZXJzKHByZXYgPT4gKHsgLi4ucHJldiwgW2RhdGEudXNlcklkXTogZGF0YS5pc1R5cGluZyB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ21lc3NhZ2VfcmVhZCcsICh7IG1lc3NhZ2VJZCB9KSA9PiB7XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChtc2cgPT4gXG4gICAgICAgICAgbXNnLl9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIGlzUmVhZDogdHJ1ZSB9IDogbXNnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIG5ldyByb29tIGNyZWF0aW9uc1xuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfcm9vbScsIChyb29tOiBSb29tKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnTmV3IHJvb20gcmVjZWl2ZWQ6Jywgcm9vbSk7XG4gICAgICBzZXRSb29tcyhwcmV2ID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJvb20gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgY29uc3QgZXhpc3RzID0gcHJldi5zb21lKHIgPT4gci5faWQgPT09IHJvb20uX2lkKTtcbiAgICAgICAgaWYgKGV4aXN0cykgcmV0dXJuIHByZXY7XG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgcm9vbV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgcm9vbSB1cGRhdGVzIChtZW1iZXJzIGFkZGVkL3JlbW92ZWQpXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3Jvb21fdXBkYXRlZCcsIChyb29tOiBSb29tKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnUm9vbSB1cGRhdGVkOicsIHJvb20pO1xuICAgICAgaWYgKHJvb20ucmVtb3ZlZCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJvb20gd2FzIHJlbW92ZWQgZm9yIHRoaXMgdXNlciwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgc2V0Um9vbXMocHJldiA9PiBwcmV2LmZpbHRlcihyID0+IHIuX2lkICE9PSByb29tLl9pZCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgYWN0aXZlIGNoYXQgaXMgdGhpcyByb29tLCBjbGVhciBpdFxuICAgICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBhY3RpdmVDaGF0LmlkID09PSByb29tLl9pZCkge1xuICAgICAgICAgIHNldEFjdGl2ZUNoYXQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYubWFwKHIgPT4gci5faWQgPT09IHJvb20uX2lkID8gcm9vbSA6IHIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH07XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIHVzZXIsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIExvYWQgaW5pdGlhbCBkYXRhOiB1c2VycyBhbmQgcm9vbXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmV0Y2hJbml0aWFsRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IFt1c2Vyc1Jlc3BvbnNlLCByb29tc1Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vdXNlcnNgKSxcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vcm9vbXMvbXlgKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIHNldFVzZXJzKHVzZXJzUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHNldFJvb21zKHJvb21zUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbmxpbmUgc3RhdHVzXG4gICAgICAgIGNvbnN0IGluaXRpYWxPbmxpbmVTdGF0dXM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gICAgICAgIHVzZXJzUmVzcG9uc2UuZGF0YS5mb3JFYWNoKCh1c2VyOiBVc2VyKSA9PiB7XG4gICAgICAgICAgaW5pdGlhbE9ubGluZVN0YXR1c1t1c2VyLl9pZCFdID0gdXNlci5pc09ubGluZSB8fCBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE9ubGluZVVzZXJzKGluaXRpYWxPbmxpbmVTdGF0dXMpO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGluaXRpYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hJbml0aWFsRGF0YSgpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBMb2FkIG1lc3NhZ2VzIHdoZW4gYWN0aXZlQ2hhdCBjaGFuZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICFpc0F1dGhlbnRpY2F0ZWQgfHwgIXNvY2tldENvbm5lY3RlZCkge1xuICAgICAgc2V0TWVzc2FnZXMoW10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBjb25zdCBmZXRjaE1lc3NhZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGF4aW9zLmdldChgJHtBUElfVVJMfS9jaGF0cy9kaXJlY3QvJHthY3RpdmVDaGF0LmlkfWApO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIEpvaW4gdXNlciByb29tIGZvciBkaXJlY3QgbWVzc2FnZXNcbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyB1c2VySWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBheGlvcy5nZXQoYCR7QVBJX1VSTH0vY2hhdHMvcm9vbS8ke2FjdGl2ZUNoYXQuaWR9YCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gSm9pbiByb29tXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzZXRNZXNzYWdlcyhyZXNwb25zZS5kYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG1lc3NhZ2VzOicsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmZXRjaE1lc3NhZ2VzKCk7XG4gICAgXG4gICAgLy8gQ2xlYXIgdHlwaW5nIGluZGljYXRvciB3aGVuIGNoYW5naW5nIGNoYXRzXG4gICAgc2V0VHlwaW5nVXNlcnMoe30pO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBMZWF2ZSBwcmV2aW91cyBjaGF0IHJvb21cbiAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnbGVhdmVfcm9vbScsIHsgdXNlcklkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2xlYXZlX3Jvb20nLCB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYWN0aXZlQ2hhdCwgaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMLCBzb2NrZXRDb25uZWN0ZWRdKTtcbiAgXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhdXNlciB8fCAhc29ja2V0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnc2VuZF9tZXNzYWdlJywgbWVzc2FnZURhdGEpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgY3JlYXRlUm9vbSA9IGFzeW5jIChuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uID0gJycsIGlzUHJpdmF0ZSA9IGZhbHNlLCBtZW1iZXJzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9yb29tc2AsIHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIGlzUHJpdmF0ZSxcbiAgICAgICAgbWVtYmVycyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBObyBuZWVkIHRvIG1hbnVhbGx5IGFkZCB0byByb29tcyBhcnJheSwgdGhlIHNvY2tldCBldmVudCB3aWxsIGhhbmRsZSBpdFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgdXBkYXRlUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXBkYXRlRGF0YTogeyBuYW1lPzogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZzsgaW1hZ2U/OiBzdHJpbmc7IGlzUHJpdmF0ZT86IGJvb2xlYW4gfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEgfSA9IGF3YWl0IGF4aW9zLnB1dChgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH1gLCB1cGRhdGVEYXRhKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRoZSByb29tIGluIHRoZSBsb2NhbCBzdGF0ZSB0byBpbW1lZGlhdGVseSByZWZsZWN0IGNoYW5nZXNcbiAgICAgIHNldFJvb21zKHByZXZSb29tcyA9PiBcbiAgICAgICAgcHJldlJvb21zLm1hcChyb29tID0+IFxuICAgICAgICAgIHJvb20uX2lkID09PSByb29tSWQgPyB7IC4uLnJvb20sIC4uLmRhdGEgfSA6IHJvb21cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3Qgam9pblJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlciAmJiAhdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHVzZXJJZCBpcyBwcm92aWRlZCwgdXNlIGl0IChmb3IgYWRtaW4gYWRkaW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWpvaW5pbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfS9tZW1iZXJzLyR7dGFyZ2V0VXNlcklkfWApO1xuICAgICAgLy8gUm9vbSB1cGRhdGUgd2lsbCBiZSBoYW5kbGVkIGJ5IHNvY2tldCBldmVudFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBqb2luaW5nIHJvb206JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9O1xuICBcbiAgY29uc3QgbGVhdmVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIgJiYgIXVzZXJJZCkgcmV0dXJuO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBJZiB1c2VySWQgaXMgcHJvdmlkZWQsIHVzZSBpdCAoZm9yIGFkbWluIHJlbW92aW5nIG90aGVycylcbiAgICAgIC8vIE90aGVyd2lzZSB1c2UgY3VycmVudCB1c2VyJ3MgSUQgKGZvciBzZWxmLWxlYXZpbmcpXG4gICAgICBjb25zdCB0YXJnZXRVc2VySWQgPSB1c2VySWQgfHwgdXNlciEuaWQ7XG4gICAgICBhd2FpdCBheGlvcy5kZWxldGUoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt0YXJnZXRVc2VySWR9YCk7XG4gICAgICAvLyBSb29tIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgYnkgc29ja2V0IGV2ZW50XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxlYXZpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBzZXRUeXBpbmcgPSAoaXNUeXBpbmc6IGJvb2xlYW4pID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQgfHwgIXNvY2tldFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgY29uc3QgdHlwaW5nRGF0YSA9IHtcbiAgICAgIGlzVHlwaW5nLFxuICAgICAgLi4uKGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8geyByZWNpcGllbnRJZDogYWN0aXZlQ2hhdC5pZCB9IDogeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSksXG4gICAgfTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCd0eXBpbmcnLCB0eXBpbmdEYXRhKTtcbiAgfTtcbiAgXG4gIHJldHVybiAoXG4gICAgPENoYXRDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7XG4gICAgICBhY3RpdmVDaGF0LFxuICAgICAgbWVzc2FnZXMsXG4gICAgICByb29tcyxcbiAgICAgIG9ubGluZVVzZXJzLFxuICAgICAgdXNlcnMsXG4gICAgICB0eXBpbmdVc2VycyxcbiAgICAgIGlzTG9hZGluZyxcbiAgICAgIHNldEFjdGl2ZUNoYXQsXG4gICAgICBzZW5kTWVzc2FnZSxcbiAgICAgIGNyZWF0ZVJvb20sXG4gICAgICB1cGRhdGVSb29tLFxuICAgICAgam9pblJvb20sXG4gICAgICBsZWF2ZVJvb20sXG4gICAgICBzZXRUeXBpbmcsXG4gICAgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiaW8iLCJheGlvcyIsInVzZUF1dGgiLCJDaGF0Q29udGV4dCIsImFjdGl2ZUNoYXQiLCJtZXNzYWdlcyIsInJvb21zIiwib25saW5lVXNlcnMiLCJ1c2VycyIsInR5cGluZ1VzZXJzIiwiaXNMb2FkaW5nIiwic2V0QWN0aXZlQ2hhdCIsInNlbmRNZXNzYWdlIiwiY3JlYXRlUm9vbSIsIl9pZCIsIm5hbWUiLCJjcmVhdG9yIiwiaWQiLCJlbWFpbCIsImF2YXRhciIsIm1lbWJlcnMiLCJpc1ByaXZhdGUiLCJjcmVhdGVkQXQiLCJ1cGRhdGVSb29tIiwiam9pblJvb20iLCJsZWF2ZVJvb20iLCJzZXRUeXBpbmciLCJ1c2VDaGF0IiwiQ2hhdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0TWVzc2FnZXMiLCJzZXRSb29tcyIsInNldFVzZXJzIiwic2V0T25saW5lVXNlcnMiLCJzZXRUeXBpbmdVc2VycyIsInNldElzTG9hZGluZyIsInNvY2tldENvbm5lY3RlZCIsInNldFNvY2tldENvbm5lY3RlZCIsInNvY2tldFJlZiIsImN1cnJlbnRBY3RpdmVDaGF0UmVmIiwiY3VycmVudCIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImRpc2Nvbm5lY3QiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhdXRoIiwid2l0aENyZWRlbnRpYWxzIiwib24iLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsInR5cGUiLCJzZW5kZXIiLCJyZWNpcGllbnQiLCJyb29tIiwicHJldiIsInVzZXJJZCIsImlzT25saW5lIiwiZGF0YSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJtZXNzYWdlSWQiLCJtYXAiLCJtc2ciLCJpc1JlYWQiLCJleGlzdHMiLCJzb21lIiwiciIsInJlbW92ZWQiLCJmaWx0ZXIiLCJmZXRjaEluaXRpYWxEYXRhIiwidXNlcnNSZXNwb25zZSIsInJvb21zUmVzcG9uc2UiLCJQcm9taXNlIiwiYWxsIiwiZ2V0IiwiaW5pdGlhbE9ubGluZVN0YXR1cyIsImZvckVhY2giLCJlcnJvciIsImZldGNoTWVzc2FnZXMiLCJyZXNwb25zZSIsImVtaXQiLCJjb250ZW50IiwibWVzc2FnZURhdGEiLCJyZWNpcGllbnRJZCIsImRlc2NyaXB0aW9uIiwicG9zdCIsInVwZGF0ZURhdGEiLCJwdXQiLCJwcmV2Um9vbXMiLCJ0YXJnZXRVc2VySWQiLCJkZWxldGUiLCJ0eXBpbmdEYXRhIiwiUHJvdmlkZXIiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});