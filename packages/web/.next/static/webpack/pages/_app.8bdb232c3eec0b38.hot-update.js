"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/contexts/ChatContext.tsx":
/*!**************************************!*\
  !*** ./src/contexts/ChatContext.tsx ***!
  \**************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChatProvider: function() { return /* binding */ ChatProvider; },\n/* harmony export */   FileType: function() { return /* binding */ FileType; },\n/* harmony export */   useChat: function() { return /* binding */ useChat; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"../../node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"../../node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var socket_io_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! socket.io-client */ \"../../node_modules/socket.io-client/build/esm/index.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"../../node_modules/axios/index.js\");\n/* harmony import */ var _AuthContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AuthContext */ \"./src/contexts/AuthContext.tsx\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\n\nvar FileType;\n(function(FileType) {\n    FileType[\"IMAGE\"] = \"image\";\n    FileType[\"VIDEO\"] = \"video\";\n    FileType[\"DOCUMENT\"] = \"document\";\n    FileType[\"AUDIO\"] = \"audio\";\n})(FileType || (FileType = {}));\nconst ChatContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({\n    activeChat: null,\n    messages: [],\n    rooms: [],\n    onlineUsers: {},\n    users: [],\n    typingUsers: {},\n    isLoading: true,\n    isLoadingMessages: false,\n    unreadMessages: {},\n    uploadingFiles: {},\n    setActiveChat: ()=>{},\n    sendMessage: async ()=>{},\n    markAsRead: ()=>{},\n    startTyping: ()=>{},\n    stopTyping: ()=>{},\n    loadMoreMessages: async ()=>0,\n    retryFileUpload: ()=>{},\n    cancelFileUpload: ()=>{}\n});\nconst useChat = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ChatContext);\n};\n_s(useChat, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst ChatProvider = (param)=>{\n    let { children } = param;\n    _s1();\n    const { user, isAuthenticated } = (0,_AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth)();\n    const [activeChat, setActiveChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [rooms, setRooms] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [users, setUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [onlineUsers, setOnlineUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [typingUsers, setTypingUsers] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isLoadingMessages, setIsLoadingMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [socketConnected, setSocketConnected] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [unreadMessages, setUnreadMessages] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [uploadingFilesByChat, setUploadingFilesByChat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({});\n    const [selectedFile, setSelectedFile] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const uploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        if (!activeChat) return {};\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        return uploadingFilesByChat[chatId] || {};\n    }, [\n        activeChat,\n        uploadingFilesByChat\n    ]);\n    const updateUploadingFiles = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((chatId, fileId, status)=>{\n        setUploadingFilesByChat((prev)=>{\n            const newState = {\n                ...prev\n            };\n            // Si no existe el chat, lo creamos\n            if (!newState[chatId]) {\n                newState[chatId] = {};\n            }\n            // Si status es null, eliminar el archivo\n            if (status === null) {\n                if (newState[chatId][fileId]) {\n                    delete newState[chatId][fileId];\n                    // Si no quedan archivos en este chat, eliminar también la entrada del chat\n                    if (Object.keys(newState[chatId]).length === 0) {\n                        delete newState[chatId];\n                    }\n                }\n            } else {\n                // Actualizar el estado del archivo\n                newState[chatId][fileId] = status;\n            }\n            return newState;\n        });\n    }, []);\n    const cancelFileUpload = (file)=>{\n        if (!file.tempId || !activeChat) return;\n        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, null);\n    };\n    const socketRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const currentActiveChatRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(activeChat);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Keep the ref in sync with the state\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        currentActiveChatRef.current = activeChat;\n    }, [\n        activeChat\n    ]);\n    const API_URL = \"http://localhost:3001\" || 0;\n    // Initialize socket connection when authenticated\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated || !user) {\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n            return;\n        }\n        const token = localStorage.getItem(\"token\");\n        if (!token) return;\n        socketRef.current = (0,socket_io_client__WEBPACK_IMPORTED_MODULE_2__.io)(API_URL, {\n            auth: {\n                token\n            },\n            withCredentials: true,\n            // Aumentar el tiempo de espera para permitir envío de archivos grandes\n            timeout: 60000 // aumentar el tiempo de espera a 60 segundos\n        });\n        // Socket event listeners\n        socketRef.current.on(\"connect\", ()=>{\n            console.log(\"Socket connected\");\n            setSocketConnected(true);\n        });\n        socketRef.current.on(\"new_message\", (message)=>{\n            const activeChat = currentActiveChatRef.current;\n            // Identificar la clave de chat para seguimiento de notificaciones\n            let chatKey = \"\";\n            if (message.room) {\n                chatKey = \"room_\".concat(message.room);\n            } else if (message.sender._id !== user.id) {\n                chatKey = \"user_\".concat(message.sender._id);\n            } else if (message.recipient) {\n                chatKey = \"user_\".concat(message.recipient);\n            }\n            // Solo agregar el mensaje si es relevante para el chat activo\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && (message.sender._id === activeChat.id && message.recipient === user.id || message.sender._id === user.id && message.recipient === activeChat.id) || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && message.room === activeChat.id) {\n                setMessages((prev)=>[\n                        ...prev,\n                        message\n                    ]);\n            } else if (message.sender._id !== user.id && chatKey) {\n                console.log(\"New message notification:\", chatKey, message);\n                setUnreadMessages((prev)=>({\n                        ...prev,\n                        [chatKey]: (prev[chatKey] || 0) + 1\n                    }));\n            }\n        });\n        socketRef.current.on(\"user_status_change\", (param)=>{\n            let { userId, isOnline } = param;\n            setOnlineUsers((prev)=>({\n                    ...prev,\n                    [userId]: isOnline\n                }));\n        });\n        socketRef.current.on(\"typing_indicator\", (data)=>{\n            const activeChat = currentActiveChatRef.current;\n            if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"private\" && data.senderId === activeChat.id || (activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && data.roomId === activeChat.id) {\n                // Almacenar nombre en lugar de solo la bandera booleana\n                setTypingUsers((prev)=>({\n                        ...prev,\n                        [data.userId]: data.isTyping ? data.userName : false\n                    }));\n            }\n        });\n        socketRef.current.on(\"message_read\", (param)=>{\n            let { messageId } = param;\n            setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                        ...msg,\n                        isRead: true\n                    } : msg));\n        });\n        // Handle new room creations\n        socketRef.current.on(\"new_room\", (room)=>{\n            console.log(\"New room received:\", room);\n            setRooms((prev)=>{\n                // Check if the room already exists\n                const exists = prev.some((r)=>r._id === room._id);\n                if (exists) return prev;\n                return [\n                    ...prev,\n                    room\n                ];\n            });\n        });\n        // Handle room updates (members added/removed)\n        socketRef.current.on(\"room_updated\", (room)=>{\n            console.log(\"Room updated:\", room);\n            if (room.removed) {\n                // If this room was removed for this user, remove it from the list\n                setRooms((prev)=>prev.filter((r)=>r._id !== room._id));\n                // If active chat is this room, clear it\n                const activeChat = currentActiveChatRef.current;\n                if ((activeChat === null || activeChat === void 0 ? void 0 : activeChat.type) === \"room\" && activeChat.id === room._id) {\n                    setActiveChat(null);\n                }\n            } else {\n                // Update the room in the list\n                setRooms((prev)=>prev.map((r)=>r._id === room._id ? room : r));\n            }\n        });\n        socketRef.current.on(\"disconnect\", ()=>{\n            console.log(\"Socket disconnected\");\n            setSocketConnected(false);\n        });\n        return ()=>{\n            if (socketRef.current) {\n                socketRef.current.disconnect();\n                socketRef.current = null;\n            }\n            setSocketConnected(false);\n        };\n    }, [\n        isAuthenticated,\n        user,\n        API_URL\n    ]);\n    // Load initial data: users and rooms\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!isAuthenticated) {\n            setIsLoading(false);\n            return;\n        }\n        const fetchInitialData = async ()=>{\n            try {\n                setIsLoading(true);\n                const [usersResponse, roomsResponse] = await Promise.all([\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/users\")),\n                    axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(\"\".concat(API_URL, \"/rooms/my\"))\n                ]);\n                setUsers(usersResponse.data);\n                setRooms(roomsResponse.data);\n                // Set initial online status\n                const initialOnlineStatus = {};\n                usersResponse.data.forEach((user)=>{\n                    initialOnlineStatus[user._id] = user.isOnline || false;\n                });\n                setOnlineUsers(initialOnlineStatus);\n            } catch (error) {\n                console.error(\"Error fetching initial data:\", error);\n            } finally{\n                setIsLoading(false);\n            }\n        };\n        fetchInitialData();\n    }, [\n        isAuthenticated,\n        API_URL\n    ]);\n    // Cuando se inicia el socket y se conecta, solicitamos el estado actual de mensajes no leídos\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (socketConnected && socketRef.current && user) {\n            // Solicitar mensajes no leídos al servidor\n            socketRef.current.emit(\"get_unread_messages\");\n            // Escuchar la respuesta con el recuento de mensajes no leídos\n            socketRef.current.on(\"unread_messages_count\", (unreadCounts)=>{\n                console.log(\"Received unread counts:\", unreadCounts);\n                setUnreadMessages(unreadCounts);\n            });\n            return ()=>{\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.off(\"unread_messages_count\");\n            };\n        }\n    }, [\n        socketConnected,\n        user\n    ]);\n    // Asegurarse de que los mensajes se marquen como leídos cuando se abre un chat\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (activeChat && socketRef.current) {\n            // Crear una clave para el chat actual\n            const chatKey = activeChat.type === \"private\" ? \"user_\".concat(activeChat.id) : \"room_\".concat(activeChat.id);\n            // Resetear el contador de mensajes no leídos para este chat\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n            // Notificar al servidor que los mensajes se han leído\n            socketRef.current.emit(\"mark_messages_read\", {\n                chatId: activeChat.id,\n                chatType: activeChat.type\n            });\n        }\n    }, [\n        activeChat\n    ]);\n    // Función para manejar el cambio de chat activo\n    const handleActiveChatChange = (chat)=>{\n        // Limpiar las notificaciones no leídas cuando se activa un chat\n        if (chat) {\n            const chatKey = chat.type === \"private\" ? \"user_\".concat(chat.id) : \"room_\".concat(chat.id);\n            setUnreadMessages((prev)=>({\n                    ...prev,\n                    [chatKey]: 0\n                }));\n        }\n        setActiveChat(chat);\n    };\n    // Efecto para actualizar los mensajes cuando cambia el chat activo\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!activeChat || !isAuthenticated) return;\n        // Resetear el estado al cambiar de chat\n        setMessages([]);\n        setIsLoadingMessages(true);\n        // Reiniciar estados de mensajes no leídos y archivos en carga\n        if (activeChat) {\n            // Limpiar mensajes no leídos\n            setUnreadMessages((prev)=>{\n                const chatKey = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n                if (prev[chatKey]) {\n                    const newState = {\n                        ...prev\n                    };\n                    delete newState[chatKey];\n                    return newState;\n                }\n                return prev;\n            });\n            // Asegurarnos de que la sección \"Archivos en proceso\" desaparezca al cambiar de chat\n            // incluso cuando ya había terminado la carga con 100%\n            const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n            if (chatId in uploadingFilesByChat) {\n                const hasCompletedUploads = Object.values(uploadingFilesByChat[chatId]).some((status)=>status.progress === 100);\n                if (hasCompletedUploads) {\n                    setUploadingFilesByChat((prev)=>{\n                        const newState = {\n                            ...prev\n                        };\n                        delete newState[chatId];\n                        return newState;\n                    });\n                }\n            }\n        }\n        // Solicitar mensajes al servidor\n        const fetchMessages = async ()=>{\n            try {\n                let endpoint = \"\";\n                if (activeChat.type === \"private\") {\n                    var // Join user room for direct messages\n                    _socketRef_current;\n                    endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id);\n                    (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"join_room\", {\n                        userId: activeChat.id\n                    });\n                } else {\n                    var // Join room\n                    _socketRef_current1;\n                    endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id);\n                    (_socketRef_current1 = socketRef.current) === null || _socketRef_current1 === void 0 ? void 0 : _socketRef_current1.emit(\"join_room\", {\n                        roomId: activeChat.id\n                    });\n                }\n                const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n                setMessages(response.data);\n                // Marcar los mensajes como leídos en el servidor\n                if (response.data.length > 0) {\n                    var _socketRef_current2;\n                    (_socketRef_current2 = socketRef.current) === null || _socketRef_current2 === void 0 ? void 0 : _socketRef_current2.emit(\"mark_messages_read\", {\n                        chatType: activeChat.type,\n                        chatId: activeChat.id\n                    });\n                }\n            } catch (error) {\n                console.error(\"Error fetching messages:\", error);\n            } finally{\n                setIsLoadingMessages(false);\n            }\n        };\n        fetchMessages();\n        return ()=>{\n            // Clean up - leave rooms\n            if (activeChat.type === \"room\") {\n                var _socketRef_current;\n                (_socketRef_current = socketRef.current) === null || _socketRef_current === void 0 ? void 0 : _socketRef_current.emit(\"leave_room\", {\n                    roomId: activeChat.id\n                });\n            }\n        };\n    }, [\n        activeChat,\n        user,\n        isAuthenticated,\n        API_URL\n    ]);\n    // Efecto para limpiar archivos completados automáticamente\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        // Revisa cada 2 segundos si hay archivos que están al 100% que deban eliminarse\n        const cleanupInterval = setInterval(()=>{\n            setUploadingFilesByChat((prev)=>{\n                const newState = {\n                    ...prev\n                };\n                let hasChanges = false;\n                // Revisar todos los chats\n                Object.keys(newState).forEach((chatId)=>{\n                    // Revisar todos los archivos en ese chat\n                    Object.keys(newState[chatId]).forEach((fileId)=>{\n                        // Si un archivo está al 100%, eliminarlo\n                        if (newState[chatId][fileId].progress === 100) {\n                            delete newState[chatId][fileId];\n                            hasChanges = true;\n                        }\n                    });\n                    // Si el chat ya no tiene archivos, eliminar el chat\n                    if (Object.keys(newState[chatId]).length === 0) {\n                        delete newState[chatId];\n                        hasChanges = true;\n                    }\n                });\n                return hasChanges ? newState : prev;\n            });\n        }, 2000);\n        return ()=>clearInterval(cleanupInterval);\n    }, []);\n    const sendMessage = async (content, attachments)=>{\n        if (!socketRef.current || !activeChat) return;\n        try {\n            // Generar tempIds para los archivos y convertirlos a FileAttachment\n            const attachmentsWithIds = [];\n            if (attachments && attachments.length > 0) {\n                for (const file of attachments){\n                    const tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n                    // Determinar tipo de archivo de forma segura\n                    let fileType = \"document\";\n                    const fileTypeString = file.type || \"\"; // Usar string vacío si type es undefined\n                    if (fileTypeString.startsWith(\"image/\")) {\n                        fileType = \"image\";\n                    } else if (fileTypeString.startsWith(\"video/\")) {\n                        fileType = \"video\";\n                    } else if (fileTypeString.startsWith(\"audio/\")) {\n                        fileType = \"audio\";\n                    } else {\n                        fileType = \"document\";\n                    }\n                    // Crear objeto FileAttachment para el archivo\n                    const attachment = {\n                        tempId,\n                        filename: file.name || \"archivo\",\n                        contentType: file.type || \"application/octet-stream\",\n                        fileType,\n                        size: file.size || 0\n                    };\n                    // Si es un archivo grande, lo procesamos para subida en segundo plano\n                    if (file.size > 5 * 1024 * 1024) {\n                        attachment.isLargeFile = true;\n                        // Leer como base64 para preprocesamiento\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Iniciar subida en segundo plano\n                        const chatId = \"\".concat(activeChat.type, \"-\").concat(activeChat.id);\n                        updateUploadingFiles(chatId, tempId, {\n                            progress: 0,\n                            error: undefined\n                        });\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                        // Iniciar subida en segundo plano\n                        uploadLargeFileToServer(attachment).then((fileId)=>{\n                            if (fileId) {\n                                // Actualizar el attachment con el fileId\n                                attachment.fileId = fileId;\n                                attachment.isLargeFile = true;\n                                attachment.data = undefined; // Eliminar los datos binarios\n                                // Actualizar progreso a 100%\n                                updateUploadingFiles(chatId, tempId, {\n                                    progress: 100,\n                                    error: undefined\n                                });\n                            }\n                        }).catch((error)=>{\n                            console.error(\"Error subiendo archivo:\", error);\n                            updateUploadingFiles(chatId, tempId, {\n                                progress: 0,\n                                error: error.message || \"Error al subir el archivo\"\n                            });\n                        });\n                    } else {\n                        // Para archivos pequeños (<5MB), leerlos como base64 y enviar con el mensaje\n                        const reader = new FileReader();\n                        reader.readAsDataURL(file);\n                        await new Promise((resolve)=>{\n                            reader.onload = ()=>{\n                                var _reader_result;\n                                const base64data = ((_reader_result = reader.result) === null || _reader_result === void 0 ? void 0 : _reader_result.toString()) || \"\";\n                                // Quitar el prefijo (ej. \"data:image/jpeg;base64,\")\n                                const base64Clean = base64data.split(\",\")[1];\n                                attachment.data = base64Clean;\n                                resolve();\n                            };\n                        });\n                        // Agregar a la lista de adjuntos\n                        attachmentsWithIds.push(attachment);\n                    }\n                }\n            }\n            // Preparar datos del mensaje\n            const messageData = {\n                content,\n                attachments: attachmentsWithIds,\n                ...activeChat.type === \"private\" ? {\n                    recipientId: activeChat.id\n                } : {\n                    roomId: activeChat.id\n                }\n            };\n            // Enviar el mensaje a través del socket\n            socketRef.current.emit(\"send_message\", messageData, (response)=>{\n                if (!response.success) {\n                    console.error(\"Error al enviar mensaje:\", response.error);\n                }\n            });\n            // Limpiar formulario después de enviar\n            if (fileInputRef.current) {\n                fileInputRef.current.value = \"\";\n            }\n            setSelectedFile(null);\n        } catch (error) {\n            console.error(\"Error al procesar mensaje:\", error);\n        }\n    };\n    const createRoom = async function(name) {\n        let description = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", isPrivate = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, members = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms\"), {\n                name,\n                description,\n                isPrivate,\n                members\n            });\n            // No need to manually add to rooms array, the socket event will handle it\n            return data;\n        } catch (error) {\n            console.error(\"Error creating room:\", error);\n            throw error;\n        }\n    };\n    const updateRoom = async (roomId, updateData)=>{\n        try {\n            const { data } = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].put(\"\".concat(API_URL, \"/rooms/\").concat(roomId), updateData);\n            // Update the room in the local state to immediately reflect changes\n            setRooms((prevRooms)=>prevRooms.map((room)=>room._id === roomId ? {\n                        ...room,\n                        ...data\n                    } : room));\n            return data;\n        } catch (error) {\n            console.error(\"Error updating room:\", error);\n            throw error;\n        }\n    };\n    const joinRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin adding others)\n            // Otherwise use current user's ID (for self-joining)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error joining room:\", error);\n            throw error;\n        }\n    };\n    const leaveRoom = async (roomId, userId)=>{\n        if (!user && !userId) return;\n        try {\n            // If userId is provided, use it (for admin removing others)\n            // Otherwise use current user's ID (for self-leaving)\n            const targetUserId = userId || user.id;\n            await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/rooms/\").concat(roomId, \"/members/\").concat(targetUserId));\n        // Room update will be handled by socket event\n        } catch (error) {\n            console.error(\"Error leaving room:\", error);\n            throw error;\n        }\n    };\n    const setTyping = (isTyping)=>{\n        if (!activeChat || !socketRef.current) return;\n        const typingData = {\n            isTyping,\n            ...activeChat.type === \"private\" ? {\n                recipientId: activeChat.id\n            } : {\n                roomId: activeChat.id\n            }\n        };\n        socketRef.current.emit(\"typing\", typingData);\n    };\n    const clearChatHistory = async (recipientId)=>{\n        try {\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"][\"delete\"](\"\".concat(API_URL, \"/chats/direct/\").concat(recipientId));\n            return {\n                success: true,\n                message: \"Chat history cleared successfully\"\n            };\n        } catch (error) {\n            console.error(\"Error clearing chat history:\", error);\n            return {\n                success: false,\n                message: \"Failed to clear chat history\"\n            };\n        }\n    };\n    // Implementación de retryFileUpload\n    const retryFileUpload = (file)=>{\n        if (!file.tempId) return;\n        // Reset progress\n        const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n        updateUploadingFiles(chatId, file.tempId, {\n            progress: 0,\n            error: undefined\n        });\n        // Prepare for re-upload\n        if (file.data) {\n            // Es un archivo ya convertido a base64\n            uploadLargeFileToServer(file);\n        } else if (file.fileId) {\n            // Remover el error pero mantener el progreso como completado\n            // ya que el archivo ya está subido\n            updateUploadingFiles(chatId, file.tempId, {\n                progress: 100,\n                error: undefined\n            });\n        }\n    };\n    // Función auxiliar para subir un archivo grande directamente al servidor\n    const uploadLargeFileToServer = async (attachment)=>{\n        if (!attachment.tempId) {\n            attachment.tempId = \"temp-\".concat(Date.now(), \"-\").concat(Math.random().toString(36).substring(2, 9));\n        }\n        try {\n            // Convertir datos base64 a Blob para subir\n            const base64Data = attachment.data || \"\";\n            const byteCharacters = atob(base64Data);\n            const byteArrays = [];\n            for(let offset = 0; offset < byteCharacters.length; offset += 512){\n                const slice = byteCharacters.slice(offset, offset + 512);\n                const byteNumbers = new Array(slice.length);\n                for(let i = 0; i < slice.length; i++){\n                    byteNumbers[i] = slice.charCodeAt(i);\n                }\n                const byteArray = new Uint8Array(byteNumbers);\n                byteArrays.push(byteArray);\n            }\n            const blob = new Blob(byteArrays, {\n                type: attachment.contentType\n            });\n            const file = new File([\n                blob\n            ], attachment.filename, {\n                type: attachment.contentType\n            });\n            // Crear FormData para la subida\n            const formData = new FormData();\n            formData.append(\"file\", file);\n            // Iniciar la carga y actualizar el estado\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: undefined\n            });\n            // Realizar la subida con seguimiento de progreso\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].post(\"\".concat(API_URL, \"/file-storage/upload\"), formData, {\n                headers: {\n                    \"Content-Type\": \"multipart/form-data\"\n                },\n                onUploadProgress: (progressEvent)=>{\n                    const percentCompleted = progressEvent.total ? Math.round(progressEvent.loaded * 100 / progressEvent.total) : 0;\n                    updateUploadingFiles(chatId, attachment.tempId, {\n                        progress: percentCompleted,\n                        error: undefined\n                    });\n                    // Si el archivo ha terminado de cargarse (100%), lo eliminamos de la lista después de un breve tiempo\n                    if (percentCompleted === 100) {\n                        setTimeout(()=>{\n                            updateUploadingFiles(chatId, attachment.tempId, null);\n                        }, 1000);\n                    }\n                }\n            });\n            if (response.data && response.data.fileId) {\n                return response.data.fileId;\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error al subir archivo:\", error);\n            const chatId = \"\".concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.type, \"-\").concat(activeChat === null || activeChat === void 0 ? void 0 : activeChat.id);\n            updateUploadingFiles(chatId, attachment.tempId, {\n                progress: 0,\n                error: error.message || \"Error al subir el archivo\"\n            });\n            return null;\n        }\n    };\n    // Esta función se encarga de marcar un mensaje como leído\n    const handleMarkAsRead = (messageId)=>{\n        if (!socketRef.current) return;\n        socketRef.current.emit(\"mark_message_read\", {\n            messageId\n        });\n        // Actualizar el estado de mensajes localmente\n        setMessages((prev)=>prev.map((msg)=>msg._id === messageId ? {\n                    ...msg,\n                    isRead: true\n                } : msg));\n    };\n    // Esta función carga más mensajes para la paginación\n    const fetchMoreMessages = async (beforeMessageId)=>{\n        if (!activeChat || !user || !isAuthenticated) return;\n        try {\n            let endpoint = \"\";\n            if (activeChat.type === \"private\") {\n                endpoint = \"\".concat(API_URL, \"/chats/direct/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            } else {\n                endpoint = \"\".concat(API_URL, \"/chats/room/\").concat(activeChat.id, \"?before=\").concat(beforeMessageId);\n            }\n            const response = await axios__WEBPACK_IMPORTED_MODULE_4__[\"default\"].get(endpoint);\n            // Añadir los mensajes anteriores al inicio del array de mensajes\n            setMessages((prev)=>[\n                    ...response.data,\n                    ...prev\n                ]);\n            return response.data.length;\n        } catch (error) {\n            console.error(\"Error al cargar m\\xe1s mensajes:\", error);\n            return 0;\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ChatContext.Provider, {\n        value: {\n            activeChat,\n            messages,\n            rooms,\n            onlineUsers,\n            users,\n            typingUsers,\n            isLoading,\n            isLoadingMessages,\n            unreadMessages,\n            uploadingFiles,\n            setActiveChat: handleActiveChatChange,\n            sendMessage,\n            markAsRead: handleMarkAsRead,\n            startTyping: ()=>setTyping(true),\n            stopTyping: ()=>setTyping(false),\n            loadMoreMessages: fetchMoreMessages,\n            retryFileUpload,\n            cancelFileUpload\n        },\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/edgardurand/Documents/REPOS/chat/packages/web/src/contexts/ChatContext.tsx\",\n        lineNumber: 846,\n        columnNumber: 5\n    }, undefined);\n};\n_s1(ChatProvider, \"WkNbpqBjcVKNxVZQELMlCtrIcQo=\", false, function() {\n    return [\n        _AuthContext__WEBPACK_IMPORTED_MODULE_3__.useAuth\n    ];\n});\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNkaEMsUUFBUWdDLEtBQUssQ0FBQyxvQ0FBaUNBO1lBQy9DLE9BQU87UUFDVDtJQUNGO0lBRUEscUJBQ0UsOERBQUNuRyxZQUFZcU0sUUFBUTtRQUFDOUMsT0FBTztZQUMzQnRKO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDO1lBQ0FDLGVBQWU2RjtZQUNmNUY7WUFDQUMsWUFBWXFMO1lBQ1pwTCxhQUFhLElBQU11SixVQUFVO1lBQzdCdEosWUFBWSxJQUFNc0osVUFBVTtZQUM1QnJKLGtCQUFrQm1MO1lBQ2xCbEw7WUFDQUM7UUFDRjtrQkFDR0c7Ozs7OztBQUdQLEVBQUU7SUE3dkJXRDs7UUFDdUJ0QixpREFBT0E7OztLQUQ5QnNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9jb250ZXh0cy9DaGF0Q29udGV4dC50c3g/MGI1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VNZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlvLCBTb2NrZXQgfSBmcm9tICdzb2NrZXQuaW8tY2xpZW50JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi9BdXRoQ29udGV4dCc7XG5cbmludGVyZmFjZSBVc2VyIHtcbiAgaWQ6IHN0cmluZztcbiAgX2lkPzogc3RyaW5nO1xuICBuYW1lOiBzdHJpbmc7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIGF2YXRhcjogc3RyaW5nO1xuICBpc09ubGluZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBlbnVtIEZpbGVUeXBlIHtcbiAgSU1BR0UgPSAnaW1hZ2UnLFxuICBWSURFTyA9ICd2aWRlbycsXG4gIERPQ1VNRU5UID0gJ2RvY3VtZW50JyxcbiAgQVVESU8gPSAnYXVkaW8nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRmlsZUF0dGFjaG1lbnQge1xuICBmaWxlbmFtZTogc3RyaW5nO1xuICBjb250ZW50VHlwZTogc3RyaW5nO1xuICBmaWxlVHlwZTogRmlsZVR5cGU7XG4gIGRhdGE/OiBzdHJpbmc7IC8vIEJhc2U2NCBlbmNvZGVkIGRhdGEgcGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3NcbiAgc2l6ZT86IG51bWJlcjtcbiAgZmlsZUlkPzogc3RyaW5nOyAvLyBJRCBwYXJhIGFyY2hpdm9zIGdyYW5kZXMgYWxtYWNlbmFkb3MgcG9yIHNlcGFyYWRvXG4gIGlzTGFyZ2VGaWxlPzogYm9vbGVhbjsgLy8gSW5kaWNhIHNpIGVsIGFyY2hpdm8gZXN0w6EgYWxtYWNlbmFkbyBwb3Igc2VwYXJhZG9cbiAgaXNDaHVuaz86IGJvb2xlYW47XG4gIG9yaWdpbmFsRmlsZW5hbWU/OiBzdHJpbmc7XG4gIGNodW5rSW5kZXg/OiBudW1iZXI7XG4gIHRvdGFsQ2h1bmtzPzogbnVtYmVyO1xuICB0ZW1wSWQ/OiBzdHJpbmc7IC8vIElEIHRlbXBvcmFsIHBhcmEgc2VndWltaWVudG8gZGUgY2FyZ2Fcbn1cblxuaW50ZXJmYWNlIE1lc3NhZ2Uge1xuICBfaWQ6IHN0cmluZztcbiAgY29udGVudD86IHN0cmluZztcbiAgYXR0YWNobWVudHM/OiBGaWxlQXR0YWNobWVudFtdO1xuICBzZW5kZXI6IFVzZXI7XG4gIHJlY2lwaWVudD86IHN0cmluZztcbiAgcm9vbT86IHN0cmluZztcbiAgaXNSZWFkOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFJvb20ge1xuICBfaWQ6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBkZXNjcmlwdGlvbj86IHN0cmluZztcbiAgaW1hZ2U/OiBzdHJpbmc7XG4gIGNyZWF0b3I6IFVzZXI7XG4gIG1lbWJlcnM6IFVzZXJbXTtcbiAgaXNQcml2YXRlOiBib29sZWFuO1xuICBjcmVhdGVkQXQ6IHN0cmluZztcbiAgcmVtb3ZlZD86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBDaGF0Q29udGV4dFR5cGUge1xuICBhY3RpdmVDaGF0OiB7IHR5cGU6ICdwcml2YXRlJyB8ICdyb29tJywgaWQ6IHN0cmluZyB9IHwgbnVsbDtcbiAgbWVzc2FnZXM6IE1lc3NhZ2VbXTtcbiAgcm9vbXM6IFJvb21bXTtcbiAgb25saW5lVXNlcnM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+O1xuICB1c2VyczogVXNlcltdO1xuICB0eXBpbmdVc2VyczogUmVjb3JkPHN0cmluZywgYm9vbGVhbiB8IHN0cmluZz47XG4gIGlzTG9hZGluZzogYm9vbGVhbjtcbiAgaXNMb2FkaW5nTWVzc2FnZXM6IGJvb2xlYW47XG4gIHVucmVhZE1lc3NhZ2VzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB1cGxvYWRpbmdGaWxlczogUmVjb3JkPHN0cmluZywgeyBwcm9ncmVzczogbnVtYmVyLCBlcnJvcj86IHN0cmluZyB9PjtcbiAgc2V0QWN0aXZlQ2hhdDogKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB2b2lkO1xuICBzZW5kTWVzc2FnZTogKGNvbnRlbnQ6IHN0cmluZywgYXR0YWNobWVudHM/OiBGaWxlW10pID0+IFByb21pc2U8dm9pZD47XG4gIG1hcmtBc1JlYWQ6IChtZXNzYWdlSWQ6IHN0cmluZykgPT4gdm9pZDtcbiAgc3RhcnRUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIHN0b3BUeXBpbmc6ICgpID0+IHZvaWQ7XG4gIGxvYWRNb3JlTWVzc2FnZXM6IChiZWZvcmVNZXNzYWdlSWQ6IHN0cmluZykgPT4gUHJvbWlzZTxudW1iZXI+O1xuICByZXRyeUZpbGVVcGxvYWQ6IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4gdm9pZDtcbiAgY2FuY2VsRmlsZVVwbG9hZDogKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB2b2lkO1xufVxuXG5jb25zdCBDaGF0Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8Q2hhdENvbnRleHRUeXBlPih7XG4gIGFjdGl2ZUNoYXQ6IG51bGwsXG4gIG1lc3NhZ2VzOiBbXSxcbiAgcm9vbXM6IFtdLFxuICBvbmxpbmVVc2Vyczoge30sXG4gIHVzZXJzOiBbXSxcbiAgdHlwaW5nVXNlcnM6IHt9LFxuICBpc0xvYWRpbmc6IHRydWUsXG4gIGlzTG9hZGluZ01lc3NhZ2VzOiBmYWxzZSxcbiAgdW5yZWFkTWVzc2FnZXM6IHt9LFxuICB1cGxvYWRpbmdGaWxlczoge30sXG4gIHNldEFjdGl2ZUNoYXQ6ICgpID0+IHt9LFxuICBzZW5kTWVzc2FnZTogYXN5bmMgKCkgPT4ge30sXG4gIG1hcmtBc1JlYWQ6ICgpID0+IHt9LFxuICBzdGFydFR5cGluZzogKCkgPT4ge30sXG4gIHN0b3BUeXBpbmc6ICgpID0+IHt9LFxuICBsb2FkTW9yZU1lc3NhZ2VzOiBhc3luYyAoKSA9PiAwLFxuICByZXRyeUZpbGVVcGxvYWQ6ICgpID0+IHt9LFxuICBjYW5jZWxGaWxlVXBsb2FkOiAoKSA9PiB7fSxcbn0pO1xuXG5leHBvcnQgY29uc3QgdXNlQ2hhdCA9ICgpID0+IHVzZUNvbnRleHQoQ2hhdENvbnRleHQpO1xuXG5leHBvcnQgY29uc3QgQ2hhdFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIGNvbnN0IHsgdXNlciwgaXNBdXRoZW50aWNhdGVkIH0gPSB1c2VBdXRoKCk7XG4gIGNvbnN0IFthY3RpdmVDaGF0LCBzZXRBY3RpdmVDaGF0XSA9IHVzZVN0YXRlPHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsPihudWxsKTtcbiAgY29uc3QgW21lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZTxNZXNzYWdlW10+KFtdKTtcbiAgY29uc3QgW3Jvb21zLCBzZXRSb29tc10gPSB1c2VTdGF0ZTxSb29tW10+KFtdKTtcbiAgY29uc3QgW3VzZXJzLCBzZXRVc2Vyc10gPSB1c2VTdGF0ZTxVc2VyW10+KFtdKTtcbiAgY29uc3QgW29ubGluZVVzZXJzLCBzZXRPbmxpbmVVc2Vyc10gPSB1c2VTdGF0ZTxSZWNvcmQ8c3RyaW5nLCBib29sZWFuPj4oe30pO1xuICBjb25zdCBbdHlwaW5nVXNlcnMsIHNldFR5cGluZ1VzZXJzXSA9IHVzZVN0YXRlPFJlY29yZDxzdHJpbmcsIGJvb2xlYW4gfCBzdHJpbmc+Pih7fSk7XG4gIGNvbnN0IFtpc0xvYWRpbmcsIHNldElzTG9hZGluZ10gPSB1c2VTdGF0ZSh0cnVlKTtcbiAgY29uc3QgW2lzTG9hZGluZ01lc3NhZ2VzLCBzZXRJc0xvYWRpbmdNZXNzYWdlc10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzb2NrZXRDb25uZWN0ZWQsIHNldFNvY2tldENvbm5lY3RlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt1bnJlYWRNZXNzYWdlcywgc2V0VW5yZWFkTWVzc2FnZXNdID0gdXNlU3RhdGU8UmVjb3JkPHN0cmluZywgbnVtYmVyPj4oe30pO1xuICBjb25zdCBbdXBsb2FkaW5nRmlsZXNCeUNoYXQsIHNldFVwbG9hZGluZ0ZpbGVzQnlDaGF0XSA9IHVzZVN0YXRlPHtcbiAgICBbY2hhdElkOiBzdHJpbmddOiB7XG4gICAgICBbZmlsZUlkOiBzdHJpbmddOiB7XG4gICAgICAgIHByb2dyZXNzOiBudW1iZXI7XG4gICAgICAgIGVycm9yPzogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfT4oe30pO1xuICBjb25zdCBbc2VsZWN0ZWRGaWxlLCBzZXRTZWxlY3RlZEZpbGVdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xuICBcbiAgY29uc3QgdXBsb2FkaW5nRmlsZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIWFjdGl2ZUNoYXQpIHJldHVybiB7fTtcbiAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgIHJldHVybiB1cGxvYWRpbmdGaWxlc0J5Q2hhdFtjaGF0SWRdIHx8IHt9O1xuICB9LCBbYWN0aXZlQ2hhdCwgdXBsb2FkaW5nRmlsZXNCeUNoYXRdKTtcblxuICBjb25zdCB1cGRhdGVVcGxvYWRpbmdGaWxlcyA9IHVzZUNhbGxiYWNrKChcbiAgICBjaGF0SWQ6IHN0cmluZyxcbiAgICBmaWxlSWQ6IHN0cmluZyxcbiAgICBzdGF0dXM6IHsgcHJvZ3Jlc3M6IG51bWJlcjsgZXJyb3I/OiBzdHJpbmcgfSB8IG51bGxcbiAgKSA9PiB7XG4gICAgc2V0VXBsb2FkaW5nRmlsZXNCeUNoYXQocHJldiA9PiB7XG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHsgLi4ucHJldiB9O1xuICAgICAgXG4gICAgICAvLyBTaSBubyBleGlzdGUgZWwgY2hhdCwgbG8gY3JlYW1vc1xuICAgICAgaWYgKCFuZXdTdGF0ZVtjaGF0SWRdKSB7XG4gICAgICAgIG5ld1N0YXRlW2NoYXRJZF0gPSB7fTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gU2kgc3RhdHVzIGVzIG51bGwsIGVsaW1pbmFyIGVsIGFyY2hpdm9cbiAgICAgIGlmIChzdGF0dXMgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXSkge1xuICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdW2ZpbGVJZF07XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2kgbm8gcXVlZGFuIGFyY2hpdm9zIGVuIGVzdGUgY2hhdCwgZWxpbWluYXIgdGFtYmnDqW4gbGEgZW50cmFkYSBkZWwgY2hhdFxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZVtjaGF0SWRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWN0dWFsaXphciBlbCBlc3RhZG8gZGVsIGFyY2hpdm9cbiAgICAgICAgbmV3U3RhdGVbY2hhdElkXVtmaWxlSWRdID0gc3RhdHVzO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfSk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBjYW5jZWxGaWxlVXBsb2FkID0gKGZpbGU6IEZpbGVBdHRhY2htZW50KSA9PiB7XG4gICAgaWYgKCFmaWxlLnRlbXBJZCB8fCAhYWN0aXZlQ2hhdCkgcmV0dXJuO1xuICAgIFxuICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCBmaWxlLnRlbXBJZCwgbnVsbCk7XG4gIH07XG5cbiAgY29uc3Qgc29ja2V0UmVmID0gdXNlUmVmPFNvY2tldCB8IG51bGw+KG51bGwpO1xuICBjb25zdCBjdXJyZW50QWN0aXZlQ2hhdFJlZiA9IHVzZVJlZihhY3RpdmVDaGF0KTtcbiAgY29uc3QgZmlsZUlucHV0UmVmID0gdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwpO1xuICBcbiAgLy8gS2VlcCB0aGUgcmVmIGluIHN5bmMgd2l0aCB0aGUgc3RhdGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50ID0gYWN0aXZlQ2hhdDtcbiAgfSwgW2FjdGl2ZUNoYXRdKTtcbiAgXG4gIGNvbnN0IEFQSV9VUkwgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjMwMDEnO1xuICBcbiAgLy8gSW5pdGlhbGl6ZSBzb2NrZXQgY29ubmVjdGlvbiB3aGVuIGF1dGhlbnRpY2F0ZWRcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCB8fCAhdXNlcikge1xuICAgICAgaWYgKHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2V0U29ja2V0Q29ubmVjdGVkKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndG9rZW4nKTtcbiAgICBcbiAgICBpZiAoIXRva2VuKSByZXR1cm47XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQgPSBpbyhBUElfVVJMLCB7XG4gICAgICBhdXRoOiB7IHRva2VuIH0sXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHRydWUsXG4gICAgICAvLyBBdW1lbnRhciBlbCB0aWVtcG8gZGUgZXNwZXJhIHBhcmEgcGVybWl0aXIgZW52w61vIGRlIGFyY2hpdm9zIGdyYW5kZXNcbiAgICAgIHRpbWVvdXQ6IDYwMDAwIC8vIGF1bWVudGFyIGVsIHRpZW1wbyBkZSBlc3BlcmEgYSA2MCBzZWd1bmRvc1xuICAgIH0pO1xuICAgIFxuICAgIC8vIFNvY2tldCBldmVudCBsaXN0ZW5lcnNcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ25ld19tZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2UpID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgXG4gICAgICAvLyBJZGVudGlmaWNhciBsYSBjbGF2ZSBkZSBjaGF0IHBhcmEgc2VndWltaWVudG8gZGUgbm90aWZpY2FjaW9uZXNcbiAgICAgIGxldCBjaGF0S2V5ID0gJyc7XG4gICAgICBpZiAobWVzc2FnZS5yb29tKSB7XG4gICAgICAgIGNoYXRLZXkgPSBgcm9vbV8ke21lc3NhZ2Uucm9vbX1gO1xuICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLnNlbmRlci5faWQgIT09IHVzZXIuaWQpIHtcbiAgICAgICAgY2hhdEtleSA9IGB1c2VyXyR7bWVzc2FnZS5zZW5kZXIuX2lkfWA7XG4gICAgICB9IGVsc2UgaWYgKG1lc3NhZ2UucmVjaXBpZW50KSB7XG4gICAgICAgIGNoYXRLZXkgPSBgdXNlcl8ke21lc3NhZ2UucmVjaXBpZW50fWA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIFNvbG8gYWdyZWdhciBlbCBtZW5zYWplIHNpIGVzIHJlbGV2YW50ZSBwYXJhIGVsIGNoYXQgYWN0aXZvXG4gICAgICBpZiAoXG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncHJpdmF0ZScgJiYgXG4gICAgICAgICAgKChtZXNzYWdlLnNlbmRlci5faWQgPT09IGFjdGl2ZUNoYXQuaWQgJiYgbWVzc2FnZS5yZWNpcGllbnQgPT09IHVzZXIuaWQpIHx8IFxuICAgICAgICAgICAobWVzc2FnZS5zZW5kZXIuX2lkID09PSB1c2VyLmlkICYmIG1lc3NhZ2UucmVjaXBpZW50ID09PSBhY3RpdmVDaGF0LmlkKSkpIHx8XG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgbWVzc2FnZS5yb29tID09PSBhY3RpdmVDaGF0LmlkKVxuICAgICAgKSB7XG4gICAgICAgIHNldE1lc3NhZ2VzKHByZXYgPT4gWy4uLnByZXYsIG1lc3NhZ2VdKTtcbiAgICAgIH0gXG4gICAgICAvLyBTaSBlbCBtZW5zYWplIG5vIGVzIHBhcmEgZWwgY2hhdCBhY3Rpdm8geSBubyBmdWUgZW52aWFkbyBwb3IgZWwgdXN1YXJpbyBhY3R1YWwsIGluY3JlbWVudGFyIGNvbnRhZG9yXG4gICAgICBlbHNlIGlmIChtZXNzYWdlLnNlbmRlci5faWQgIT09IHVzZXIuaWQgJiYgY2hhdEtleSkge1xuICAgICAgICBjb25zb2xlLmxvZygnTmV3IG1lc3NhZ2Ugbm90aWZpY2F0aW9uOicsIGNoYXRLZXksIG1lc3NhZ2UpO1xuICAgICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBbY2hhdEtleV06IChwcmV2W2NoYXRLZXldIHx8IDApICsgMVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3VzZXJfc3RhdHVzX2NoYW5nZScsICh7IHVzZXJJZCwgaXNPbmxpbmUgfSkgPT4ge1xuICAgICAgc2V0T25saW5lVXNlcnMocHJldiA9PiAoeyAuLi5wcmV2LCBbdXNlcklkXTogaXNPbmxpbmUgfSkpO1xuICAgIH0pO1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCd0eXBpbmdfaW5kaWNhdG9yJywgKGRhdGE6IHsgdXNlcklkOiBzdHJpbmcsIHVzZXJOYW1lOiBzdHJpbmcsIGlzVHlwaW5nOiBib29sZWFuLCByb29tSWQ/OiBzdHJpbmcsIHNlbmRlcklkPzogc3RyaW5nIH0pID0+IHtcbiAgICAgIGNvbnN0IGFjdGl2ZUNoYXQgPSBjdXJyZW50QWN0aXZlQ2hhdFJlZi5jdXJyZW50O1xuICAgICAgaWYgKFxuICAgICAgICAoYWN0aXZlQ2hhdD8udHlwZSA9PT0gJ3ByaXZhdGUnICYmIGRhdGEuc2VuZGVySWQgPT09IGFjdGl2ZUNoYXQuaWQpIHx8XG4gICAgICAgIChhY3RpdmVDaGF0Py50eXBlID09PSAncm9vbScgJiYgZGF0YS5yb29tSWQgPT09IGFjdGl2ZUNoYXQuaWQpXG4gICAgICApIHtcbiAgICAgICAgLy8gQWxtYWNlbmFyIG5vbWJyZSBlbiBsdWdhciBkZSBzb2xvIGxhIGJhbmRlcmEgYm9vbGVhbmFcbiAgICAgICAgc2V0VHlwaW5nVXNlcnMocHJldiA9PiAoeyBcbiAgICAgICAgICAuLi5wcmV2LCBcbiAgICAgICAgICBbZGF0YS51c2VySWRdOiBkYXRhLmlzVHlwaW5nID8gZGF0YS51c2VyTmFtZSA6IGZhbHNlIFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ21lc3NhZ2VfcmVhZCcsICh7IG1lc3NhZ2VJZCB9KSA9PiB7XG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChtc2cgPT4gXG4gICAgICAgICAgbXNnLl9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIGlzUmVhZDogdHJ1ZSB9IDogbXNnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gSGFuZGxlIG5ldyByb29tIGNyZWF0aW9uc1xuICAgIHNvY2tldFJlZi5jdXJyZW50Lm9uKCduZXdfcm9vbScsIChyb29tOiBSb29tKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnTmV3IHJvb20gcmVjZWl2ZWQ6Jywgcm9vbSk7XG4gICAgICBzZXRSb29tcyhwcmV2ID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJvb20gYWxyZWFkeSBleGlzdHNcbiAgICAgICAgY29uc3QgZXhpc3RzID0gcHJldi5zb21lKHIgPT4gci5faWQgPT09IHJvb20uX2lkKTtcbiAgICAgICAgaWYgKGV4aXN0cykgcmV0dXJuIHByZXY7XG4gICAgICAgIHJldHVybiBbLi4ucHJldiwgcm9vbV07XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBIYW5kbGUgcm9vbSB1cGRhdGVzIChtZW1iZXJzIGFkZGVkL3JlbW92ZWQpXG4gICAgc29ja2V0UmVmLmN1cnJlbnQub24oJ3Jvb21fdXBkYXRlZCcsIChyb29tOiBSb29tKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZygnUm9vbSB1cGRhdGVkOicsIHJvb20pO1xuICAgICAgaWYgKHJvb20ucmVtb3ZlZCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJvb20gd2FzIHJlbW92ZWQgZm9yIHRoaXMgdXNlciwgcmVtb3ZlIGl0IGZyb20gdGhlIGxpc3RcbiAgICAgICAgc2V0Um9vbXMocHJldiA9PiBwcmV2LmZpbHRlcihyID0+IHIuX2lkICE9PSByb29tLl9pZCkpO1xuICAgICAgICBcbiAgICAgICAgLy8gSWYgYWN0aXZlIGNoYXQgaXMgdGhpcyByb29tLCBjbGVhciBpdFxuICAgICAgICBjb25zdCBhY3RpdmVDaGF0ID0gY3VycmVudEFjdGl2ZUNoYXRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGFjdGl2ZUNoYXQ/LnR5cGUgPT09ICdyb29tJyAmJiBhY3RpdmVDaGF0LmlkID09PSByb29tLl9pZCkge1xuICAgICAgICAgIHNldEFjdGl2ZUNoYXQobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcm9vbSBpbiB0aGUgbGlzdFxuICAgICAgICBzZXRSb29tcyhwcmV2ID0+IHByZXYubWFwKHIgPT4gci5faWQgPT09IHJvb20uX2lkID8gcm9vbSA6IHIpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBzb2NrZXRSZWYuY3VycmVudC5vbignZGlzY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTb2NrZXQgZGlzY29ubmVjdGVkJyk7XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoc29ja2V0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICBzb2NrZXRSZWYuY3VycmVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzZXRTb2NrZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgIH07XG4gIH0sIFtpc0F1dGhlbnRpY2F0ZWQsIHVzZXIsIEFQSV9VUkxdKTtcbiAgXG4gIC8vIExvYWQgaW5pdGlhbCBkYXRhOiB1c2VycyBhbmQgcm9vbXNcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIWlzQXV0aGVudGljYXRlZCkge1xuICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgZmV0Y2hJbml0aWFsRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IFt1c2Vyc1Jlc3BvbnNlLCByb29tc1Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vdXNlcnNgKSxcbiAgICAgICAgICBheGlvcy5nZXQoYCR7QVBJX1VSTH0vcm9vbXMvbXlgKVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIHNldFVzZXJzKHVzZXJzUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIHNldFJvb21zKHJvb21zUmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBTZXQgaW5pdGlhbCBvbmxpbmUgc3RhdHVzXG4gICAgICAgIGNvbnN0IGluaXRpYWxPbmxpbmVTdGF0dXM6IFJlY29yZDxzdHJpbmcsIGJvb2xlYW4+ID0ge307XG4gICAgICAgIHVzZXJzUmVzcG9uc2UuZGF0YS5mb3JFYWNoKCh1c2VyOiBVc2VyKSA9PiB7XG4gICAgICAgICAgaW5pdGlhbE9ubGluZVN0YXR1c1t1c2VyLl9pZCFdID0gdXNlci5pc09ubGluZSB8fCBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNldE9ubGluZVVzZXJzKGluaXRpYWxPbmxpbmVTdGF0dXMpO1xuICAgICAgICBcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGluaXRpYWwgZGF0YTonLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hJbml0aWFsRGF0YSgpO1xuICB9LCBbaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBDdWFuZG8gc2UgaW5pY2lhIGVsIHNvY2tldCB5IHNlIGNvbmVjdGEsIHNvbGljaXRhbW9zIGVsIGVzdGFkbyBhY3R1YWwgZGUgbWVuc2FqZXMgbm8gbGXDrWRvc1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzb2NrZXRDb25uZWN0ZWQgJiYgc29ja2V0UmVmLmN1cnJlbnQgJiYgdXNlcikge1xuICAgICAgLy8gU29saWNpdGFyIG1lbnNhamVzIG5vIGxlw61kb3MgYWwgc2Vydmlkb3JcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ2dldF91bnJlYWRfbWVzc2FnZXMnKTtcbiAgICAgIFxuICAgICAgLy8gRXNjdWNoYXIgbGEgcmVzcHVlc3RhIGNvbiBlbCByZWN1ZW50byBkZSBtZW5zYWplcyBubyBsZcOtZG9zXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5vbigndW5yZWFkX21lc3NhZ2VzX2NvdW50JywgKHVucmVhZENvdW50czogUmVjb3JkPHN0cmluZywgbnVtYmVyPikgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVjZWl2ZWQgdW5yZWFkIGNvdW50czonLCB1bnJlYWRDb3VudHMpO1xuICAgICAgICBzZXRVbnJlYWRNZXNzYWdlcyh1bnJlYWRDb3VudHMpO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHNvY2tldFJlZi5jdXJyZW50Py5vZmYoJ3VucmVhZF9tZXNzYWdlc19jb3VudCcpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtzb2NrZXRDb25uZWN0ZWQsIHVzZXJdKTtcblxuICAvLyBBc2VndXJhcnNlIGRlIHF1ZSBsb3MgbWVuc2FqZXMgc2UgbWFycXVlbiBjb21vIGxlw61kb3MgY3VhbmRvIHNlIGFicmUgdW4gY2hhdFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChhY3RpdmVDaGF0ICYmIHNvY2tldFJlZi5jdXJyZW50KSB7XG4gICAgICAvLyBDcmVhciB1bmEgY2xhdmUgcGFyYSBlbCBjaGF0IGFjdHVhbFxuICAgICAgY29uc3QgY2hhdEtleSA9IGFjdGl2ZUNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnIFxuICAgICAgICA/IGB1c2VyXyR7YWN0aXZlQ2hhdC5pZH1gIFxuICAgICAgICA6IGByb29tXyR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgXG4gICAgICAvLyBSZXNldGVhciBlbCBjb250YWRvciBkZSBtZW5zYWplcyBubyBsZcOtZG9zIHBhcmEgZXN0ZSBjaGF0XG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIFtjaGF0S2V5XTogMFxuICAgICAgfSkpO1xuICAgICAgXG4gICAgICAvLyBOb3RpZmljYXIgYWwgc2Vydmlkb3IgcXVlIGxvcyBtZW5zYWplcyBzZSBoYW4gbGXDrWRvXG4gICAgICBzb2NrZXRSZWYuY3VycmVudC5lbWl0KCdtYXJrX21lc3NhZ2VzX3JlYWQnLCB7XG4gICAgICAgIGNoYXRJZDogYWN0aXZlQ2hhdC5pZCxcbiAgICAgICAgY2hhdFR5cGU6IGFjdGl2ZUNoYXQudHlwZVxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbYWN0aXZlQ2hhdF0pO1xuICBcbiAgLy8gRnVuY2nDs24gcGFyYSBtYW5lamFyIGVsIGNhbWJpbyBkZSBjaGF0IGFjdGl2b1xuICBjb25zdCBoYW5kbGVBY3RpdmVDaGF0Q2hhbmdlID0gKGNoYXQ6IHsgdHlwZTogJ3ByaXZhdGUnIHwgJ3Jvb20nLCBpZDogc3RyaW5nIH0gfCBudWxsKSA9PiB7XG4gICAgLy8gTGltcGlhciBsYXMgbm90aWZpY2FjaW9uZXMgbm8gbGXDrWRhcyBjdWFuZG8gc2UgYWN0aXZhIHVuIGNoYXRcbiAgICBpZiAoY2hhdCkge1xuICAgICAgY29uc3QgY2hhdEtleSA9IGNoYXQudHlwZSA9PT0gJ3ByaXZhdGUnID8gYHVzZXJfJHtjaGF0LmlkfWAgOiBgcm9vbV8ke2NoYXQuaWR9YDtcbiAgICAgIHNldFVucmVhZE1lc3NhZ2VzKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgW2NoYXRLZXldOiAwXG4gICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIHNldEFjdGl2ZUNoYXQoY2hhdCk7XG4gIH07XG5cbiAgLy8gRWZlY3RvIHBhcmEgYWN0dWFsaXphciBsb3MgbWVuc2FqZXMgY3VhbmRvIGNhbWJpYSBlbCBjaGF0IGFjdGl2b1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhaXNBdXRoZW50aWNhdGVkKSByZXR1cm47XG4gICAgXG4gICAgLy8gUmVzZXRlYXIgZWwgZXN0YWRvIGFsIGNhbWJpYXIgZGUgY2hhdFxuICAgIHNldE1lc3NhZ2VzKFtdKTtcbiAgICBzZXRJc0xvYWRpbmdNZXNzYWdlcyh0cnVlKTtcbiAgICBcbiAgICAvLyBSZWluaWNpYXIgZXN0YWRvcyBkZSBtZW5zYWplcyBubyBsZcOtZG9zIHkgYXJjaGl2b3MgZW4gY2FyZ2FcbiAgICBpZiAoYWN0aXZlQ2hhdCkge1xuICAgICAgLy8gTGltcGlhciBtZW5zYWplcyBubyBsZcOtZG9zXG4gICAgICBzZXRVbnJlYWRNZXNzYWdlcyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgY2hhdEtleSA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICAgIGlmIChwcmV2W2NoYXRLZXldKSB7XG4gICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7IC4uLnByZXYgfTtcbiAgICAgICAgICBkZWxldGUgbmV3U3RhdGVbY2hhdEtleV07XG4gICAgICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIEFzZWd1cmFybm9zIGRlIHF1ZSBsYSBzZWNjacOzbiBcIkFyY2hpdm9zIGVuIHByb2Nlc29cIiBkZXNhcGFyZXpjYSBhbCBjYW1iaWFyIGRlIGNoYXRcbiAgICAgIC8vIGluY2x1c28gY3VhbmRvIHlhIGhhYsOtYSB0ZXJtaW5hZG8gbGEgY2FyZ2EgY29uIDEwMCVcbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQudHlwZX0tJHthY3RpdmVDaGF0LmlkfWA7XG4gICAgICBpZiAoY2hhdElkIGluIHVwbG9hZGluZ0ZpbGVzQnlDaGF0KSB7XG4gICAgICAgIGNvbnN0IGhhc0NvbXBsZXRlZFVwbG9hZHMgPSBPYmplY3QudmFsdWVzKHVwbG9hZGluZ0ZpbGVzQnlDaGF0W2NoYXRJZF0pXG4gICAgICAgICAgLnNvbWUoc3RhdHVzID0+IHN0YXR1cy5wcm9ncmVzcyA9PT0gMTAwKTtcbiAgICAgICAgICBcbiAgICAgICAgaWYgKGhhc0NvbXBsZXRlZFVwbG9hZHMpIHtcbiAgICAgICAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gey4uLnByZXZ9O1xuICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2NoYXRJZF07XG4gICAgICAgICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTb2xpY2l0YXIgbWVuc2FqZXMgYWwgc2Vydmlkb3JcbiAgICBjb25zdCBmZXRjaE1lc3NhZ2VzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGVuZHBvaW50ID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScpIHtcbiAgICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKb2luIHVzZXIgcm9vbSBmb3IgZGlyZWN0IG1lc3NhZ2VzXG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2pvaW5fcm9vbScsIHsgdXNlcklkOiBhY3RpdmVDaGF0LmlkIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVuZHBvaW50ID0gYCR7QVBJX1VSTH0vY2hhdHMvcm9vbS8ke2FjdGl2ZUNoYXQuaWR9YDtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBKb2luIHJvb21cbiAgICAgICAgICBzb2NrZXRSZWYuY3VycmVudD8uZW1pdCgnam9pbl9yb29tJywgeyByb29tSWQ6IGFjdGl2ZUNoYXQuaWQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGVuZHBvaW50KTtcbiAgICAgICAgc2V0TWVzc2FnZXMocmVzcG9uc2UuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICAvLyBNYXJjYXIgbG9zIG1lbnNhamVzIGNvbW8gbGXDrWRvcyBlbiBlbCBzZXJ2aWRvclxuICAgICAgICBpZiAocmVzcG9uc2UuZGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ21hcmtfbWVzc2FnZXNfcmVhZCcsIHtcbiAgICAgICAgICAgIGNoYXRUeXBlOiBhY3RpdmVDaGF0LnR5cGUsXG4gICAgICAgICAgICBjaGF0SWQ6IGFjdGl2ZUNoYXQuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbWVzc2FnZXM6JywgZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNMb2FkaW5nTWVzc2FnZXMoZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZmV0Y2hNZXNzYWdlcygpO1xuICAgIFxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBDbGVhbiB1cCAtIGxlYXZlIHJvb21zXG4gICAgICBpZiAoYWN0aXZlQ2hhdC50eXBlID09PSAncm9vbScpIHtcbiAgICAgICAgc29ja2V0UmVmLmN1cnJlbnQ/LmVtaXQoJ2xlYXZlX3Jvb20nLCB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbYWN0aXZlQ2hhdCwgdXNlciwgaXNBdXRoZW50aWNhdGVkLCBBUElfVVJMXSk7XG4gIFxuICAvLyBFZmVjdG8gcGFyYSBsaW1waWFyIGFyY2hpdm9zIGNvbXBsZXRhZG9zIGF1dG9tw6F0aWNhbWVudGVcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBSZXZpc2EgY2FkYSAyIHNlZ3VuZG9zIHNpIGhheSBhcmNoaXZvcyBxdWUgZXN0w6FuIGFsIDEwMCUgcXVlIGRlYmFuIGVsaW1pbmFyc2VcbiAgICBjb25zdCBjbGVhbnVwSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXRVcGxvYWRpbmdGaWxlc0J5Q2hhdChwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB7Li4ucHJldn07XG4gICAgICAgIGxldCBoYXNDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBSZXZpc2FyIHRvZG9zIGxvcyBjaGF0c1xuICAgICAgICBPYmplY3Qua2V5cyhuZXdTdGF0ZSkuZm9yRWFjaChjaGF0SWQgPT4ge1xuICAgICAgICAgIC8vIFJldmlzYXIgdG9kb3MgbG9zIGFyY2hpdm9zIGVuIGVzZSBjaGF0XG4gICAgICAgICAgT2JqZWN0LmtleXMobmV3U3RhdGVbY2hhdElkXSkuZm9yRWFjaChmaWxlSWQgPT4ge1xuICAgICAgICAgICAgLy8gU2kgdW4gYXJjaGl2byBlc3TDoSBhbCAxMDAlLCBlbGltaW5hcmxvXG4gICAgICAgICAgICBpZiAobmV3U3RhdGVbY2hhdElkXVtmaWxlSWRdLnByb2dyZXNzID09PSAxMDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG5ld1N0YXRlW2NoYXRJZF1bZmlsZUlkXTtcbiAgICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gU2kgZWwgY2hhdCB5YSBubyB0aWVuZSBhcmNoaXZvcywgZWxpbWluYXIgZWwgY2hhdFxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZVtjaGF0SWRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBuZXdTdGF0ZVtjaGF0SWRdO1xuICAgICAgICAgICAgaGFzQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBoYXNDaGFuZ2VzID8gbmV3U3RhdGUgOiBwcmV2O1xuICAgICAgfSk7XG4gICAgfSwgMjAwMCk7XG4gICAgXG4gICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoY2xlYW51cEludGVydmFsKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IHNlbmRNZXNzYWdlID0gYXN5bmMgKGNvbnRlbnQ6IHN0cmluZywgYXR0YWNobWVudHM/OiBGaWxlW10pID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50IHx8ICFhY3RpdmVDaGF0KSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIEdlbmVyYXIgdGVtcElkcyBwYXJhIGxvcyBhcmNoaXZvcyB5IGNvbnZlcnRpcmxvcyBhIEZpbGVBdHRhY2htZW50XG4gICAgICBjb25zdCBhdHRhY2htZW50c1dpdGhJZHM6IEZpbGVBdHRhY2htZW50W10gPSBbXTtcbiAgICAgIFxuICAgICAgaWYgKGF0dGFjaG1lbnRzICYmIGF0dGFjaG1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgY29uc3QgdGVtcElkID0gYHRlbXAtJHtEYXRlLm5vdygpfS0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCA5KX1gO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIERldGVybWluYXIgdGlwbyBkZSBhcmNoaXZvIGRlIGZvcm1hIHNlZ3VyYVxuICAgICAgICAgIGxldCBmaWxlVHlwZSA9IEZpbGVUeXBlLkRPQ1VNRU5UO1xuICAgICAgICAgIGNvbnN0IGZpbGVUeXBlU3RyaW5nID0gZmlsZS50eXBlIHx8ICcnOyAvLyBVc2FyIHN0cmluZyB2YWPDrW8gc2kgdHlwZSBlcyB1bmRlZmluZWRcbiAgICAgICAgICBpZiAoZmlsZVR5cGVTdHJpbmcuc3RhcnRzV2l0aCgnaW1hZ2UvJykpIHtcbiAgICAgICAgICAgIGZpbGVUeXBlID0gRmlsZVR5cGUuSU1BR0U7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWxlVHlwZVN0cmluZy5zdGFydHNXaXRoKCd2aWRlby8nKSkge1xuICAgICAgICAgICAgZmlsZVR5cGUgPSBGaWxlVHlwZS5WSURFTztcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVUeXBlU3RyaW5nLnN0YXJ0c1dpdGgoJ2F1ZGlvLycpKSB7XG4gICAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLkFVRElPO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWxlVHlwZSA9IEZpbGVUeXBlLkRPQ1VNRU5UO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDcmVhciBvYmpldG8gRmlsZUF0dGFjaG1lbnQgcGFyYSBlbCBhcmNoaXZvXG4gICAgICAgICAgY29uc3QgYXR0YWNobWVudDogRmlsZUF0dGFjaG1lbnQgPSB7XG4gICAgICAgICAgICB0ZW1wSWQsXG4gICAgICAgICAgICBmaWxlbmFtZTogZmlsZS5uYW1lIHx8ICdhcmNoaXZvJyxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBmaWxlLnR5cGUgfHwgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICBmaWxlVHlwZSxcbiAgICAgICAgICAgIHNpemU6IGZpbGUuc2l6ZSB8fCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSBlcyB1biBhcmNoaXZvIGdyYW5kZSwgbG8gcHJvY2VzYW1vcyBwYXJhIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgICAgaWYgKGZpbGUuc2l6ZSA+IDUgKiAxMDI0ICogMTAyNCkgeyAvLyBNw6FzIGRlIDVNQlxuICAgICAgICAgICAgYXR0YWNobWVudC5pc0xhcmdlRmlsZSA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIExlZXIgY29tbyBiYXNlNjQgcGFyYSBwcmVwcm9jZXNhbWllbnRvXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAgIC8vIFF1aXRhciBlbCBwcmVmaWpvIChlai4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NENsZWFuID0gYmFzZTY0ZGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IGJhc2U2NENsZWFuO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJbmljaWFyIHN1YmlkYSBlbiBzZWd1bmRvIHBsYW5vXG4gICAgICAgICAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0LnR5cGV9LSR7YWN0aXZlQ2hhdC5pZH1gO1xuICAgICAgICAgICAgdXBkYXRlVXBsb2FkaW5nRmlsZXMoY2hhdElkLCB0ZW1wSWQsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFncmVnYXIgYSBsYSBsaXN0YSBkZSBhZGp1bnRvc1xuICAgICAgICAgICAgYXR0YWNobWVudHNXaXRoSWRzLnB1c2goYXR0YWNobWVudCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEluaWNpYXIgc3ViaWRhIGVuIHNlZ3VuZG8gcGxhbm9cbiAgICAgICAgICAgIHVwbG9hZExhcmdlRmlsZVRvU2VydmVyKGF0dGFjaG1lbnQpLnRoZW4oZmlsZUlkID0+IHtcbiAgICAgICAgICAgICAgaWYgKGZpbGVJZCkge1xuICAgICAgICAgICAgICAgIC8vIEFjdHVhbGl6YXIgZWwgYXR0YWNobWVudCBjb24gZWwgZmlsZUlkXG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5maWxlSWQgPSBmaWxlSWQ7XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5pc0xhcmdlRmlsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXR0YWNobWVudC5kYXRhID0gdW5kZWZpbmVkOyAvLyBFbGltaW5hciBsb3MgZGF0b3MgYmluYXJpb3NcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxpemFyIHByb2dyZXNvIGEgMTAwJVxuICAgICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgdGVtcElkLCB7IHByb2dyZXNzOiAxMDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igc3ViaWVuZG8gYXJjaGl2bzonLCBlcnJvcik7XG4gICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCwgdGVtcElkLCB7IHByb2dyZXNzOiAwLCBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2bycgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUGFyYSBhcmNoaXZvcyBwZXF1ZcOxb3MgKDw1TUIpLCBsZWVybG9zIGNvbW8gYmFzZTY0IHkgZW52aWFyIGNvbiBlbCBtZW5zYWplXG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSByZWFkZXIucmVzdWx0Py50b1N0cmluZygpIHx8ICcnO1xuICAgICAgICAgICAgICAgIC8vIFF1aXRhciBlbCBwcmVmaWpvIChlai4gXCJkYXRhOmltYWdlL2pwZWc7YmFzZTY0LFwiKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NENsZWFuID0gYmFzZTY0ZGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgICAgICAgICAgIGF0dGFjaG1lbnQuZGF0YSA9IGJhc2U2NENsZWFuO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBZ3JlZ2FyIGEgbGEgbGlzdGEgZGUgYWRqdW50b3NcbiAgICAgICAgICAgIGF0dGFjaG1lbnRzV2l0aElkcy5wdXNoKGF0dGFjaG1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBQcmVwYXJhciBkYXRvcyBkZWwgbWVuc2FqZVxuICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgIGNvbnRlbnQsXG4gICAgICAgIGF0dGFjaG1lbnRzOiBhdHRhY2htZW50c1dpdGhJZHMsXG4gICAgICAgIC4uLihhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJyA/IHsgcmVjaXBpZW50SWQ6IGFjdGl2ZUNoYXQuaWQgfSA6IHsgcm9vbUlkOiBhY3RpdmVDaGF0LmlkIH0pLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gRW52aWFyIGVsIG1lbnNhamUgYSB0cmF2w6lzIGRlbCBzb2NrZXRcbiAgICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ3NlbmRfbWVzc2FnZScsIG1lc3NhZ2VEYXRhLCAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBlbnZpYXIgbWVuc2FqZTonLCByZXNwb25zZS5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBMaW1waWFyIGZvcm11bGFyaW8gZGVzcHXDqXMgZGUgZW52aWFyXG4gICAgICBpZiAoZmlsZUlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgZmlsZUlucHV0UmVmLmN1cnJlbnQudmFsdWUgPSAnJztcbiAgICAgIH1cbiAgICAgIHNldFNlbGVjdGVkRmlsZShudWxsKTtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBwcm9jZXNhciBtZW5zYWplOicsIGVycm9yKTtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBjcmVhdGVSb29tID0gYXN5bmMgKG5hbWU6IHN0cmluZywgZGVzY3JpcHRpb24gPSAnJywgaXNQcml2YXRlID0gZmFsc2UsIG1lbWJlcnM6IHN0cmluZ1tdID0gW10pID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhIH0gPSBhd2FpdCBheGlvcy5wb3N0KGAke0FQSV9VUkx9L3Jvb21zYCwge1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgaXNQcml2YXRlLFxuICAgICAgICBtZW1iZXJzLFxuICAgICAgfSk7XG4gICAgICBcbiAgICAgIC8vIE5vIG5lZWQgdG8gbWFudWFsbHkgYWRkIHRvIHJvb21zIGFycmF5LCB0aGUgc29ja2V0IGV2ZW50IHdpbGwgaGFuZGxlIGl0XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCB1cGRhdGVSb29tID0gYXN5bmMgKHJvb21JZDogc3RyaW5nLCB1cGRhdGVEYXRhOiB7IG5hbWU/OiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nOyBpbWFnZT86IHN0cmluZzsgaXNQcml2YXRlPzogYm9vbGVhbiB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YSB9ID0gYXdhaXQgYXhpb3MucHV0KGAke0FQSV9VUkx9L3Jvb21zLyR7cm9vbUlkfWAsIHVwZGF0ZURhdGEpO1xuICAgICAgXG4gICAgICAvLyBVcGRhdGUgdGhlIHJvb20gaW4gdGhlIGxvY2FsIHN0YXRlIHRvIGltbWVkaWF0ZWx5IHJlZmxlY3QgY2hhbmdlc1xuICAgICAgc2V0Um9vbXMocHJldlJvb21zID0+IFxuICAgICAgICBwcmV2Um9vbXMubWFwKHJvb20gPT4gXG4gICAgICAgICAgcm9vbS5faWQgPT09IHJvb21JZCA/IHsgLi4ucm9vbSwgLi4uZGF0YSB9IDogcm9vbVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgdXBkYXRpbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBqb2luUm9vbSA9IGFzeW5jIChyb29tSWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyICYmICF1c2VySWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgLy8gSWYgdXNlcklkIGlzIHByb3ZpZGVkLCB1c2UgaXQgKGZvciBhZG1pbiBhZGRpbmcgb3RoZXJzKVxuICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBjdXJyZW50IHVzZXIncyBJRCAoZm9yIHNlbGYtam9pbmluZylcbiAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCB1c2VyIS5pZDtcbiAgICAgIGF3YWl0IGF4aW9zLnBvc3QoYCR7QVBJX1VSTH0vcm9vbXMvJHtyb29tSWR9L21lbWJlcnMvJHt0YXJnZXRVc2VySWR9YCk7XG4gICAgICAvLyBSb29tIHVwZGF0ZSB3aWxsIGJlIGhhbmRsZWQgYnkgc29ja2V0IGV2ZW50XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGpvaW5pbmcgcm9vbTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBsZWF2ZVJvb20gPSBhc3luYyAocm9vbUlkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlciAmJiAhdXNlcklkKSByZXR1cm47XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIHVzZXJJZCBpcyBwcm92aWRlZCwgdXNlIGl0IChmb3IgYWRtaW4gcmVtb3Zpbmcgb3RoZXJzKVxuICAgICAgLy8gT3RoZXJ3aXNlIHVzZSBjdXJyZW50IHVzZXIncyBJRCAoZm9yIHNlbGYtbGVhdmluZylcbiAgICAgIGNvbnN0IHRhcmdldFVzZXJJZCA9IHVzZXJJZCB8fCB1c2VyIS5pZDtcbiAgICAgIGF3YWl0IGF4aW9zLmRlbGV0ZShgJHtBUElfVVJMfS9yb29tcy8ke3Jvb21JZH0vbWVtYmVycy8ke3RhcmdldFVzZXJJZH1gKTtcbiAgICAgIC8vIFJvb20gdXBkYXRlIHdpbGwgYmUgaGFuZGxlZCBieSBzb2NrZXQgZXZlbnRcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbGVhdmluZyByb29tOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcbiAgXG4gIGNvbnN0IHNldFR5cGluZyA9IChpc1R5cGluZzogYm9vbGVhbikgPT4ge1xuICAgIGlmICghYWN0aXZlQ2hhdCB8fCAhc29ja2V0UmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBcbiAgICBjb25zdCB0eXBpbmdEYXRhID0ge1xuICAgICAgaXNUeXBpbmcsXG4gICAgICAuLi4oYWN0aXZlQ2hhdC50eXBlID09PSAncHJpdmF0ZScgPyB7IHJlY2lwaWVudElkOiBhY3RpdmVDaGF0LmlkIH0gOiB7IHJvb21JZDogYWN0aXZlQ2hhdC5pZCB9KSxcbiAgICB9O1xuICAgIFxuICAgIHNvY2tldFJlZi5jdXJyZW50LmVtaXQoJ3R5cGluZycsIHR5cGluZ0RhdGEpO1xuICB9O1xuICBcbiAgY29uc3QgY2xlYXJDaGF0SGlzdG9yeSA9IGFzeW5jIChyZWNpcGllbnRJZDogc3RyaW5nKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZGVsZXRlKGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke3JlY2lwaWVudElkfWApO1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgbWVzc2FnZTogJ0NoYXQgaGlzdG9yeSBjbGVhcmVkIHN1Y2Nlc3NmdWxseScgfTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2xlYXJpbmcgY2hhdCBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBtZXNzYWdlOiAnRmFpbGVkIHRvIGNsZWFyIGNoYXQgaGlzdG9yeScgfTtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBJbXBsZW1lbnRhY2nDs24gZGUgcmV0cnlGaWxlVXBsb2FkXG4gIGNvbnN0IHJldHJ5RmlsZVVwbG9hZCA9IChmaWxlOiBGaWxlQXR0YWNobWVudCkgPT4ge1xuICAgIGlmICghZmlsZS50ZW1wSWQpIHJldHVybjtcbiAgICBcbiAgICAvLyBSZXNldCBwcm9ncmVzc1xuICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQ/LnR5cGV9LSR7YWN0aXZlQ2hhdD8uaWR9YDtcbiAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQhLCBmaWxlLnRlbXBJZCEsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgXG4gICAgLy8gUHJlcGFyZSBmb3IgcmUtdXBsb2FkXG4gICAgaWYgKGZpbGUuZGF0YSkge1xuICAgICAgLy8gRXMgdW4gYXJjaGl2byB5YSBjb252ZXJ0aWRvIGEgYmFzZTY0XG4gICAgICB1cGxvYWRMYXJnZUZpbGVUb1NlcnZlcihmaWxlKTtcbiAgICB9IGVsc2UgaWYgKGZpbGUuZmlsZUlkKSB7XG4gICAgICAvLyBSZW1vdmVyIGVsIGVycm9yIHBlcm8gbWFudGVuZXIgZWwgcHJvZ3Jlc28gY29tbyBjb21wbGV0YWRvXG4gICAgICAvLyB5YSBxdWUgZWwgYXJjaGl2byB5YSBlc3TDoSBzdWJpZG9cbiAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGZpbGUudGVtcElkISwgeyBwcm9ncmVzczogMTAwLCBlcnJvcjogdW5kZWZpbmVkIH0pO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEZ1bmNpw7NuIGF1eGlsaWFyIHBhcmEgc3ViaXIgdW4gYXJjaGl2byBncmFuZGUgZGlyZWN0YW1lbnRlIGFsIHNlcnZpZG9yXG4gIGNvbnN0IHVwbG9hZExhcmdlRmlsZVRvU2VydmVyID0gYXN5bmMgKGF0dGFjaG1lbnQ6IEZpbGVBdHRhY2htZW50KTogUHJvbWlzZTxzdHJpbmcgfCBudWxsPiA9PiB7XG4gICAgaWYgKCFhdHRhY2htZW50LnRlbXBJZCkge1xuICAgICAgYXR0YWNobWVudC50ZW1wSWQgPSBgdGVtcC0ke0RhdGUubm93KCl9LSR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsIDkpfWA7XG4gICAgfVxuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0aXIgZGF0b3MgYmFzZTY0IGEgQmxvYiBwYXJhIHN1YmlyXG4gICAgICBjb25zdCBiYXNlNjREYXRhID0gYXR0YWNobWVudC5kYXRhIHx8ICcnO1xuICAgICAgY29uc3QgYnl0ZUNoYXJhY3RlcnMgPSBhdG9iKGJhc2U2NERhdGEpO1xuICAgICAgY29uc3QgYnl0ZUFycmF5cyA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBieXRlQ2hhcmFjdGVycy5sZW5ndGg7IG9mZnNldCArPSA1MTIpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UgPSBieXRlQ2hhcmFjdGVycy5zbGljZShvZmZzZXQsIG9mZnNldCArIDUxMik7XG4gICAgICAgIGNvbnN0IGJ5dGVOdW1iZXJzID0gbmV3IEFycmF5KHNsaWNlLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBieXRlTnVtYmVyc1tpXSA9IHNsaWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZU51bWJlcnMpO1xuICAgICAgICBieXRlQXJyYXlzLnB1c2goYnl0ZUFycmF5KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKGJ5dGVBcnJheXMsIHsgdHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZSB9KTtcbiAgICAgIGNvbnN0IGZpbGUgPSBuZXcgRmlsZShbYmxvYl0sIGF0dGFjaG1lbnQuZmlsZW5hbWUsIHsgdHlwZTogYXR0YWNobWVudC5jb250ZW50VHlwZSB9KTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXIgRm9ybURhdGEgcGFyYSBsYSBzdWJpZGFcbiAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQoJ2ZpbGUnLCBmaWxlKTtcbiAgICAgIFxuICAgICAgLy8gSW5pY2lhciBsYSBjYXJnYSB5IGFjdHVhbGl6YXIgZWwgZXN0YWRvXG4gICAgICBjb25zdCBjaGF0SWQgPSBgJHthY3RpdmVDaGF0Py50eXBlfS0ke2FjdGl2ZUNoYXQ/LmlkfWA7XG4gICAgICB1cGRhdGVVcGxvYWRpbmdGaWxlcyhjaGF0SWQhLCBhdHRhY2htZW50LnRlbXBJZCEsIHsgcHJvZ3Jlc3M6IDAsIGVycm9yOiB1bmRlZmluZWQgfSk7XG4gICAgICBcbiAgICAgIC8vIFJlYWxpemFyIGxhIHN1YmlkYSBjb24gc2VndWltaWVudG8gZGUgcHJvZ3Jlc29cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MucG9zdChgJHtBUElfVVJMfS9maWxlLXN0b3JhZ2UvdXBsb2FkYCwgZm9ybURhdGEsIHtcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YSdcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGxvYWRQcm9ncmVzczogKHByb2dyZXNzRXZlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCBwZXJjZW50Q29tcGxldGVkID0gcHJvZ3Jlc3NFdmVudC50b3RhbCBcbiAgICAgICAgICAgID8gTWF0aC5yb3VuZCgocHJvZ3Jlc3NFdmVudC5sb2FkZWQgKiAxMDApIC8gcHJvZ3Jlc3NFdmVudC50b3RhbClcbiAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBwcm9ncmVzczogcGVyY2VudENvbXBsZXRlZCwgZXJyb3I6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBTaSBlbCBhcmNoaXZvIGhhIHRlcm1pbmFkbyBkZSBjYXJnYXJzZSAoMTAwJSksIGxvIGVsaW1pbmFtb3MgZGUgbGEgbGlzdGEgZGVzcHXDqXMgZGUgdW4gYnJldmUgdGllbXBvXG4gICAgICAgICAgaWYgKHBlcmNlbnRDb21wbGV0ZWQgPT09IDEwMCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgbnVsbCk7XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBpZiAocmVzcG9uc2UuZGF0YSAmJiByZXNwb25zZS5kYXRhLmZpbGVJZCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5maWxlSWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhbCBzdWJpciBhcmNoaXZvOicsIGVycm9yKTtcbiAgICAgIGNvbnN0IGNoYXRJZCA9IGAke2FjdGl2ZUNoYXQ/LnR5cGV9LSR7YWN0aXZlQ2hhdD8uaWR9YDtcbiAgICAgIHVwZGF0ZVVwbG9hZGluZ0ZpbGVzKGNoYXRJZCEsIGF0dGFjaG1lbnQudGVtcElkISwgeyBcbiAgICAgICAgcHJvZ3Jlc3M6IDAsIFxuICAgICAgICBlcnJvcjogZXJyb3IubWVzc2FnZSB8fCAnRXJyb3IgYWwgc3ViaXIgZWwgYXJjaGl2bydcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRXN0YSBmdW5jacOzbiBzZSBlbmNhcmdhIGRlIG1hcmNhciB1biBtZW5zYWplIGNvbW8gbGXDrWRvXG4gIGNvbnN0IGhhbmRsZU1hcmtBc1JlYWQgPSAobWVzc2FnZUlkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXNvY2tldFJlZi5jdXJyZW50KSByZXR1cm47XG4gICAgXG4gICAgc29ja2V0UmVmLmN1cnJlbnQuZW1pdCgnbWFya19tZXNzYWdlX3JlYWQnLCB7IG1lc3NhZ2VJZCB9KTtcbiAgICBcbiAgICAvLyBBY3R1YWxpemFyIGVsIGVzdGFkbyBkZSBtZW5zYWplcyBsb2NhbG1lbnRlXG4gICAgc2V0TWVzc2FnZXMocHJldiA9PiBcbiAgICAgIHByZXYubWFwKG1zZyA9PiBcbiAgICAgICAgbXNnLl9pZCA9PT0gbWVzc2FnZUlkID8geyAuLi5tc2csIGlzUmVhZDogdHJ1ZSB9IDogbXNnXG4gICAgICApXG4gICAgKTtcbiAgfTtcbiAgXG4gIC8vIEVzdGEgZnVuY2nDs24gY2FyZ2EgbcOhcyBtZW5zYWplcyBwYXJhIGxhIHBhZ2luYWNpw7NuXG4gIGNvbnN0IGZldGNoTW9yZU1lc3NhZ2VzID0gYXN5bmMgKGJlZm9yZU1lc3NhZ2VJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCFhY3RpdmVDaGF0IHx8ICF1c2VyIHx8ICFpc0F1dGhlbnRpY2F0ZWQpIHJldHVybjtcbiAgICBcbiAgICB0cnkge1xuICAgICAgbGV0IGVuZHBvaW50ID0gJyc7XG4gICAgICBcbiAgICAgIGlmIChhY3RpdmVDaGF0LnR5cGUgPT09ICdwcml2YXRlJykge1xuICAgICAgICBlbmRwb2ludCA9IGAke0FQSV9VUkx9L2NoYXRzL2RpcmVjdC8ke2FjdGl2ZUNoYXQuaWR9P2JlZm9yZT0ke2JlZm9yZU1lc3NhZ2VJZH1gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5kcG9pbnQgPSBgJHtBUElfVVJMfS9jaGF0cy9yb29tLyR7YWN0aXZlQ2hhdC5pZH0/YmVmb3JlPSR7YmVmb3JlTWVzc2FnZUlkfWA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuZ2V0KGVuZHBvaW50KTtcbiAgICAgIFxuICAgICAgLy8gQcOxYWRpciBsb3MgbWVuc2FqZXMgYW50ZXJpb3JlcyBhbCBpbmljaW8gZGVsIGFycmF5IGRlIG1lbnNhamVzXG4gICAgICBzZXRNZXNzYWdlcyhwcmV2ID0+IFsuLi5yZXNwb25zZS5kYXRhLCAuLi5wcmV2XSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmxlbmd0aDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWwgY2FyZ2FyIG3DoXMgbWVuc2FqZXM6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICBcbiAgcmV0dXJuIChcbiAgICA8Q2hhdENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3tcbiAgICAgIGFjdGl2ZUNoYXQsXG4gICAgICBtZXNzYWdlcyxcbiAgICAgIHJvb21zLFxuICAgICAgb25saW5lVXNlcnMsXG4gICAgICB1c2VycyxcbiAgICAgIHR5cGluZ1VzZXJzLFxuICAgICAgaXNMb2FkaW5nLFxuICAgICAgaXNMb2FkaW5nTWVzc2FnZXMsXG4gICAgICB1bnJlYWRNZXNzYWdlcyxcbiAgICAgIHVwbG9hZGluZ0ZpbGVzLFxuICAgICAgc2V0QWN0aXZlQ2hhdDogaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSxcbiAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgbWFya0FzUmVhZDogaGFuZGxlTWFya0FzUmVhZCxcbiAgICAgIHN0YXJ0VHlwaW5nOiAoKSA9PiBzZXRUeXBpbmcodHJ1ZSksXG4gICAgICBzdG9wVHlwaW5nOiAoKSA9PiBzZXRUeXBpbmcoZmFsc2UpLFxuICAgICAgbG9hZE1vcmVNZXNzYWdlczogZmV0Y2hNb3JlTWVzc2FnZXMsXG4gICAgICByZXRyeUZpbGVVcGxvYWQsXG4gICAgICBjYW5jZWxGaWxlVXBsb2FkXG4gICAgfX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9DaGF0Q29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlTWVtbyIsInVzZUNhbGxiYWNrIiwiaW8iLCJheGlvcyIsInVzZUF1dGgiLCJGaWxlVHlwZSIsIkNoYXRDb250ZXh0IiwiYWN0aXZlQ2hhdCIsIm1lc3NhZ2VzIiwicm9vbXMiLCJvbmxpbmVVc2VycyIsInVzZXJzIiwidHlwaW5nVXNlcnMiLCJpc0xvYWRpbmciLCJpc0xvYWRpbmdNZXNzYWdlcyIsInVucmVhZE1lc3NhZ2VzIiwidXBsb2FkaW5nRmlsZXMiLCJzZXRBY3RpdmVDaGF0Iiwic2VuZE1lc3NhZ2UiLCJtYXJrQXNSZWFkIiwic3RhcnRUeXBpbmciLCJzdG9wVHlwaW5nIiwibG9hZE1vcmVNZXNzYWdlcyIsInJldHJ5RmlsZVVwbG9hZCIsImNhbmNlbEZpbGVVcGxvYWQiLCJ1c2VDaGF0IiwiQ2hhdFByb3ZpZGVyIiwiY2hpbGRyZW4iLCJ1c2VyIiwiaXNBdXRoZW50aWNhdGVkIiwic2V0TWVzc2FnZXMiLCJzZXRSb29tcyIsInNldFVzZXJzIiwic2V0T25saW5lVXNlcnMiLCJzZXRUeXBpbmdVc2VycyIsInNldElzTG9hZGluZyIsInNldElzTG9hZGluZ01lc3NhZ2VzIiwic29ja2V0Q29ubmVjdGVkIiwic2V0U29ja2V0Q29ubmVjdGVkIiwic2V0VW5yZWFkTWVzc2FnZXMiLCJ1cGxvYWRpbmdGaWxlc0J5Q2hhdCIsInNldFVwbG9hZGluZ0ZpbGVzQnlDaGF0Iiwic2VsZWN0ZWRGaWxlIiwic2V0U2VsZWN0ZWRGaWxlIiwiY2hhdElkIiwidHlwZSIsImlkIiwidXBkYXRlVXBsb2FkaW5nRmlsZXMiLCJmaWxlSWQiLCJzdGF0dXMiLCJwcmV2IiwibmV3U3RhdGUiLCJPYmplY3QiLCJrZXlzIiwibGVuZ3RoIiwiZmlsZSIsInRlbXBJZCIsInNvY2tldFJlZiIsImN1cnJlbnRBY3RpdmVDaGF0UmVmIiwiZmlsZUlucHV0UmVmIiwiY3VycmVudCIsIkFQSV9VUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImRpc2Nvbm5lY3QiLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJhdXRoIiwid2l0aENyZWRlbnRpYWxzIiwidGltZW91dCIsIm9uIiwiY29uc29sZSIsImxvZyIsIm1lc3NhZ2UiLCJjaGF0S2V5Iiwicm9vbSIsInNlbmRlciIsIl9pZCIsInJlY2lwaWVudCIsInVzZXJJZCIsImlzT25saW5lIiwiZGF0YSIsInNlbmRlcklkIiwicm9vbUlkIiwiaXNUeXBpbmciLCJ1c2VyTmFtZSIsIm1lc3NhZ2VJZCIsIm1hcCIsIm1zZyIsImlzUmVhZCIsImV4aXN0cyIsInNvbWUiLCJyIiwicmVtb3ZlZCIsImZpbHRlciIsImZldGNoSW5pdGlhbERhdGEiLCJ1c2Vyc1Jlc3BvbnNlIiwicm9vbXNSZXNwb25zZSIsIlByb21pc2UiLCJhbGwiLCJnZXQiLCJpbml0aWFsT25saW5lU3RhdHVzIiwiZm9yRWFjaCIsImVycm9yIiwiZW1pdCIsInVucmVhZENvdW50cyIsIm9mZiIsImNoYXRUeXBlIiwiaGFuZGxlQWN0aXZlQ2hhdENoYW5nZSIsImNoYXQiLCJoYXNDb21wbGV0ZWRVcGxvYWRzIiwidmFsdWVzIiwicHJvZ3Jlc3MiLCJmZXRjaE1lc3NhZ2VzIiwiZW5kcG9pbnQiLCJyZXNwb25zZSIsImNsZWFudXBJbnRlcnZhbCIsInNldEludGVydmFsIiwiaGFzQ2hhbmdlcyIsImNsZWFySW50ZXJ2YWwiLCJjb250ZW50IiwiYXR0YWNobWVudHMiLCJhdHRhY2htZW50c1dpdGhJZHMiLCJNYXRoIiwiRGF0ZSIsIm5vdyIsInJhbmRvbSIsInRvU3RyaW5nIiwic3Vic3RyaW5nIiwiZmlsZVR5cGUiLCJmaWxlVHlwZVN0cmluZyIsInN0YXJ0c1dpdGgiLCJhdHRhY2htZW50IiwiZmlsZW5hbWUiLCJuYW1lIiwiY29udGVudFR5cGUiLCJzaXplIiwiaXNMYXJnZUZpbGUiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsInJlc29sdmUiLCJvbmxvYWQiLCJiYXNlNjRkYXRhIiwicmVzdWx0IiwiYmFzZTY0Q2xlYW4iLCJzcGxpdCIsInVuZGVmaW5lZCIsInB1c2giLCJ1cGxvYWRMYXJnZUZpbGVUb1NlcnZlciIsInRoZW4iLCJjYXRjaCIsIm1lc3NhZ2VEYXRhIiwicmVjaXBpZW50SWQiLCJzdWNjZXNzIiwidmFsdWUiLCJjcmVhdGVSb29tIiwiZGVzY3JpcHRpb24iLCJpc1ByaXZhdGUiLCJtZW1iZXJzIiwicG9zdCIsInVwZGF0ZVJvb20iLCJ1cGRhdGVEYXRhIiwicHV0IiwicHJldlJvb21zIiwiam9pblJvb20iLCJ0YXJnZXRVc2VySWQiLCJsZWF2ZVJvb20iLCJkZWxldGUiLCJzZXRUeXBpbmciLCJ0eXBpbmdEYXRhIiwiY2xlYXJDaGF0SGlzdG9yeSIsImJhc2U2NERhdGEiLCJieXRlQ2hhcmFjdGVycyIsImF0b2IiLCJieXRlQXJyYXlzIiwib2Zmc2V0Iiwic2xpY2UiLCJieXRlTnVtYmVycyIsIkFycmF5IiwiaSIsImNoYXJDb2RlQXQiLCJieXRlQXJyYXkiLCJVaW50OEFycmF5IiwiYmxvYiIsIkJsb2IiLCJGaWxlIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsImhlYWRlcnMiLCJvblVwbG9hZFByb2dyZXNzIiwicHJvZ3Jlc3NFdmVudCIsInBlcmNlbnRDb21wbGV0ZWQiLCJ0b3RhbCIsInJvdW5kIiwibG9hZGVkIiwic2V0VGltZW91dCIsImhhbmRsZU1hcmtBc1JlYWQiLCJmZXRjaE1vcmVNZXNzYWdlcyIsImJlZm9yZU1lc3NhZ2VJZCIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/contexts/ChatContext.tsx\n"));

/***/ })

});